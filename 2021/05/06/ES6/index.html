<!DOCTYPE html><html lang="cn" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>ES6 | ManyFish's 破站</title><meta name="author" content="manyfish"><meta name="copyright" content="manyfish"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="ES6ES6是什么是JavaScript语言的下一代标准，在2015年6月正式发布。Mozilla公司将在这个标准的基础上，推出JavaScript 2.0 ECMAScript是JavaScript语言的国际标准，JavaScript是ECMAScript的实现。 使JavaScript语言可以用来编写大型的复杂的应用程序，成为企业级开发语言。 关于浏览器不能浏览的解决 ：安装babel转码器">
<meta property="og:type" content="article">
<meta property="og:title" content="ES6">
<meta property="og:url" content="http://example.com/2021/05/06/ES6/index.html">
<meta property="og:site_name" content="ManyFish&#39;s 破站">
<meta property="og:description" content="ES6ES6是什么是JavaScript语言的下一代标准，在2015年6月正式发布。Mozilla公司将在这个标准的基础上，推出JavaScript 2.0 ECMAScript是JavaScript语言的国际标准，JavaScript是ECMAScript的实现。 使JavaScript语言可以用来编写大型的复杂的应用程序，成为企业级开发语言。 关于浏览器不能浏览的解决 ：安装babel转码器">
<meta property="og:locale">
<meta property="og:image" content="http://example.com/img/Banner_img.jpg">
<meta property="article:published_time" content="2021-05-06T00:36:00.000Z">
<meta property="article:modified_time" content="2021-06-04T03:43:40.534Z">
<meta property="article:author" content="manyfish">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/Banner_img.jpg"><link rel="shortcut icon" href="/img/frog.png"><link rel="canonical" href="http://example.com/2021/05/06/ES6/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"Traditional Chinese Activated Manually","cht_to_chs":"Simplified Chinese Activated Manually","day_to_night":"Dark Mode Activated Manually","night_to_day":"Light Mode Activated Manually","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-06-04 11:43:40'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    })(window)</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/static-butterfly/dist/css/index.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css"><script src="https://cdn.jsdelivr.net/gh/stevenjoezhang/live2d-widget@latest/autoload.js"></script><html style="cursor:url('img/Arrow.cur'),default"><meta name="generator" content="Hexo 5.4.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/img/head_img.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">17</div></a></div></div></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/Banner_img.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">ManyFish's 破站</a></span><div id="menus"><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">ES6</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2021-05-06T00:36:00.000Z" title="Created 2021-05-06 08:36:00">2021-05-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2021-06-04T03:43:40.534Z" title="Updated 2021-06-04 11:43:40">2021-06-04</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="ES6"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">Comments:</span><a href="/2021/05/06/ES6/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count" data-xid="/2021/05/06/ES6/" itemprop="commentCount"></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h1><h2 id="ES6是什么"><a href="#ES6是什么" class="headerlink" title="ES6是什么"></a>ES6是什么</h2><p>是JavaScript语言的下一代标准，在2015年6月正式发布。Mozilla公司将在这个标准的基础上，推出JavaScript 2.0</p>
<p>ECMAScript是JavaScript语言的国际标准，JavaScript是ECMAScript的实现。</p>
<p>使JavaScript语言可以用来编写大型的复杂的应用程序，成为企业级开发语言。</p>
<p>关于浏览器不能浏览的解决 ：安装babel转码器</p>
<p>为什么使用es6:前端唯一的编程语言</p>
<p>es6增强了可预测性，相比于js属于弱类型语言 精准性不高 语法分散 不可预测性高</p>
<p>增加了新变量声明关键字</p>
<p>ES6官方中文教程：<a target="_blank" rel="noopener" href="http://es6.ruanyifeng.com/">http://es6.ruanyifeng.com/</a></p>
<h1 id="ES6新的语法"><a href="#ES6新的语法" class="headerlink" title="ES6新的语法"></a>ES6新的语法</h1><h2 id="1-常量"><a href="#1-常量" class="headerlink" title="1.常量"></a><strong>1.常量</strong></h2><p><strong>ES5没有定义声明常量的方式，ES6标准中引入了新的关键字c o n s t来定义常量。</strong></p>
<p><strong>常量必须给初始值； 常量不能在同一作用域内重新定义或赋值；</strong> </p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> PI = <span class="number">3.14</span>;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(PI);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="2-块级作用域"><a href="#2-块级作用域" class="headerlink" title="2.块级作用域"></a><strong>2.块级作用域</strong></h2><p><strong>JS中作用域有：全局作用域、函数作用域</strong></p>
<p> <strong>ES6中新增了块级作用域。</strong></p>
<p>   <strong>块作用域由 { } 包括，if语句和for语句里面的{ }就属于块作用域。(不包括函数)</strong></p>
<h3 id="2-1-作用域"><a href="#2-1-作用域" class="headerlink" title="2.1.**作用域 **"></a>2.1.**作用域 **</h3><p><strong>全局作用域</strong>    声明在函数外 let var声明都是全局函数 <strong>差别</strong> var是window属性 —let不是window属性</p>
<p><strong>局部作用域</strong>    声明在函数内 var声明</p>
<p><strong>块级作用域</strong>    声明在{ }内 let声明</p>
<p><strong>this–动态作用域</strong>    this指向</p>
<p><strong>块作用域由 { } 包括，if语句和for语句里面的{ }就属于块作用域。(不包括函数)</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意 块级作用域中，使用var声明的变量是全局变量</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(a);<span class="comment">//1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a);<span class="comment">//1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(b);<span class="comment">//2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(b);<span class="comment">//2</span></span><br></pre></td></tr></table></figure>

<h3 id="2-2-let关键字"><a href="#2-2-let关键字" class="headerlink" title="2.2.let关键字"></a><strong>2.2.let关键字</strong></h3><p><strong>ES6中增加了let关键字声明变量，声明的变量只在当前代码块中生效（块级作用域）****。</strong>、**</p>
<p>** <strong>使用<code>let</code>声明的变量可以重新赋值,但是不能在同一作用域内重新声明</strong></p>
<p>let命令：<strong>声明变量</strong>     使用方法类似var，但let只在块级作用域中有效，（衍生块级作用域理论）。</p>
<p>for循环小括号内为父作用域 花括号内为子作用域</p>
<p>let变量必须先声明后使用 不存在变量提升 不能直接赋值 就近原则 先取值在同一块级作用域内 不能重复声明</p>
<p>暂时性死区：在同一块级作用域内先调用let值不声明会报错</p>
<p>为什么需要块级作用域：解决书写时的范围问题 </p>
<p>用来声明变量</p>
<p>防止循环变量变为全局变量</p>
<h3 id="2-3-const关键字"><a href="#2-3-const关键字" class="headerlink" title="2.3.const关键字"></a>2.3.const关键字</h3><p>const声明一个只读的常量 不能改动—报错 同let有死区，不存在变量提升 不允许重复声明</p>
<p>扩展：Object.freeze(对象) 冻结对象的属性和方法 使其无法操作 不可扩展属性与方法 严格模式</p>
<h2 id="3-解构赋值"><a href="#3-解构赋值" class="headerlink" title="3.解构赋值"></a>3.解构赋值</h2><p>解构赋值是<strong>对赋值运算符的扩展</strong>。</p>
<p>是一种针对数组或者对象进行模式匹配，然后对其中的变量进行赋值。</p>
<p>在代码书写上简洁易读，语义更加清晰；方便了复杂对象中数据字段获取。</p>
<h3 id="3-1解构模型"><a href="#3-1解构模型" class="headerlink" title="3.1解构模型"></a>3.1解构模型</h3><p>在解构中，有下面两部分参与：</p>
<p><strong>解构的源</strong>，解构赋值表达式的右边部分。</p>
<p><strong>解构的目标</strong>，解构赋值表达式的左边部分。</p>
<h3 id="3-2数组解构"><a href="#3-2数组解构" class="headerlink" title="3.2数组解构"></a>3.2数组解构</h3><p><strong>基础用法</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [x,y,...z] = [<span class="string">&quot;a&quot;</span>];</span><br><span class="line"><span class="comment">//&quot;a&quot;,undefined,[]</span></span><br></pre></td></tr></table></figure>

<p><strong>可嵌套</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, [[b], c]] = [<span class="number">1</span>, [[<span class="number">2</span>], <span class="number">3</span>]]; </span><br><span class="line"><span class="comment">// a = 1 // b = 2 // c = 3</span></span><br></pre></td></tr></table></figure>

<p><strong>可忽略</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, , b] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="comment">// a = 1 // b = 3</span></span><br></pre></td></tr></table></figure>

<p><strong>不完全解构</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a = <span class="number">1</span>, b] = []; </span><br><span class="line"><span class="comment">// a = 1, b = undefined</span></span><br></pre></td></tr></table></figure>

<p><strong>剩余运算符</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, ...b] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]; </span><br><span class="line"><span class="comment">//a = 1 </span></span><br><span class="line"><span class="comment">//b = [2, 3]</span></span><br></pre></td></tr></table></figure>

<p><strong>字符串等</strong></p>
<blockquote>
<p>在数组的解构中，解构的目标若为可遍历对象，皆可进行解构赋值。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b, c, d, e] = <span class="string">&#x27;hello&#x27;</span>; </span><br><span class="line"><span class="comment">// a = &#x27;h&#x27; </span></span><br><span class="line"><span class="comment">// b = &#x27;e&#x27; </span></span><br><span class="line"><span class="comment">// c = &#x27;l&#x27; </span></span><br><span class="line"><span class="comment">// d = &#x27;l&#x27; </span></span><br><span class="line"><span class="comment">// e = &#x27;o&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>解构默认值</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a = <span class="number">2</span>] = [<span class="literal">undefined</span>]; </span><br><span class="line"><span class="comment">// a = 2</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>当解构模式有匹配结果，且匹配结果是 undefined 时，会触发默认值作为返回结果。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a = <span class="number">3</span>, b = a] = [];     <span class="comment">// a = 3, b = 3 </span></span><br><span class="line"><span class="keyword">let</span> [a = <span class="number">3</span>, b = a] = [<span class="number">1</span>];    <span class="comment">// a = 1, b = 1 </span></span><br><span class="line"><span class="keyword">let</span> [a = <span class="number">3</span>, b = a] = [<span class="number">1</span>, <span class="number">2</span>]; <span class="comment">// a = 1, b = 2</span></span><br><span class="line"><span class="keyword">let</span> [a = b, b = <span class="number">3</span>] = [];	<span class="comment">//ReferenceError:b is not defind</span></span><br></pre></td></tr></table></figure>

<ul>
<li>a 与 b 匹配结果为 undefined ，触发默认值：<strong>a = 3; b = a =3</strong></li>
<li>a 正常解构赋值，匹配结果：a = 1，b 匹配结果 undefined ，触发默认值：<strong>b = a =1</strong></li>
<li>a 与 b 正常解构赋值，匹配结果：<strong>a = 1，b = 2</strong></li>
<li>先运行<strong>a = b</strong> 因为没有定义b 所以会导致报错</li>
</ul>
<blockquote>
<p>数组成员的值不严格等于undefined，默认值不生效(null的话相应值依然为null)</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [x=<span class="number">1</span>,y=<span class="number">2</span>,z=<span class="number">3</span>,o=<span class="number">4</span>] = [<span class="string">&#x27;a&#x27;</span>, ,<span class="literal">undefined</span>,<span class="literal">null</span>]</span><br><span class="line"><span class="comment">//&#x27;a&#x27;,2,3,null</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>等号右边如果不是数组，将会报错（不是可遍历结构）</p>
<p>解构赋值 var, let, const命令声明均适用</p>
<p>set结构也可解构赋值(可采用数组形式结构赋值)</p>
<p>set解构:任何类型的单个值的集合</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [x,y,z] = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>])</span><br><span class="line">x<span class="comment">//&quot;a&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="3-3对象解构"><a href="#3-3对象解构" class="headerlink" title="3.3对象解构"></a>3.3对象解构</h3><p><strong>基本</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; foo, bar &#125; = &#123; <span class="attr">foo</span>: <span class="string">&#x27;aaa&#x27;</span>, <span class="attr">bar</span>: <span class="string">&#x27;bbb&#x27;</span> &#125;; </span><br><span class="line"><span class="comment">// foo = &#x27;aaa&#x27; </span></span><br><span class="line"><span class="comment">// bar = &#x27;bbb&#x27;  </span></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">baz</span> : foo &#125; = &#123; <span class="attr">baz</span> : <span class="string">&#x27;ddd&#x27;</span> &#125;; </span><br><span class="line"><span class="comment">// foo = &#x27;ddd&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>可嵌套可忽略</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">p</span>: [<span class="string">&#x27;hello&#x27;</span>, &#123;<span class="attr">y</span>: <span class="string">&#x27;world&#x27;</span>&#125;] &#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">p</span>: [x, &#123; y &#125;] &#125; = obj;</span><br><span class="line"><span class="comment">// x = &#x27;hello&#x27; </span></span><br><span class="line"><span class="comment">// y = &#x27;world&#x27; </span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">p</span>: [<span class="string">&#x27;hello&#x27;</span>, &#123;<span class="attr">y</span>: <span class="string">&#x27;world&#x27;</span>&#125;] &#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">p</span>: [x, &#123;  &#125;] &#125; = obj; </span><br><span class="line"><span class="comment">// x = &#x27;hello&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>不完全解构</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">p</span>: [&#123;<span class="attr">y</span>: <span class="string">&#x27;world&#x27;</span>&#125;] &#125;; </span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">p</span>: [&#123; y &#125;, x ] &#125; = obj; </span><br><span class="line"><span class="comment">// x = undefined </span></span><br><span class="line"><span class="comment">// y = &#x27;world&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>剩余运算符</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;a, b, ...rest&#125; = &#123;<span class="attr">a</span>: <span class="number">10</span>, <span class="attr">b</span>: <span class="number">20</span>, <span class="attr">c</span>: <span class="number">30</span>, <span class="attr">d</span>: <span class="number">40</span>&#125;; </span><br><span class="line"><span class="comment">// a = 10 </span></span><br><span class="line"><span class="comment">// b = 20 </span></span><br><span class="line"><span class="comment">// rest = &#123;c: 30, d: 40&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>解构默认值</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;a = <span class="number">10</span>, b = <span class="number">5</span>&#125; = &#123;<span class="attr">a</span>: <span class="number">3</span>&#125;; </span><br><span class="line"><span class="comment">// a = 3; b = 5; </span></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">a</span>: aa = <span class="number">10</span>, <span class="attr">b</span>: bb = <span class="number">5</span>&#125; = &#123;<span class="attr">a</span>: <span class="number">3</span>&#125;; </span><br><span class="line"><span class="comment">// aa = 3; bb = 5;</span></span><br></pre></td></tr></table></figure>
<p><strong>数组按次序排列，对象变量必须与属性同名</strong></p>
<p><strong>如果默认值是表达式，表达式惰性求值</strong>，只有在用到的时候才会去执行</p>
<p><strong>默认值可以引用结构赋值的其他变量</strong>，但该变量必须已声明对象结构赋值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123;bar,foo,<span class="attr">baz</span>:loc&#125; = &#123;<span class="attr">foo</span>:<span class="string">&#x27;aaa&#x27;</span>,<span class="attr">baz</span>:<span class="string">&#x27;bbb&#x27;</span>&#125;</span><br><span class="line">bar <span class="comment">//undefined</span></span><br><span class="line">foo	<span class="comment">//&#x27;aaa&#x27;</span></span><br><span class="line">loc	<span class="comment">//&#x27;bbb&#x27;</span></span><br><span class="line">baz	<span class="comment">//ReferenceError:baz is not defind</span></span><br></pre></td></tr></table></figure>

<p><strong>可用于嵌套结构的对象</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> node = &#123;</span><br><span class="line">	loc:&#123;</span><br><span class="line">		start:&#123;</span><br><span class="line">			line:<span class="number">1</span>,</span><br><span class="line">			cloumn:<span class="number">5</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> &#123;<span class="attr">loc</span>:&#123;<span class="attr">start</span>:&#123;line&#125;&#125;&#125; = node</span><br><span class="line">line	<span class="comment">//1</span></span><br><span class="line">loc 	<span class="comment">//ReferenceError:loc is not defind</span></span><br><span class="line">start	<span class="comment">//ReferenceError:start is not defind</span></span><br><span class="line"><span class="comment">//line是变量，loc,start都是模式</span></span><br></pre></td></tr></table></figure>

<p><strong>对象结构可以指定默认值</strong></p>
<blockquote>
<p>(生效条件是对象属性值严格等于undefined，null不会生效，解构失败值为undefined)</p>
</blockquote>
<p><strong>解构模式是嵌套对象，且子对象父属性不存在</strong>，报错</p>
<p><strong>已声明的变量解构赋值</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x;</span><br><span class="line">&#123;x&#125;=&#123;<span class="attr">x</span>:<span class="number">1</span>&#125;	<span class="comment">//SyntaxError: Unexpectted token =</span></span><br><span class="line">(&#123;x&#125;=&#123;<span class="attr">x</span>:<span class="number">1</span>&#125;)	<span class="comment">//正确赋值方法</span></span><br><span class="line"><span class="comment">//js会将&#123;x&#125;理解成代码块，不将大括号写在行首即可</span></span><br></pre></td></tr></table></figure>

<p><strong>可以将现有对象的方法赋值到某个变量</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; sin, cos, log &#125; = <span class="built_in">Math</span></span><br><span class="line"><span class="comment">//(Math对象的名为sin的方法直接赋值给sin变量)</span></span><br></pre></td></tr></table></figure>

<p><strong>字符串解构赋值</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [a,b] = <span class="string">&#x27;hello&#x27;</span> </span><br><span class="line">a<span class="comment">//h</span></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">length</span>:len&#125; = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">len<span class="comment">//5(字符串本身包含length属性)</span></span><br></pre></td></tr></table></figure>

<h1 id="在线转换"><a href="#在线转换" class="headerlink" title="在线转换"></a>在线转换</h1><p>Babel 提供一个<a target="_blank" rel="noopener" href="https://babeljs.io/repl/#?babili=false&browsers=&build=&builtIns=false&code_lz=MYewdgzgLgBMCGAbRAjewDWEBMMC8MA2gLoDcAUAGYgBOAFIgKawBW-MADKTGwDwHZuLANTCAlAG9yMGXCSp0WbIRbF2lAK5hgUAJbg6k6bJM1mGmmB4wAVDGzGZAX3IvQkEEwB0UeCiZ0hI4IyGiYOIQcxIYANMHyYUqEAIzRYnGyIQrhythp0sRiQA&debug=false&forceAllTransforms=false&shippedProposals=false&circleciRepo=&evaluate=false&fileSize=false&lineWrap=true&presets=es2015,react,stage-2&prettier=false&targets=&version=6.26.0&envVersion=">REPL在线编译器</a>，可以在线将 ES6 代码转为 ES5 代码。转换后的代码，可以直接作为 ES5 代码插入网页运行。</p>
<hr>
<h1 id="let和const命令"><a href="#let和const命令" class="headerlink" title="let和const命令"></a>let和const命令</h1><h2 id="let和var的区别"><a href="#let和var的区别" class="headerlink" title="let和var的区别"></a>let和var的区别</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  a[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">a[<span class="number">6</span>](); <span class="comment">// 101234567</span></span><br></pre></td></tr></table></figure>

<p>变量i是var声明的，在全局范围内都有效，所以全局只有一个变量i。每一次循环，变量i的值都会发生改变，而循环内被赋给数组a的function在运行时，会通过闭包读到这同一个变量i，导致最后输出的是最后一轮的i的值，也就是10。</p>
<p>而如果使用let，声明的变量仅在块级作用域内有效，最后输出的是6。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  a[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">a[<span class="number">6</span>](); <span class="comment">// 6</span></span><br><span class="line"><span class="number">12345678</span></span><br></pre></td></tr></table></figure>

<p>变量i是let声明的，当前的i只在本轮循环有效，所以每一次循环的i其实都是一个新的变量，所以最后输出的是6。</p>
<p>for循环语句部分是一个父作用域，而循环体内部是一个单独的子作用域。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// abc</span></span><br><span class="line"><span class="comment">// abc</span></span><br><span class="line"><span class="comment">// abc1234567</span></span><br></pre></td></tr></table></figure>

<p>上面代码输出了3次abc，这表明函数内部的变量i和外部的变量i是分离的。就是说i每循环一次 ，每次产生新的作用域 (块级作用域) 也就是把当前的j值保存下来</p>
<h2 id="不存在变量提升"><a href="#不存在变量提升" class="headerlink" title="不存在变量提升"></a>不存在变量提升</h2><p>var命令会发生”变量提升“现象，即变量可以在声明之前使用，值为undefined。正常情况下，变量应该在声明语句之后才可以使用。</p>
<p>为了纠正这种现象，let命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// var 的情况</span></span><br><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// 输出undefined</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// let 的情况</span></span><br><span class="line"><span class="built_in">console</span>.log(bar); <span class="comment">// 报错ReferenceError</span></span><br><span class="line"><span class="keyword">let</span> bar = <span class="number">2</span>;<span class="number">12345678</span></span><br></pre></td></tr></table></figure>

<h2 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h2><p>块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tmp = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">tmp = ‘abc’; <span class="comment">// ReferenceError</span></span><br><span class="line"><span class="keyword">let</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，存在全局变量tmp，但是块级作用域内let又声明了一个局部变量tmp，导致后者绑定这个块级作用域，所以在let声明变量前，对tmp赋值会报错。</p>
<p>ES6明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。</p>
<p>总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。</p>
<p>*<strong>ES6 规定暂时性死区和let、const语句不出现变量提升*</strong></p>
<h2 id="不允许重复声明"><a href="#不允许重复声明" class="headerlink" title="不允许重复声明"></a>不允许重复声明</h2><p>let不允许在相同作用域内，重复声明同一个变量。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112</span></span><br></pre></td></tr></table></figure>

<p>因此，不能在函数内部重新声明参数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> arg; <span class="comment">// 报错</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">let</span> arg; <span class="comment">// 不报错</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;<span class="number">123456789</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h2><p>ES5 只有全局作用域和函数作用域，没有块级作用域</p>
<p><strong>第一种场景，内层变量可能会覆盖外层变量。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tmp = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(tmp);</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> tmp = <span class="string">&#x27;hello world&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(); <span class="comment">// undefined12345678910</span></span><br></pre></td></tr></table></figure>

<p>if代码块的外部使用外层的tmp变量，内部使用内层的tmp变量。但是，函数f执行后，输出结果为undefined，原因在于变量提升，导致内层的tmp变量覆盖了外层的tmp变量。</p>
<p><strong>第二种，用来计数的循环变量泄露为全局变量。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; s.length; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(s[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(i); <span class="comment">// 51234567</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，变量i只用来控制循环，但是循环结束后，它并没有消失，泄露成了全局变量。</p>
<hr>
<h2 id="ES6-的块级作用域"><a href="#ES6-的块级作用域" class="headerlink" title="ES6 的块级作用域"></a>ES6 的块级作用域</h2><ul>
<li>let实际上为 JavaScript 新增了块级作用域。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> n = <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> n = <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(n); <span class="comment">// 5</span></span><br><span class="line">&#125;<span class="number">1234567</span></span><br></pre></td></tr></table></figure>

<p>上面的函数有两个代码块，都声明了变量n，运行后输出5。这表示外层代码块不受内层代码块的影响。如果使用var定义变量n，最后输出的值就是10。</p>
<p>ES6 允许块级作用域的任意嵌套。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;&#123;&#123;&#123;<span class="keyword">let</span> insane = <span class="string">&#x27;Hello World&#x27;</span>&#125;&#125;&#125;&#125;&#125;;<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>上面代码使用了一个五层的块级作用域。外层作用域无法读取内层作用域的变量。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;&#123;&#123;</span><br><span class="line">  &#123;<span class="keyword">let</span> insane = <span class="string">&#x27;Hello World&#x27;</span>&#125;</span><br><span class="line">  <span class="built_in">console</span>.log(insane); <span class="comment">// 报错</span></span><br><span class="line">&#125;&#125;&#125;&#125;;<span class="number">1234</span></span><br></pre></td></tr></table></figure>

<p>内层作用域可以定义外层作用域的同名变量。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;&#123;&#123;</span><br><span class="line">  <span class="keyword">let</span> insane = <span class="string">&#x27;Hello World&#x27;</span>;</span><br><span class="line">  &#123;<span class="keyword">let</span> insane = <span class="string">&#x27;Hello World&#x27;</span>&#125;</span><br><span class="line">&#125;&#125;&#125;&#125;;<span class="number">1234</span></span><br></pre></td></tr></table></figure>

<p>块级作用域的出现，实际上使得获得广泛应用的立即执行函数表达式（IIFE）不再必要了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IIFE 写法</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> tmp = ...;</span><br><span class="line">  ...</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 块级作用域写法</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> tmp = ...;</span><br><span class="line">  ...</span><br><span class="line">&#125;<span class="number">1234567891011</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="块级作用域与函数声明"><a href="#块级作用域与函数声明" class="headerlink" title="块级作用域与函数声明"></a>块级作用域与函数声明</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">&#x27;I am outside!&#x27;</span>); &#125;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="comment">// 重复声明一次函数f</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">&#x27;I am inside!&#x27;</span>); &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  f();</span><br><span class="line">&#125;());<span class="number">1234567891011</span></span><br></pre></td></tr></table></figure>

<p><strong>上面代码在 ES5 中运行，会得到“I am inside!”,ES6 就完全不一样了，理论上会得到“I am outside!”。因为块级作用域内声明的函数类似于let，对作用域之外没有影响。</strong></p>
<p>*<strong>另外，还有一个需要注意的地方，考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。*</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数声明语句</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="string">&#x27;secret&#x27;</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数表达式</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="string">&#x27;secret&#x27;</span>;</span><br><span class="line">  <span class="keyword">let</span> f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;<span class="number">1234567891011121314151617</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="do-表达式"><a href="#do-表达式" class="headerlink" title="do 表达式"></a>do 表达式</h2><p>块级作用域是一个语句，将多个操作封装在一起，没有返回值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> t = f();</span><br><span class="line">  t = t * t + <span class="number">1</span>;</span><br><span class="line">&#125;<span class="number">1234</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，块级作用域将两个语句封装在一起。但是，在块级作用域以外，没有办法得到t的值，因为块级作用域不返回值，除非t是全局变量。</p>
<p><strong>do表达式，可以返回值。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="keyword">do</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> t = f();</span><br><span class="line">  t * t + <span class="number">1</span>;</span><br><span class="line">&#125;;<span class="number">1234</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，变量x会得到整个块级作用域的返回值。</p>
<hr>
<h2 id="const-命令"><a href="#const-命令" class="headerlink" title="const 命令"></a>const 命令</h2><p>基本用法</p>
<p>*<strong>const声明一个只读的常量。一旦声明，常量的值就不能改变。*</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PI = <span class="number">3.1415</span>;</span><br><span class="line">PI <span class="comment">// 3.1415</span></span><br><span class="line">js</span><br><span class="line">PI = <span class="number">3</span>;</span><br><span class="line"><span class="comment">// TypeError: Assignment to constant variable.12345</span></span><br></pre></td></tr></table></figure>

<p>上面代码表明改变常量的值会报错。</p>
<p><strong>const声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo;</span><br><span class="line"><span class="comment">// SyntaxError: Missing initializer in const declaration12</span></span><br></pre></td></tr></table></figure>

<p>上面代码表示，对于const来说，只声明不赋值，就会报错。</p>
<p><strong>const的作用域与let命令相同：只在声明所在的块级作用域内有效。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> MAX = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line">MAX <span class="comment">// Uncaught ReferenceError: MAX is not defined1234</span></span><br></pre></td></tr></table></figure>

<p><strong>const命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(MAX); <span class="comment">// ReferenceError</span></span><br><span class="line">  <span class="keyword">const</span> MAX = <span class="number">5</span>;</span><br><span class="line">&#125;<span class="number">12345</span></span><br></pre></td></tr></table></figure>

<p>上面代码在常量MAX声明之前就调用，结果报错。</p>
<p><strong>const声明的常量，也与let一样不可重复声明。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> message = <span class="string">&quot;Hello!&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> age = <span class="number">25</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下两行都会报错</span></span><br><span class="line"><span class="keyword">const</span> message = <span class="string">&quot;Goodbye!&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> age = <span class="number">30</span>;<span class="number">123456</span></span><br></pre></td></tr></table></figure>

<p>常量foo储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把foo指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = &#123;&#125;;</span><br><span class="line"><span class="comment">// 为 foo 添加一个属性，可以成功</span></span><br><span class="line">foo.prop = <span class="number">123</span>;</span><br><span class="line">foo.prop <span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 foo 指向另一个对象，就会报错</span></span><br><span class="line">foo = &#123;&#125;; <span class="comment">// TypeError: &quot;foo&quot; is read-only1234567</span></span><br></pre></td></tr></table></figure>

<p>例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [];</span><br><span class="line">a.push(<span class="string">&#x27;Hello&#x27;</span>); <span class="comment">// 可执行</span></span><br><span class="line">a.length = <span class="number">0</span>;    <span class="comment">// 可执行</span></span><br><span class="line">a = [<span class="string">&#x27;Dave&#x27;</span>];    <span class="comment">// 报错1234</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，常量a是一个数组，这个数组本身是可写的，但是如果将另一个数组赋值给a，就会报错。</p>
<p><strong>将对象冻结，应该使用Object.freeze方法。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="built_in">Object</span>.freeze(&#123;&#125;);</span><br><span class="line"><span class="comment">// 常规模式时，下面一行不起作用；</span></span><br><span class="line"><span class="comment">// 严格模式时，该行会报错</span></span><br><span class="line">foo.prop = <span class="number">123</span>;<span class="number">1234</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，常量foo指向一个冻结的对象，所以添加新属性不起作用，严格模式时还会报错。</p>
<p>除了将对象本身冻结，对象的属性也应该冻结。下面是一个将对象彻底冻结的函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> constantize = <span class="function">(<span class="params">obj</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">Object</span>.freeze(obj);</span><br><span class="line">  <span class="built_in">Object</span>.keys(obj).forEach( <span class="function">(<span class="params">key, i</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="keyword">typeof</span> obj[key] === <span class="string">&#x27;object&#x27;</span> ) &#123;</span><br><span class="line">      constantize( obj[key] );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;<span class="number">12345678</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="ES6-声明变量的六种方法"><a href="#ES6-声明变量的六种方法" class="headerlink" title="ES6 声明变量的六种方法"></a>ES6 声明变量的六种方法</h2><p>ES5 有两种声明变量的方法：var命令和function命令。ES6除了添加let和const命令，还有另外两种声明变量的方法：import命令和class命令。所以，ES6 一共有6种声明变量的方法。</p>
<hr>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> &#123;<span class="number">0</span> : first, <span class="number">1</span>:second, [arr.length - <span class="number">1</span>] : last&#125; = arr;</span><br><span class="line"><span class="built_in">console</span>.log(first); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(second); <span class="comment">//</span></span><br><span class="line"><span class="built_in">console</span>.log(last); <span class="comment">// 312345</span></span><br></pre></td></tr></table></figure>

<p>上面代码对数组进行对象解构。***数组arr的0键对应的值是1，[arr.length - 1]就是2键，对应的值是3。***方括号这种写法，属于“属性名表达式”。</p>
<hr>
<h2 id="字符串的解构赋值"><a href="#字符串的解构赋值" class="headerlink" title="字符串的解构赋值"></a>字符串的解构赋值</h2><p>字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [a, b, c, d, e] = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">a <span class="comment">// &quot;h&quot;</span></span><br><span class="line">b <span class="comment">// &quot;e&quot;</span></span><br><span class="line">c <span class="comment">// &quot;l&quot;</span></span><br><span class="line">d <span class="comment">// &quot;l&quot;</span></span><br><span class="line">e <span class="comment">// &quot;o&quot;123456</span></span><br></pre></td></tr></table></figure>

<p><strong>类似数组的对象都有一个length属性，因此还可以对这个属性解构赋值。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="attr">length</span> : len&#125; = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">len <span class="comment">// 512</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="变量的解构赋值"><a href="#变量的解构赋值" class="headerlink" title="变量的解构赋值"></a>变量的解构赋值</h1><h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><p><strong>（1）交换变量的值</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> y = <span class="number">2</span>;</span><br><span class="line">[x,y] = [y,x];</span><br><span class="line"><span class="built_in">console</span>.log(y);  <span class="comment">//x = 2,y = 1;1234</span></span><br></pre></td></tr></table></figure>

<p>这样的写法不仅简洁，而且易读，语义非常清晰。</p>
<p><strong>（2）从函数返回多个值</strong><br>函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回一个数组</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> [a, b, c] = example();</span><br><span class="line">  <span class="built_in">console</span>.table([a,b,c]);<span class="number">123456</span></span><br></pre></td></tr></table></figure>

<p><strong>结果：</strong><br><img src="/2021/05/06/ES6/20180519230829265" alt="这里写图片描述"></p>
<p><strong>（3）函数参数的定义</strong><br>解构赋值可以方便地将一组参数与变量名对应起来。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数是一组有次序的值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">[x, y, z]</span>) </span>&#123; ... &#125;</span><br><span class="line">f([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数是一组无次序的值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">&#123;x, y, z&#125;</span>) </span>&#123; ... &#125;</span><br><span class="line">f(&#123;<span class="attr">z</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">x</span>: <span class="number">1</span>&#125;);<span class="number">1234567</span></span><br></pre></td></tr></table></figure>

<p><strong>（4）提取JSON数据</strong></p>
<p><strong>解构赋值对提取JSON对象中的数据，尤其有用。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> jsonData = &#123;</span><br><span class="line">  id: <span class="number">42</span>,</span><br><span class="line">  status: <span class="string">&quot;OK&quot;</span>,</span><br><span class="line">  data: [<span class="number">867</span>, <span class="number">5309</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; id, status, <span class="attr">data</span>: number &#125; = jsonData;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(id, status, number);</span><br><span class="line"><span class="comment">// 42, &quot;OK&quot;, [867, 5309]12345678910</span></span><br></pre></td></tr></table></figure>

<p>上面代码可以快速提取 JSON 数据的值。</p>
<p><strong>（5）函数参数的默认值</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">jQuery.ajax = <span class="function"><span class="keyword">function</span> (<span class="params">url, &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">async</span> = <span class="literal">true</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  beforeSend = <span class="keyword">function</span> () &#123;&#125;,</span></span></span><br><span class="line"><span class="function"><span class="params">  cache = <span class="literal">true</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  complete = <span class="keyword">function</span> () &#123;&#125;,</span></span></span><br><span class="line"><span class="function"><span class="params">  crossDomain = <span class="literal">false</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="built_in">global</span> = <span class="literal">true</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="regexp">//</span> ... more config</span></span></span><br><span class="line"><span class="function"><span class="params">&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ... do stuff</span></span><br><span class="line">&#125;;<span class="number">1234567891011</span></span><br></pre></td></tr></table></figure>

<p>指定参数的默认值，就避免了在函数体内部再写var foo = config.foo || ‘default foo’;这样的语句。</p>
<p><strong>（6）遍历Map结构</strong><br>任何部署了Iterator接口的对象，都可以用<strong>for…of</strong>循环遍历。Map结构原生支持Iterator接口，配合变量的解构赋值，获取键名和键值就非常方便。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">map.set(<span class="string">&#x27;first&#x27;</span>, <span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">map.set(<span class="string">&#x27;second&#x27;</span>, <span class="string">&#x27;world&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key + <span class="string">&quot; is &quot;</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// first is hello</span></span><br><span class="line"><span class="comment">// second is world123456789</span></span><br></pre></td></tr></table></figure>

<p><strong>如果只想获取键名，或者只想获取键值，可以写成下面这样。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取键名</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取键值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [,value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;<span class="number">123456789</span></span><br></pre></td></tr></table></figure>

<p><strong>Set 本身是一个构造函数，用来生成 Set 数据结构。它类似于数组，但是成员的值都是唯一的，没有重复的值。</strong></p>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">[<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">2</span>].map(<span class="function"><span class="params">x</span> =&gt;</span> s.add(x))</span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">of</span> s) &#123;<span class="built_in">console</span>.log(i)&#125;</span><br><span class="line"><span class="comment">// 2 3 5 41234</span></span><br></pre></td></tr></table></figure>

<p>注：add()方法，向Set 数据结构数据结构添加元素。</p>
<p><strong>（7）输入模块的指定方法</strong><br>加载模块时，需要指定输入哪些方法。解构赋值使输入语句清晰。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; SourceMapConsumer, SourceNode &#125; = <span class="built_in">require</span>(<span class="string">&quot;source-map&quot;</span>);<span class="number">1</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="字符串的扩展"><a href="#字符串的扩展" class="headerlink" title="字符串的扩展"></a>字符串的扩展</h1><h2 id="codePointAt"><a href="#codePointAt" class="headerlink" title="codePointAt()"></a>codePointAt()</h2><p>codePointAt方法是测试一个字符由两个字节还是由四个字节组成的最简单方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">is32Bit</span>(<span class="params">c</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> c.codePointAt(<span class="number">0</span>) &gt; <span class="number">0xFFFF</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">is32Bit(<span class="string">&quot;&quot;</span>) <span class="comment">// true</span></span><br><span class="line">is32Bit(<span class="string">&quot;a&quot;</span>) <span class="comment">// false123456</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="String-fromCodePoint"><a href="#String-fromCodePoint" class="headerlink" title="String.fromCodePoint()"></a>String.fromCodePoint()</h2><p><strong>ES5提供*String.fromCharCode*方法，用于从码点返回对应字符，但是这个方法不能识别32位的UTF-16字符（Unicode编号大于0xFFFF）。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>.fromCharCode(<span class="number">0x20BB7</span>)</span><br><span class="line"><span class="comment">// &quot;ஷ&quot;12</span></span><br></pre></td></tr></table></figure>

<p><strong>ES6提供了*String.fromCodePoint*方法，可以识别0xFFFF的字符，弥补了String.fromCharCode方法的不足。在作用上，正好与codePointAt方法相反。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>.fromCodePoint(<span class="number">0x20BB7</span>)</span><br><span class="line"><span class="comment">// &quot;&quot;</span></span><br><span class="line"><span class="built_in">String</span>.fromCodePoint(<span class="number">0x78</span>, <span class="number">0x1f680</span>, <span class="number">0x79</span>) === <span class="string">&#x27;x\uD83D\uDE80y&#x27;</span></span><br><span class="line"><span class="comment">// true1234</span></span><br></pre></td></tr></table></figure>

<p>*<strong>注意，fromCodePoint方法定义在String对象上，而codePointAt方法定义在字符串的实例对象上。*</strong></p>
<hr>
<h2 id="字符串的遍历器接口"><a href="#字符串的遍历器接口" class="headerlink" title="字符串的遍历器接口"></a>字符串的遍历器接口</h2><p><strong>用for…of循环遍历</strong></p>
<p>代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">for</span>(<span class="keyword">let</span> codePointAt <span class="keyword">of</span> <span class="string">&#x27;hicai&#x27;</span>)&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(codePointAt);</span><br><span class="line">  &#125;  </span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>

<p>结果：<br><img src="/2021/05/06/ES6/20180521141626752" alt="这里写图片描述"></p>
<p><strong>除了遍历字符串，这个遍历器最大的优点是可以识别大于0xFFFF的码点</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="built_in">String</span>.fromCodePoint(<span class="number">0x20BB7</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; text.length; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(text[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &quot; &quot;</span></span><br><span class="line"><span class="comment">// &quot; &quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> text) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &quot;&quot;123456789101112</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，字符串text只有一个字符，但是for循环会认为它包含两个字符（都不可打印），而<br>for…of循环会正确识别出这一个字符。</p>
<hr>
<h2 id="at"><a href="#at" class="headerlink" title="at()"></a>at()</h2><p><strong>ES5对字符串提供charAt方法，但不能识别码点大于0xFFFF的字符。</strong><br><strong>ES6的at方法，可以识别Unicode编号大于0xFFFF的字符，返回正确的字符。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;abc&#x27;</span>.at(<span class="number">0</span>) <span class="comment">// &quot;a&quot;</span></span><br><span class="line"><span class="string">&#x27;&#x27;</span>.at(<span class="number">0</span>) <span class="comment">// &quot;&quot;12</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="normalize"><a href="#normalize" class="headerlink" title="normalize()"></a>normalize()</h2><p>比如Ǒ（\u01D1）。另一种是提供合成符号（combining character），即原字符与重音符号的合成，两个字符合成一个字符，比如O（\u004F）和ˇ（\u030C）合成Ǒ（\u004F\u030C）。</p>
<p>这两种表示方法，在视觉和语义上都等价，但是JavaScript不能识别。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;\u01D1&#x27;</span>===<span class="string">&#x27;\u004F\u030C&#x27;</span> <span class="comment">//false</span></span><br><span class="line"><span class="string">&#x27;\u01D1&#x27;</span>.length <span class="comment">// 1</span></span><br><span class="line"><span class="string">&#x27;\u004F\u030C&#x27;</span>.length <span class="comment">// 2123</span></span><br></pre></td></tr></table></figure>

<p><strong>ES6提供字符串实例的normalize()方法，用来将字符的不同表示方法统一为同样的形式，这称为Unicode正规化。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;\u01D1&#x27;</span>.normalize() === <span class="string">&#x27;\u004F\u030C&#x27;</span>.normalize()</span><br><span class="line"><span class="comment">// true12</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="includes-startsWith-endsWith"><a href="#includes-startsWith-endsWith" class="headerlink" title="includes(), startsWith(), endsWith()"></a>includes(), startsWith(), endsWith()</h2><p><strong>ES5中的indexOf方法，用来检索字符串中指定字符串出现的位置</strong> 而ES6又提供了三种新方法。</p>
<p>**includes()**：返回布尔值，表示是否找到了参数字符串。<br>**startsWith()**：返回布尔值，表示参数字符串是否在源字符串的头部。<br>**endsWith()**：返回布尔值，表示参数字符串是否在源字符串的尾部。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;Hello world!&#x27;</span>;</span><br><span class="line">s.startsWith(<span class="string">&#x27;Hello&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">s.endsWith(<span class="string">&#x27;!&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">s.includes(<span class="string">&#x27;o&#x27;</span>) <span class="comment">// true</span></span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure>

<p><strong>这三个方法都支持第二个参数，表示开始搜索的位置。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;Hello world!&#x27;</span>;</span><br><span class="line">s.startsWith(<span class="string">&#x27;world&#x27;</span>, <span class="number">6</span>) <span class="comment">// true</span></span><br><span class="line">s.endsWith(<span class="string">&#x27;Hello&#x27;</span>, <span class="number">5</span>) <span class="comment">// true</span></span><br><span class="line">s.includes(<span class="string">&#x27;Hello&#x27;</span>, <span class="number">0</span>) <span class="comment">// true</span></span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure>

<p>*<strong>注意：endsWith的行为与其他两个方法有所不同。它针对前n个字符，而其他两个方法针对从第n个位置直到字符串结束。*</strong></p>
<hr>
<h2 id="repeat"><a href="#repeat" class="headerlink" title="repeat()"></a>repeat()</h2><p>repeat方法返回一个新字符串，表示将原字符串重复n次。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;x&#x27;</span>.repeat(<span class="number">3</span>) <span class="comment">// &quot;xxx&quot;</span></span><br><span class="line"><span class="string">&#x27;hello&#x27;</span>.repeat(<span class="number">2</span>) <span class="comment">// &quot;hellohello&quot;</span></span><br><span class="line"><span class="string">&#x27;na&#x27;</span>.repeat(<span class="number">0</span>) <span class="comment">// &quot;&quot;123</span></span><br></pre></td></tr></table></figure>

<p><strong>参数如果是小数，会被取整。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;na&#x27;</span>.repeat(<span class="number">2.9</span>) <span class="comment">// &quot;nana&quot;1</span></span><br></pre></td></tr></table></figure>

<p><strong>如果repeat的参数是负数或者Infinity，会报错。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;na&#x27;</span>.repeat(<span class="literal">Infinity</span>)</span><br><span class="line"><span class="comment">// RangeError</span></span><br><span class="line"><span class="string">&#x27;na&#x27;</span>.repeat(-<span class="number">1</span>)</span><br><span class="line"><span class="comment">// RangeError</span></span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure>

<p>但是，如果参数是0到-1之间的小数，则等同于0，这是因为会先进行取整运算。0到-1之间的小数，取整以后等于-0，repeat视同为0。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;na&#x27;</span>.repeat(-<span class="number">0.9</span>) <span class="comment">// &quot; &quot;1</span></span><br></pre></td></tr></table></figure>

<p>参数NaN等同于0。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;na&#x27;</span>.repeat(<span class="literal">NaN</span>) <span class="comment">// &quot;&quot;</span></span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>

<p>如果repeat的参数是字符串，则会先转换成数字。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;na&#x27;</span>.repeat(<span class="string">&#x27;na&#x27;</span>) <span class="comment">// &quot;&quot;</span></span><br><span class="line"><span class="string">&#x27;na&#x27;</span>.repeat(<span class="string">&#x27;3&#x27;</span>) <span class="comment">// &quot;nanana&quot;</span></span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="padStart-，padEnd"><a href="#padStart-，padEnd" class="headerlink" title="padStart()，padEnd()"></a>padStart()，padEnd()</h2><p><strong>字符串补全长度功能，padStart()用于头部补全，padEnd()用于尾部补全。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//padStart()</span></span><br><span class="line"><span class="string">&#x27;x&#x27;</span>.padStart(<span class="number">5</span>, <span class="string">&#x27;ab&#x27;</span>) <span class="comment">// &#x27;ababx&#x27;</span></span><br><span class="line"><span class="string">&#x27;x&#x27;</span>.padStart(<span class="number">4</span>, <span class="string">&#x27;ab&#x27;</span>) <span class="comment">// &#x27;abax&#x27;</span></span><br><span class="line"><span class="comment">//padEnd()</span></span><br><span class="line"><span class="string">&#x27;x&#x27;</span>.padEnd(<span class="number">5</span>, <span class="string">&#x27;ab&#x27;</span>) <span class="comment">// &#x27;xabab&#x27;</span></span><br><span class="line"><span class="string">&#x27;x&#x27;</span>.padEnd(<span class="number">4</span>, <span class="string">&#x27;ab&#x27;</span>) <span class="comment">// &#x27;xaba&#x27;123456</span></span><br></pre></td></tr></table></figure>

<p>*<strong>参数：第一个参数用来指定字符串的最小长度，第二个参数是用来补全的字符串。*</strong></p>
<p><strong>如果原字符串的长度，等于或大于指定的最小长度，则返回原字符串。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;xxx&#x27;</span>.padStart(<span class="number">2</span>, <span class="string">&#x27;ab&#x27;</span>) <span class="comment">// &#x27;xxx&#x27;</span></span><br><span class="line"><span class="string">&#x27;xxx&#x27;</span>.padEnd(<span class="number">2</span>, <span class="string">&#x27;ab&#x27;</span>) <span class="comment">// &#x27;xxx&#x27;12</span></span><br></pre></td></tr></table></figure>

<p><strong>如果用来补全的字符串与原字符串，两者的长度之和超过了指定的最小长度，则会截去超出位数的补全字符串。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;abc&#x27;</span>.padStart(<span class="number">10</span>, <span class="string">&#x27;0123456789&#x27;</span>)</span><br><span class="line"><span class="comment">// &#x27;0123456abc&#x27;</span></span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>

<p><strong>如果省略第二个参数，默认使用空格补全长度。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;x&#x27;</span>.padStart(<span class="number">4</span>) <span class="comment">// &#x27;   x&#x27;</span></span><br><span class="line"><span class="string">&#x27;x&#x27;</span>.padEnd(<span class="number">4</span>) <span class="comment">// &#x27;x   &#x27;12</span></span><br></pre></td></tr></table></figure>

<p><strong>padStart的常见用途是为数值补全指定位数。下面代码生成10位的数值字符串。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;1&#x27;</span>.padStart(<span class="number">10</span>, <span class="string">&#x27;0&#x27;</span>) <span class="comment">// &quot;0000000001&quot;</span></span><br><span class="line"><span class="string">&#x27;12&#x27;</span>.padStart(<span class="number">10</span>, <span class="string">&#x27;0&#x27;</span>) <span class="comment">// &quot;0000000012&quot;</span></span><br><span class="line"><span class="string">&#x27;123456&#x27;</span>.padStart(<span class="number">10</span>, <span class="string">&#x27;0&#x27;</span>) <span class="comment">// &quot;0000123456&quot;123</span></span><br></pre></td></tr></table></figure>

<p><strong>另一个用途是提示字符串格式。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;12&#x27;</span>.padStart(<span class="number">10</span>, <span class="string">&#x27;YYYY-MM-DD&#x27;</span>) <span class="comment">// &quot;YYYY-MM-12&quot;</span></span><br><span class="line"><span class="string">&#x27;09-12&#x27;</span>.padStart(<span class="number">10</span>, <span class="string">&#x27;YYYY-MM-DD&#x27;</span>) <span class="comment">// &quot;YYYY-09-12&quot;12</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="数值的扩展"><a href="#数值的扩展" class="headerlink" title="数值的扩展"></a>数值的扩展</h1><h2 id="Number-isFinite-Number-isNaN"><a href="#Number-isFinite-Number-isNaN" class="headerlink" title="Number.isFinite(), Number.isNaN()"></a>Number.isFinite(), Number.isNaN()</h2><p><strong>Number.isFinite()用来检查一个数值是否为有限的（finite）。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isFinite(<span class="number">15</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="number">0.8</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="literal">NaN</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="literal">Infinity</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(-<span class="literal">Infinity</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="string">&#x27;foo&#x27;</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="string">&#x27;15&#x27;</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="literal">true</span>); <span class="comment">// false12345678</span></span><br></pre></td></tr></table></figure>

<p><strong>Number.isNaN()用来检查一个值是否为NaN。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isNaN(<span class="literal">NaN</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="number">15</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="string">&#x27;15&#x27;</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="literal">true</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="number">9</span>/<span class="literal">NaN</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="string">&#x27;true&#x27;</span>/<span class="number">0</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="string">&#x27;true&#x27;</span>/<span class="string">&#x27;true&#x27;</span>) <span class="comment">// true1234567</span></span><br></pre></td></tr></table></figure>

<p>*<strong>注意：它们与传统的全局方法isFinite()和isNaN()的区别在于，传统方法先调用Number()将非数值的值转为数值，再进行判断，而这两个新方法只对数值有效，Number.isFinite()对于非数值一律返回false, Number.isNaN()只有对于NaN才返回true，非NaN一律返回false。*</strong></p>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">isFinite</span>(<span class="number">25</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">isFinite</span>(<span class="string">&quot;25&quot;</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="number">25</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="string">&quot;25&quot;</span>) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="literal">NaN</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="string">&quot;NaN&quot;</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="literal">NaN</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="string">&quot;NaN&quot;</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="number">1</span>) <span class="comment">// false12345678910</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Number-parseInt-Number-parseFloat"><a href="#Number-parseInt-Number-parseFloat" class="headerlink" title="Number.parseInt(), Number.parseFloat()"></a>Number.parseInt(), Number.parseFloat()</h2><p><strong>ES6将全局方法parseInt()和parseFloat()，移植到Number对象上面，行为完全保持不变。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5的写法</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;12.34&#x27;</span>) <span class="comment">// 12</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">&#x27;123.45#&#x27;</span>) <span class="comment">// 123.45</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6的写法</span></span><br><span class="line"><span class="built_in">Number</span>.parseInt(<span class="string">&#x27;12.34&#x27;</span>) <span class="comment">// 12</span></span><br><span class="line"><span class="built_in">Number</span>.parseFloat(<span class="string">&#x27;123.45#&#x27;</span>) <span class="comment">// 123.45</span></span><br><span class="line"><span class="number">123456789</span></span><br></pre></td></tr></table></figure>

<p><strong>这样做的目的，是逐步减少全局性方法，使得语言逐步模块化。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.parseInt === <span class="built_in">parseInt</span> <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.parseFloat === <span class="built_in">parseFloat</span> <span class="comment">// true</span></span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Number-isInteger"><a href="#Number-isInteger" class="headerlink" title="Number.isInteger()"></a>Number.isInteger()</h2><p><strong>Number.isInteger()用来判断一个值是否为整数。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isInteger(<span class="number">25</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isInteger(<span class="number">25.0</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isInteger(<span class="number">25.1</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isInteger(<span class="string">&quot;15&quot;</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isInteger(<span class="literal">true</span>) <span class="comment">// false</span></span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Number-EPSILON"><a href="#Number-EPSILON" class="headerlink" title="Number.EPSILON"></a>Number.EPSILON</h2><p><strong>ES6在Number对象上面，新增一个极小的常量Number.EPSILON。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.EPSILON</span><br><span class="line"><span class="comment">// 2.220446049250313e-16</span></span><br><span class="line"><span class="built_in">Number</span>.EPSILON.toFixed(<span class="number">20</span>)</span><br><span class="line"><span class="comment">// &#x27;0.00000000000000022204&#x27;1234</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="安全整数和Number-isSafeInteger"><a href="#安全整数和Number-isSafeInteger" class="headerlink" title="安全整数和Number.isSafeInteger()"></a>安全整数和Number.isSafeInteger()</h2><p><strong>JavaScript能够准确表示的整数范围在-2^53到2^53之间（不含两个端点），超过这个范围，无法精确表示这个值。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) <span class="comment">// 9007199254740992</span></span><br><span class="line"></span><br><span class="line"><span class="number">9007199254740992</span>  <span class="comment">// 9007199254740992</span></span><br><span class="line"><span class="number">9007199254740993</span>  <span class="comment">// 9007199254740992</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) === <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) + <span class="number">1</span></span><br><span class="line"><span class="comment">// true1234567</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，超出2的53次方之后，一个数就不精确了。</p>
<p><strong>ES6引入了Number.MAX_SAFE_INTEGER和Number.MIN_SAFE_INTEGER这两个常量，用来表示这个范围的上下限。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.MAX_SAFE_INTEGER === <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) - <span class="number">1</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.MAX_SAFE_INTEGER === <span class="number">9007199254740991</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>.MIN_SAFE_INTEGER === -<span class="built_in">Number</span>.MAX_SAFE_INTEGER</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.MIN_SAFE_INTEGER === -<span class="number">9007199254740991</span></span><br><span class="line"><span class="comment">// true123456789</span></span><br></pre></td></tr></table></figure>

<p><strong>Number.isSafeInteger()则是用来判断一个整数是否落在这个范围之内。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="string">&#x27;a&#x27;</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="literal">null</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="literal">NaN</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="literal">Infinity</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(-<span class="literal">Infinity</span>) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="number">3</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="number">1.2</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="number">9007199254740990</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="number">9007199254740992</span>) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="built_in">Number</span>.MIN_SAFE_INTEGER - <span class="number">1</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="built_in">Number</span>.MIN_SAFE_INTEGER) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="built_in">Number</span>.MAX_SAFE_INTEGER) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="built_in">Number</span>.MAX_SAFE_INTEGER + <span class="number">1</span>) <span class="comment">// false123456789101112131415</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Math对象的扩展"><a href="#Math对象的扩展" class="headerlink" title="Math对象的扩展"></a>Math对象的扩展</h2><h3 id="Math-trunc"><a href="#Math-trunc" class="headerlink" title="Math.trunc()"></a>Math.trunc()</h3><p><strong>Math.trunc方法用于去除一个数的小数部分，返回整数部分。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.trunc(<span class="number">4.1</span>) <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">Math</span>.trunc(<span class="number">4.9</span>) <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">Math</span>.trunc(-<span class="number">4.1</span>) <span class="comment">// -4</span></span><br><span class="line"><span class="built_in">Math</span>.trunc(-<span class="number">4.9</span>) <span class="comment">// -4</span></span><br><span class="line"><span class="built_in">Math</span>.trunc(-<span class="number">0.1234</span>) <span class="comment">// -012345</span></span><br></pre></td></tr></table></figure>

<p><strong>对于非数值，Math.trunc内部使用Number方法将其先转为数值。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.trunc(<span class="string">&#x27;123.456&#x27;</span>)</span><br><span class="line"><span class="comment">// 12312</span></span><br></pre></td></tr></table></figure>

<p><strong>对于空值和无法截取整数的值，返回NaN。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.trunc(<span class="literal">NaN</span>);      <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Math</span>.trunc(<span class="string">&#x27;foo&#x27;</span>);    <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Math</span>.trunc();         <span class="comment">// NaN123</span></span><br></pre></td></tr></table></figure>

<h3 id="Math-sign"><a href="#Math-sign" class="headerlink" title="Math.sign()"></a>Math.sign()</h3><p><strong>Math.sign方法用来判断一个数到底是正数、负数、还是零。</strong></p>
<p>它会返回五种值。<br>参数为正数，返回+1；<br>参数为负数，返回-1；<br>参数为0，返回0；<br>参数为-0，返回-0;<br>其他值，返回NaN。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.sign(-<span class="number">5</span>) <span class="comment">// -1</span></span><br><span class="line"><span class="built_in">Math</span>.sign(<span class="number">5</span>) <span class="comment">// +1</span></span><br><span class="line"><span class="built_in">Math</span>.sign(<span class="number">0</span>) <span class="comment">// +0</span></span><br><span class="line"><span class="built_in">Math</span>.sign(-<span class="number">0</span>) <span class="comment">// -0</span></span><br><span class="line"><span class="built_in">Math</span>.sign(<span class="literal">NaN</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Math</span>.sign(<span class="string">&#x27;foo&#x27;</span>); <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Math</span>.sign(); <span class="comment">// NaN1234567</span></span><br></pre></td></tr></table></figure>

<h3 id="Math-cbrt"><a href="#Math-cbrt" class="headerlink" title="Math.cbrt()"></a>Math.cbrt()</h3><p><strong>Math.cbrt方法用于计算一个数的立方根。（ 3的立方）</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.cbrt(-<span class="number">1</span>) <span class="comment">// -1</span></span><br><span class="line"><span class="built_in">Math</span>.cbrt(<span class="number">0</span>)  <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">Math</span>.cbrt(<span class="number">1</span>)  <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">Math</span>.cbrt(<span class="number">2</span>)  <span class="comment">// 1.2599210498948734</span></span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure>

<p><strong>对于非数值，Math.cbrt方法内部也是先使用Number方法将其转为数值。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.cbrt(<span class="string">&#x27;8&#x27;</span>) <span class="comment">// 2 </span></span><br><span class="line"><span class="built_in">Math</span>.cbrt(<span class="string">&#x27;hello&#x27;</span>) <span class="comment">// NaN12</span></span><br></pre></td></tr></table></figure>

<h3 id="Math-clz32"><a href="#Math-clz32" class="headerlink" title="Math.clz32()"></a>Math.clz32()</h3><p><strong>Math.clz32方法返回一个数的32位无符号整数形式有多少个前导0。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.clz32(<span class="number">0</span>) <span class="comment">// 32</span></span><br><span class="line"><span class="built_in">Math</span>.clz32(<span class="number">1</span>) <span class="comment">// 31</span></span><br><span class="line"><span class="built_in">Math</span>.clz32(<span class="number">1000</span>) <span class="comment">// 22</span></span><br><span class="line"><span class="built_in">Math</span>.clz32(<span class="number">0b01000000000000000000000000000000</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">Math</span>.clz32(<span class="number">0b00100000000000000000000000000000</span>) <span class="comment">// 212345</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，0的二进制形式全为0，所以有32个前导0；1的二进制形式是0b1，只占1位，所以32位之中有31个前导0；1000的二进制形式是0b1111101000，一共有10位，所以32位之中有22个前导0。</p>
<h3 id="Math-imul"><a href="#Math-imul" class="headerlink" title="Math.imul()"></a>Math.imul()</h3><p><strong>Math.imul方法返回两个数以32位带符号整数形式相乘的结果，返回的也是一个32位的带符号整数。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.imul(<span class="number">2</span>, <span class="number">4</span>)   <span class="comment">// 8</span></span><br><span class="line"><span class="built_in">Math</span>.imul(-<span class="number">1</span>, <span class="number">8</span>)  <span class="comment">// -8</span></span><br><span class="line"><span class="built_in">Math</span>.imul(-<span class="number">2</span>, -<span class="number">2</span>) <span class="comment">// 4123</span></span><br></pre></td></tr></table></figure>

<h3 id="Math-fround"><a href="#Math-fround" class="headerlink" title="Math.fround()"></a>Math.fround()</h3><p><strong>Math.fround方法返回一个数的单精度浮点数形式。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.fround(<span class="number">0</span>)     <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">Math</span>.fround(<span class="number">1</span>)     <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">Math</span>.fround(<span class="number">1.337</span>) <span class="comment">// 1.3370000123977661</span></span><br><span class="line"><span class="built_in">Math</span>.fround(<span class="number">1.5</span>)   <span class="comment">// 1.5</span></span><br><span class="line"><span class="built_in">Math</span>.fround(<span class="literal">NaN</span>)   <span class="comment">// NaN</span></span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure>

<h3 id="Math-hypot"><a href="#Math-hypot" class="headerlink" title="Math.hypot()"></a>Math.hypot()</h3><p><strong>Math.hypot方法返回所有参数的平方和的平方根。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.hypot(<span class="number">3</span>, <span class="number">4</span>);        <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">Math</span>.hypot(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);     <span class="comment">// 7.0710678118654755</span></span><br><span class="line"><span class="built_in">Math</span>.hypot();            <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">Math</span>.hypot(<span class="literal">NaN</span>);         <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Math</span>.hypot(<span class="number">3</span>, <span class="number">4</span>, <span class="string">&#x27;foo&#x27;</span>); <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Math</span>.hypot(<span class="number">3</span>, <span class="number">4</span>, <span class="string">&#x27;5&#x27;</span>);   <span class="comment">// 7.0710678118654755</span></span><br><span class="line"><span class="built_in">Math</span>.hypot(-<span class="number">3</span>);          <span class="comment">// 31234567</span></span><br></pre></td></tr></table></figure>

<p><strong>上面代码中，3的平方加上4的平方，等于5的平方。</strong></p>
<p><strong>如果参数不是数值，Math.hypot方法会将其转为数值。只要有一个参数无法转为数值，就会返回NaN。</strong></p>
<hr>
<h3 id="对数方法"><a href="#对数方法" class="headerlink" title="对数方法"></a>对数方法</h3><p><strong>（1） Math.expm1()</strong></p>
<p><strong>Math.expm1(x)返回ex - 1，即Math.exp(x) - 1。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.expm1(-<span class="number">1</span>) <span class="comment">// -0.6321205588285577</span></span><br><span class="line"><span class="built_in">Math</span>.expm1(<span class="number">0</span>)  <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">Math</span>.expm1(<span class="number">1</span>)  <span class="comment">// 1.718281828459045</span></span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>

<p><strong>（2）Math.log1p()</strong><br><strong>Math.log1p(x)方法返回1 + x的自然对数，即Math.log(1 + x)。如果x小于-1，返回NaN。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.log1p(<span class="number">1</span>)  <span class="comment">// 0.6931471805599453</span></span><br><span class="line"><span class="built_in">Math</span>.log1p(<span class="number">0</span>)  <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">Math</span>.log1p(-<span class="number">1</span>) <span class="comment">// -Infinity</span></span><br><span class="line"><span class="built_in">Math</span>.log1p(-<span class="number">2</span>) <span class="comment">// NaN1234</span></span><br></pre></td></tr></table></figure>

<p><strong>（3）Math.log10()</strong><br><strong>Math.log10(x)返回以10为底的x的对数。如果x小于0，则返回NaN。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.log10(<span class="number">2</span>)      <span class="comment">// 0.3010299956639812</span></span><br><span class="line"><span class="built_in">Math</span>.log10(<span class="number">1</span>)      <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">Math</span>.log10(<span class="number">0</span>)      <span class="comment">// -Infinity</span></span><br><span class="line"><span class="built_in">Math</span>.log10(-<span class="number">2</span>)     <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Math</span>.log10(<span class="number">100000</span>) <span class="comment">// 512345</span></span><br></pre></td></tr></table></figure>

<p><strong>( 4 ) Math.log2()</strong><br><strong>Math.log2(x)返回以2为底的x的对数。如果x小于0，则返回NaN。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.log2(<span class="number">3</span>)       <span class="comment">// 1.584962500721156</span></span><br><span class="line"><span class="built_in">Math</span>.log2(<span class="number">2</span>)       <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">Math</span>.log2(<span class="number">1</span>)       <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">Math</span>.log2(<span class="number">0</span>)       <span class="comment">// -Infinity</span></span><br><span class="line"><span class="built_in">Math</span>.log2(-<span class="number">2</span>)      <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Math</span>.log2(<span class="number">1024</span>)    <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">Math</span>.log2(<span class="number">1</span> &lt;&lt; <span class="number">29</span>) <span class="comment">// 291234567</span></span><br></pre></td></tr></table></figure>

<h3 id="三角函数方法"><a href="#三角函数方法" class="headerlink" title="三角函数方法"></a>三角函数方法</h3><p><strong>ES6新增了6个三角函数方法。</strong><br>Math.sinh(x) 返回x的双曲正弦（hyperbolic sine）<br>Math.cosh(x) 返回x的双曲余弦（hyperbolic cosine）<br>Math.tanh(x) 返回x的双曲正切（hyperbolic tangent）<br>Math.asinh(x) 返回x的反双曲正弦（inverse hyperbolic sine）<br>Math.acosh(x) 返回x的反双曲余弦（inverse hyperbolic cosine）<br>Math.atanh(x) 返回x的反双曲正切（inverse hyperbolic tangent）</p>
<h3 id="Math-signbit"><a href="#Math-signbit" class="headerlink" title="Math.signbit()"></a>Math.signbit()</h3><p><strong>Math.sign()用来判断一个值的正负，但是如果参数是-0，它会返回-0。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.signbit(<span class="number">2</span>) <span class="comment">//false</span></span><br><span class="line"><span class="built_in">Math</span>.signbit(-<span class="number">2</span>) <span class="comment">//true</span></span><br><span class="line"><span class="built_in">Math</span>.signbit(<span class="number">0</span>) <span class="comment">//false</span></span><br><span class="line"><span class="built_in">Math</span>.signbit(-<span class="number">0</span>) <span class="comment">//true1234</span></span><br></pre></td></tr></table></figure>

<p><strong>该方法的算法如下。</strong></p>
<p>如果参数是NaN，返回false<br>如果参数是-0，返回true<br>如果参数是负值，返回true<br>其他情况返回false</p>
<h3 id="指数运算符"><a href="#指数运算符" class="headerlink" title="指数运算符"></a>指数运算符</h3><p>ES2016 新增了一个<strong>指数运算符（</strong>）**。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> ** <span class="number">2</span> <span class="comment">// 4</span></span><br><span class="line"><span class="number">2</span> ** <span class="number">3</span> <span class="comment">// 812</span></span><br></pre></td></tr></table></figure>

<p>指数运算符可以与等号结合，形成一个新的<strong>赋值运算符（</strong>=）**。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">let</span> b = <span class="number">4</span>;</span><br><span class="line"> b **= <span class="number">3</span>;  <span class="comment">// 等同于 b = b * b * b;</span></span><br><span class="line"> <span class="built_in">console</span>.log(b)  <span class="comment">//64</span></span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="数组的扩展"><a href="#数组的扩展" class="headerlink" title="数组的扩展"></a>数组的扩展</h1><h2 id="Array-from"><a href="#Array-from" class="headerlink" title="Array.from()"></a>Array.from()</h2><p><strong>Array.from方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括ES6新增的数据结构Set和Map）。</strong><br>下面是一个类似数组的对象，Array.from将它转为真正的数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">let</span> arrayLike = &#123;</span><br><span class="line">    <span class="string">&#x27;0&#x27;</span>:<span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;1&#x27;</span>:<span class="string">&#x27;b&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;2&#x27;</span>:<span class="string">&#x27;c&#x27;</span>,</span><br><span class="line">    length:<span class="number">3</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">//ES5写法</span></span><br><span class="line">  <span class="keyword">var</span> arr1 = [].slice.call(arrayLike);</span><br><span class="line">  <span class="comment">//ES6写法</span></span><br><span class="line">  <span class="keyword">let</span> arr2 = <span class="built_in">Array</span>.from(arrayLike);</span><br><span class="line">  <span class="built_in">console</span>.log(arr1);</span><br><span class="line">  <span class="built_in">console</span>.log(arr2); </span><br><span class="line"><span class="number">12345678910111213</span></span><br></pre></td></tr></table></figure>

<p>控制台结果：<br><img src="/2021/05/06/ES6/20180525112916412" alt="这里写图片描述"></p>
<p>实际应用中，<strong>常见的类似数组的对象是DOM操作返回的NodeList集合，以及函数内部的arguments对象。Array.from都可以将它们转为真正的数组。</strong></p>
<p>例：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>3<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>4<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>5<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">let</span> ps = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;p&#x27;</span>);</span></span><br><span class="line"><span class="javascript">  <span class="built_in">Array</span>.from(ps).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(item)</span></span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span>1234567891011</span><br></pre></td></tr></table></figure>

<p><strong>控制台结果：</strong><br><img src="/2021/05/06/ES6/20180525141824944" alt="这里写图片描述"></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arguments对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> args = <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure>

<p><strong>只要是部署了Iterator接口的数据结构，Array.from都能将其转为数组。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.from(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line"><span class="comment">// [&#x27;h&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> namesSet = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>])</span><br><span class="line"><span class="built_in">Array</span>.from(namesSet) <span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;]12345</span></span><br></pre></td></tr></table></figure>

<p><strong>如果参数是一个真正的数组，Array.from会返回一个一模一样的新数组。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = <span class="built_in">Array</span>.from([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">//[1, 2, 3]</span></span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>

<p><strong>扩展运算符（…）也可以将某些数据结构转为数组。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arguments对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> args = [...arguments];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NodeList对象</span></span><br><span class="line">[...document.querySelectorAll(<span class="string">&#x27;div&#x27;</span>)]<span class="number">1234567</span></span><br></pre></td></tr></table></figure>

<p><strong>Array.from还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.from(arrayLike, <span class="function"><span class="params">x</span> =&gt;</span> x * x);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">Array</span>.from(arrayLike).map(<span class="function"><span class="params">x</span> =&gt;</span> x * x);</span><br><span class="line"><span class="built_in">Array</span>.from([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="function">(<span class="params">x</span>) =&gt;</span> x * x)</span><br><span class="line"><span class="comment">// [1, 4, 9]12345</span></span><br></pre></td></tr></table></figure>

<p><strong>利用Array.from获取一组DOM节点的文本内容</strong><br>例：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>苹果<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>香蕉<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>梨<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>西瓜<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>桃子<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> spans = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;span&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    <span class="comment">//ES5写法</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> names1 = <span class="built_in">Array</span>.prototype.map.call(spans,<span class="function"><span class="keyword">function</span>(<span class="params">i</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> i.textContent;</span></span><br><span class="line">    &#125;)</span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(names1);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">   <span class="comment">//ES6写法</span></span></span><br><span class="line"><span class="javascript">   <span class="keyword">let</span> spans2 = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;span&#x27;</span>);</span></span><br><span class="line"><span class="javascript">   <span class="keyword">let</span> names2 = <span class="built_in">Array</span>.from(spans2,<span class="function"><span class="params">i</span> =&gt;</span> i.textContent);</span></span><br><span class="line"><span class="javascript">   <span class="built_in">console</span>.log(names2);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span>123456789101112131415161718</span><br></pre></td></tr></table></figure>

<p>控制台结果都相同：<br><img src="/2021/05/06/ES6/20180525234731512" alt="这里写图片描述"></p>
<p><strong>Array.from可以将数组中布尔值为false的成员转为0。</strong><br>例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.from([<span class="number">1</span>, , <span class="number">2</span>, , <span class="number">3</span>], <span class="function">(<span class="params">n</span>) =&gt;</span> n || <span class="number">0</span>)</span><br><span class="line"><span class="comment">// [1, 0, 2, 0, 3]12</span></span><br></pre></td></tr></table></figure>

<p>经过测试：NaN、undefined转化也为0</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = <span class="built_in">Array</span>.from([<span class="number">1</span>,<span class="literal">NaN</span>, <span class="number">2</span>,<span class="literal">undefined</span>, <span class="number">3</span>], <span class="function">(<span class="params">n</span>) =&gt;</span> n || <span class="number">0</span>)</span><br><span class="line"><span class="built_in">console</span>.log(arr);<span class="number">12</span></span><br></pre></td></tr></table></figure>

<p><strong>Array.from返回各种数据的类型</strong><br>例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">typesOf</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>, <span class="function"><span class="params">value</span> =&gt;</span> <span class="keyword">typeof</span> value)</span><br><span class="line">&#125;</span><br><span class="line">typesOf(<span class="literal">null</span>, [], <span class="literal">NaN</span>)</span><br><span class="line"><span class="comment">// [&#x27;object&#x27;, &#x27;object&#x27;, &#x27;number&#x27;]</span></span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure>

<h2 id="Array-of"><a href="#Array-of" class="headerlink" title="Array.of()"></a>Array.of()</h2><p><strong>Array.of方法用于将一组值，转换为数组。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.of(<span class="number">3</span>, <span class="number">11</span>, <span class="number">8</span>) <span class="comment">// [3,11,8]</span></span><br><span class="line"><span class="built_in">Array</span>.of(<span class="number">3</span>) <span class="comment">// [3]</span></span><br><span class="line"><span class="built_in">Array</span>.of(<span class="number">3</span>).length <span class="comment">// 1</span></span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>

<p><strong>Array方法没有参数、一个参数、三个参数时，返回结果都不一样。只有当参数个数不少于2个时，Array()才会返回由参数组成的新数组。参数个数只有一个时，实际上是指定数组的长度。</strong></p>
<p><strong>Array.of基本上可以用来替代Array()或new Array()，并且不存在由于参数不同而导致的重载。行为统一。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.of() <span class="comment">// []</span></span><br><span class="line"><span class="built_in">Array</span>.of(<span class="literal">undefined</span>) <span class="comment">// [undefined]</span></span><br><span class="line"><span class="built_in">Array</span>.of(<span class="number">1</span>) <span class="comment">// [1]</span></span><br><span class="line"><span class="built_in">Array</span>.of(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// [1, 2]</span></span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure>

<p><strong>Array.of总是返回参数值组成的数组。如果没有参数，就返回一个空数组。</strong></p>
<h2 id="数组实例的copyWithin"><a href="#数组实例的copyWithin" class="headerlink" title="数组实例的copyWithin()"></a>数组实例的copyWithin()</h2><p>数组实例的copyWithin方法，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组</p>
<blockquote>
<p>Array.prototype.copyWithin(target, start = 0, end = this.length)</p>
</blockquote>
<p><em>三个参数:</em><br><em>target（必需）：从该位置开始替换数据。</em><br><em>start（可选）：从该位置开始读取数据，默认为0。如果为负值，表示倒数。</em><br><em>end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数</em>。*</p>
<p>例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = <span class="built_in">Array</span>.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr.copyWithin(<span class="number">0</span>,<span class="number">3</span>)) <span class="comment">//[4, 5, 3, 4, 5]12</span></span><br></pre></td></tr></table></figure>

<p><strong>上面代码表示将从3号位直到数组结束的成员（4和5），复制到从0号位开始的位置，结果覆盖了原来的1和2。</strong></p>
<p><strong>注意：三个参数都应该是数值，如果不是，会自动转为数值。</strong></p>
<p>例如刚才的例子，输出结果相同：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(arr.copyWithin(<span class="number">0</span>,<span class="string">&#x27;3&#x27;</span>)) <span class="comment">//[4, 5, 3, 4, 5]1</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="数组实例的find-和findIndex"><a href="#数组实例的find-和findIndex" class="headerlink" title="数组实例的find()和findIndex()"></a>数组实例的find()和findIndex()</h2><p><strong>find方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">4</span>, -<span class="number">5</span>, <span class="number">10</span>].find(<span class="function">(<span class="params">n</span>) =&gt;</span> n &lt; <span class="number">0</span>)</span><br><span class="line"><span class="comment">// -5</span></span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>

<p><strong>find方法的回调函数可以接受三个参数，依次为当前的值、当前的位置和原数组。</strong><br>切记：是返回第一个符合条件的值，就不会找下一个了。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>].find(<span class="function"><span class="keyword">function</span>(<span class="params">value, index, arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value &gt; <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line">&#125;) </span><br><span class="line"> <span class="built_in">console</span>.log(arr)  <span class="comment">//1012345</span></span><br></pre></td></tr></table></figure>

<p><strong>findIndex方法的用法与find方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。</strong></p>
<p>切记：是返回第一个符合条件值的索引值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>].findIndex(<span class="function"><span class="keyword">function</span>(<span class="params">value, index, arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value &gt; <span class="number">9</span>;</span><br><span class="line">&#125;) <span class="comment">// 2</span></span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>

<p><strong>另外，这两个方法都可以发现NaN，弥补了数组的IndexOf方法的不足。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="literal">NaN</span>].indexOf(<span class="literal">NaN</span>)</span><br><span class="line"><span class="comment">// -1</span></span><br><span class="line">[<span class="literal">NaN</span>].findIndex(<span class="function"><span class="params">y</span> =&gt;</span> <span class="built_in">Object</span>.is(<span class="literal">NaN</span>, y))</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：Object.is()是ES6新增的用来比较两个值是否严格相等的方法，与===的行为基本一致。</strong></p>
<p>例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">3</span>; </span><br><span class="line"><span class="keyword">var</span> b = <span class="string">&quot;3&quot;</span>; </span><br><span class="line"></span><br><span class="line">a==b;    <span class="comment">// true</span></span><br><span class="line">a===b;   <span class="comment">// false，因为*a*，*b*的类型不一样 </span></span><br><span class="line"><span class="built_in">Object</span>.is( a, b );  <span class="comment">//false，因为*a*，*b*的类型不一样 123456</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="数组实例的fill"><a href="#数组实例的fill" class="headerlink" title="数组实例的fill()"></a>数组实例的fill()</h2><p><strong>fill方法使用给定值，填充一个数组。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(arr.fill(<span class="number">7</span>)) <span class="comment">//[7, 7, 7];</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//fill方法用于空数组的初始化非常方便。数组中已有的元素，会被全部抹去。</span></span><br><span class="line">  <span class="keyword">let</span> arr2 = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>).fill(<span class="number">6</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(arr2)<span class="comment">// [6, 6, 6]</span></span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure>

<p><strong>fill方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置</strong><br>例如：fill方法从1号位开始，向原数组填充7，到2号位之前结束。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>].fill(<span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>)<span class="comment">// [&#x27;a&#x27;, 7, &#x27;c&#x27;]</span></span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="entries-，keys-和values-用于遍历数组"><a href="#entries-，keys-和values-用于遍历数组" class="headerlink" title="entries()，keys()和values()用于遍历数组"></a>entries()，keys()和values()用于遍历数组</h2><p><strong>用于遍历数组。它们都返回一个遍历器对象，可以用for…of循环进行遍历。</strong></p>
<p><strong>keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//entries()是对键值对的遍历</span></span><br><span class="line"> <span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>);</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">let</span> [index,elem] <span class="keyword">of</span> arr.entries())&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(index,elem);</span><br><span class="line">   &#125;<span class="number">12345</span></span><br></pre></td></tr></table></figure>

<p><img src="/2021/05/06/ES6/20180527225006745" alt="这里写图片描述"></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//keys()是对键名的遍历</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> index <span class="keyword">of</span> [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>].keys()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1123456</span></span><br><span class="line"><span class="comment">//values()是对键值的遍历</span></span><br><span class="line"><span class="keyword">let</span> arr = [[<span class="string">&#x27;姓名&#x27;</span>,<span class="string">&#x27;阿蔡&#x27;</span>],[<span class="string">&#x27;年龄&#x27;</span>,<span class="string">&#x27;23&#x27;</span>]];</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">var</span> elem <span class="keyword">of</span> arr.values())&#123;  </span><br><span class="line">         <span class="built_in">console</span>.log(elem); </span><br><span class="line">  &#125;<span class="number">12345</span></span><br></pre></td></tr></table></figure>

<p>控制台结果：<br><img src="/2021/05/06/ES6/20180527232255407" alt="这里写图片描述"></p>
<hr>
<h2 id="includes"><a href="#includes" class="headerlink" title="includes()"></a>includes()</h2><p><strong>Array.prototype.includes方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的includes方法类似。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].includes(<span class="number">2</span>);     <span class="comment">// true</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].includes(<span class="number">4</span>);     <span class="comment">// false</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="literal">NaN</span>].includes(<span class="literal">NaN</span>); <span class="comment">// true123</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="函数的扩展"><a href="#函数的扩展" class="headerlink" title="函数的扩展"></a>函数的扩展</h1><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p><strong>，可以把参数默认值写在参数定义后面</strong><br>例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ES5写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (<span class="keyword">typeof</span> y === <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">  y = <span class="string">&#x27;World&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log(<span class="string">&#x27;Hello&#x27;</span>) <span class="comment">// Hello World</span></span><br><span class="line">log(<span class="string">&#x27;Hello&#x27;</span>, <span class="string">&#x27;China&#x27;</span>) <span class="comment">// Hello China</span></span><br><span class="line">log(<span class="string">&#x27;Hello&#x27;</span>, <span class="string">&#x27;&#x27;</span>) <span class="comment">// Hello World</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//ES6写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">x,y=<span class="string">&#x27;World&#x27;</span></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x, y);</span><br><span class="line">&#125;</span><br><span class="line">log(<span class="string">&#x27;Hello&#x27;</span>) <span class="comment">// Hello World</span></span><br><span class="line">log(<span class="string">&#x27;Hello&#x27;</span>, <span class="string">&#x27;China&#x27;</span>) <span class="comment">// Hello China</span></span><br><span class="line">log(<span class="string">&#x27;Hello&#x27;</span>, <span class="string">&#x27;&#x27;</span>) <span class="comment">// Hello</span></span><br><span class="line"><span class="number">1234567891011121314151617181920</span></span><br></pre></td></tr></table></figure>

<p>可以看到，ES6 的写法比 ES5 简洁许多。</p>
<p>*<strong>注意：参数变量是默认声明的，所以不能用let或const再次声明。*</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x = <span class="number">5</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">1</span>; <span class="comment">// error</span></span><br><span class="line">  <span class="keyword">const</span> x = <span class="number">2</span>; <span class="comment">// error</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure>

<h2 id="参数默认值的位置"><a href="#参数默认值的位置" class="headerlink" title="参数默认值的位置"></a>参数默认值的位置</h2><p><em><strong>*注意：如果非尾部的参数设置默认值，实际上这个参数是没法省略的。是非位数！！如果省略就报错*</strong></em><br>例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x,y=<span class="number">1</span></span>)</span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(x,y);</span><br><span class="line"> &#125;</span><br><span class="line"> foo(<span class="number">1</span>,); <span class="comment">//[1,undefined]</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">//如果是非尾部参数设置默认值</span></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x=<span class="number">1</span>,y</span>)</span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(x,y);</span><br><span class="line"> &#125;</span><br><span class="line">foo(,<span class="number">2</span>) <span class="comment">//报错12345678910</span></span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y = <span class="number">5</span>, z</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y, z];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f() <span class="comment">// [undefined, 5, undefined]</span></span><br><span class="line">f(<span class="number">1</span>) <span class="comment">// [1, 5, undefined]</span></span><br><span class="line">f(<span class="number">1</span>, ,<span class="number">2</span>) <span class="comment">// 报错</span></span><br><span class="line">f(<span class="number">1</span>, <span class="literal">undefined</span>, <span class="number">2</span>) <span class="comment">// [1, 5, 2]</span></span><br><span class="line"><span class="number">123456789</span></span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong><br><strong>有默认值的参数都不是尾参数。这时，无法只省略该参数，而不省略它后面的参数，除非显式输入undefined。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x = <span class="number">5</span>, y = <span class="number">6</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(<span class="literal">undefined</span>, <span class="literal">null</span>)</span><br><span class="line"><span class="comment">// 5 null123456</span></span><br></pre></td></tr></table></figure>

<p><strong>如果传入undefined，将触发该参数等于默认值，null则没有这个效果。</strong></p>
<hr>
<h2 id="函数的-length-属性"><a href="#函数的-length-属性" class="headerlink" title="函数的 length 属性"></a>函数的 length 属性</h2><p><strong>指定了默认值以后，函数的length属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，length属性将失真。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123;&#125;).length <span class="comment">// 1</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">a = <span class="number">5</span></span>) </span>&#123;&#125;).length <span class="comment">// 0</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">a, b, c = <span class="number">5</span></span>) </span>&#123;&#125;).length <span class="comment">// 2123</span></span><br></pre></td></tr></table></figure>

<p><strong>length属性的含义是，该函数预期传入的参数个数。某个参数指定默认值以后，预期传入的参数个数就不包括这个参数了。同理，rest参数也不会计入length属性。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;&#125;).length <span class="comment">// 01</span></span><br></pre></td></tr></table></figure>

<p><strong>如果设置了默认值的参数不是尾参数，那么length属性也不再计入后面的参数了。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">a = <span class="number">0</span>, b, c</span>) </span>&#123;&#125;).length <span class="comment">// 0</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">a, b = <span class="number">1</span>, c</span>) </span>&#123;&#125;).length <span class="comment">// 112</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p><strong>函数进行声明初始化时，参数会形成一个单独的作用域（context）。等到初始化结束，这个作用域就会消失。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">8</span>;</span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x,y = x</span>)</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(y)</span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> f();<span class="comment">//undefined</span></span><br><span class="line"> f(<span class="number">2</span>); <span class="comment">//2</span></span><br><span class="line"> f(<span class="number">1</span>,<span class="number">3</span>) <span class="comment">//312345678</span></span><br></pre></td></tr></table></figure>

<p><strong>参数y的默认值等于变量x。调用函数f时，参数形成一个单独的作用域。在这个作用域里面，默认值变量x指向第一个参数x，而不是全局变量x，所以输出是2。</strong></p>
<p>例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">y = x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f() <span class="comment">// 1123456789</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<strong>函数f调用时，参数y = x形成一个单独的作用域。这个作用域里面，变量x本身没有定义，所以指向外层的全局变量x。函数调用时，函数体内部的局部变量x影响不到默认值变量x。</strong></p>
<p>如果此时，全局变量x不存在，就会报错。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">y = x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f() <span class="comment">// ReferenceError: x is not defined</span></span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure>

<p>这样写，也会报错。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x = x</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo() <span class="comment">// ReferenceError: x is not defined</span></span><br><span class="line"><span class="number">12345678</span></span><br></pre></td></tr></table></figure>

<p><strong>参数x = x形成一个单独作用域。实际执行的是let x = x，由于暂时性死区的原因，这行代码会报错”x 未定义“。</strong></p>
<p>例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x, y = <span class="keyword">function</span>() &#123; x = <span class="number">2</span>; &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">3</span>;</span><br><span class="line">  y();</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo() <span class="comment">// 3</span></span><br><span class="line">x <span class="comment">// 1123456789</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，函数foo的参数形成一个单独作用域。这个作用域里面，首先声明了变量x，然后声明了变量y，y的默认值是一个匿名函数。这个匿名函数内部的变量x，指向同一个作用域的第一个参数x。函数foo内部又声明了一个内部变量x，该变量与第一个参数x由于不是同一个作用域，所以不是同一个变量，因此执行y后，内部变量x和外部全局变量x的值都没变。</p>
<hr>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p><strong>利用参数默认值，可以指定某一个参数不得省略，如果省略就抛出一个错误。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throwIfMissing</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Missing parameter&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">mustBeProvided = throwIfMissing()</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> mustBeProvided;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo()</span><br><span class="line"><span class="comment">// Error: Missing parameter12345678910</span></span><br></pre></td></tr></table></figure>

<p>上面代码的foo函数，如果调用的时候没有参数，就会调用默认值throwIfMissing函数，从而抛出一个错误。</p>
<hr>
<h2 id="rest参数"><a href="#rest参数" class="headerlink" title="rest参数"></a>rest参数</h2><p>ES6 引入 rest 参数（形式为“…变量名”），用于获取函数的多余参数。<br>例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">...values</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> val <span class="keyword">of</span> values) &#123;</span><br><span class="line">    sum += val;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(<span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>) <span class="comment">// 101234567891011</span></span><br></pre></td></tr></table></figure>

<p><strong>注意，rest 参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a, ...b, c</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;<span class="number">1234</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h2><p><strong>扩展运算符（spread）是三个点（…）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(...[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="comment">// 1 2 3</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>, ...[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="number">5</span>)</span><br><span class="line"><span class="comment">// 1 2 3 4 5</span></span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure>

<p><strong>扩展运算符可以用于函数的调用</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">push</span>(<span class="params">array, ...items</span>) </span>&#123;</span><br><span class="line">  array.push(...items);</span><br><span class="line">&#125;<span class="number">123</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x,y</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> numbers = [<span class="number">3</span>,<span class="number">7</span>];</span><br><span class="line">  <span class="built_in">console</span>.log(add(...numbers)); <span class="comment">//1012345</span></span><br></pre></td></tr></table></figure>

<p><strong>扩展运算符还可以与正常函数参数结合使用</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a,b,c,d,e</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a,b,c,d,e)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> number = [<span class="number">3</span>,<span class="number">5</span>];</span><br><span class="line">f(<span class="number">1</span>,...number,...[<span class="number">7</span>,<span class="number">9</span>])  <span class="comment">//1,3,5,7,912345</span></span><br></pre></td></tr></table></figure>

<h3 id="替代数组的apply方法"><a href="#替代数组的apply方法" class="headerlink" title="替代数组的apply方法"></a>替代数组的apply方法</h3><p><strong>由于扩展运算符可以展开数组，所以不再需要apply方法，将数组转为函数的参数了。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5的写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y, z</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> args = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">f.apply(<span class="literal">null</span>, args);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6的写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y, z</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> args = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">f(...args);</span><br><span class="line"><span class="number">1234567891011121314</span></span><br></pre></td></tr></table></figure>

<p><strong>通过push函数，将一个数组添加到另一个数组的尾部</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ES5的写法</span></span><br><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="built_in">Array</span>.prototype.push.apply(arr1,arr2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//ES6的写法</span></span><br><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">arr1.push(...arr2)<span class="number">123456789</span></span><br></pre></td></tr></table></figure>

<h3 id="扩展运算符的应用"><a href="#扩展运算符的应用" class="headerlink" title="扩展运算符的应用"></a>扩展运算符的应用</h3><p><strong>1.合并数组</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>].concat(more)</span><br><span class="line"><span class="comment">// ES6</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, ...more]<span class="number">1234</span></span><br></pre></td></tr></table></figure>

<p>例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">var</span> arr1 = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>];</span><br><span class="line"> <span class="keyword">var</span> arr2 = [<span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"> <span class="keyword">var</span> arr3 = [<span class="string">&#x27;b&#x27;</span>];</span><br><span class="line"></span><br><span class="line"> <span class="comment">//ES5写法</span></span><br><span class="line"> <span class="keyword">var</span> array = arr1.concat(arr2,arr3);</span><br><span class="line"> <span class="built_in">console</span>.log(array);    </span><br><span class="line"></span><br><span class="line"><span class="comment">//ES6写法</span></span><br><span class="line"><span class="keyword">var</span> array2 = [...arr1,...arr2,...arr3];</span><br><span class="line"> <span class="built_in">console</span>.log(array2);</span><br><span class="line"> <span class="comment">//[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;b&quot;]12345678910111213</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。</strong></p>
<p><strong>2.与解构赋值结合</strong><br><strong>扩展运算符可以与解构赋值结合起来，用于生成数组。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [first, ...rest] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">first <span class="comment">// 1</span></span><br><span class="line">rest  <span class="comment">// [2, 3, 4, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [first, ...rest] = [];</span><br><span class="line">first <span class="comment">// undefined</span></span><br><span class="line">rest  <span class="comment">// []:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [first, ...rest] = [<span class="string">&quot;foo&quot;</span>];</span><br><span class="line">first  <span class="comment">// &quot;foo&quot;</span></span><br><span class="line">rest   <span class="comment">// []1234567891011</span></span><br></pre></td></tr></table></figure>

<p>如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [...butLast, last] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [first, ...middle, last] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure>

<p><strong>3.函数的返回值</strong><br><strong>JavaScript的函数只能返回一个值，如果需要返回多个值，只能返回数组或对象。扩展运算符提供了解决这个问题的一种变通方法。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dateFields = readDateFields(database);</span><br><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>(...dateFields);<span class="number">12</span></span><br></pre></td></tr></table></figure>

<p>上面代码从数据库取出一行数据，通过扩展运算符，直接将其传入构造函数Date。</p>
<p><strong>4.字符串</strong><br><strong>扩展运算符还可以将字符串转为真正的数组。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[...<span class="string">&#x27;hello&#x27;</span>]</span><br><span class="line"><span class="comment">// [ &quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot; ]12</span></span><br></pre></td></tr></table></figure>

<p><strong>正确返回字符串长度的函数,识别32位的Unicode字符。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">length</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [...str].length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">length(<span class="string">&#x27;x\uD83D\uDE80y&#x27;</span>) <span class="comment">// 312345</span></span><br></pre></td></tr></table></figure>

<p><strong>5.实现了Iterator接口的对象</strong><br><strong>任何Iterator接口的对象，都可以用扩展运算符转为真正的数组。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nodeList = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> array = [...nodeList];</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>

<p><strong>6.Map和Set结构，Generator函数</strong><br><strong>扩展运算符内部调用的是数据结构的Iterator接口，因此只要具有Iterator接口的对象，都可以使用扩展运算符，比如Map结构。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([ <span class="comment">//Map是键值对结构</span></span><br><span class="line">  [<span class="number">1</span>,<span class="string">&#x27;one&#x27;</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="string">&#x27;two&#x27;</span>],</span><br><span class="line">  [<span class="number">3</span>,<span class="string">&#x27;three&#x27;</span>]</span><br><span class="line">])</span><br><span class="line"><span class="keyword">let</span> arr = [...map.keys()];</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [1, 2, 3]1234567</span></span><br></pre></td></tr></table></figure>

<p>*<strong>注意：Set和Map类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在Set中，没有重复的key。*</strong></p>
<hr>
<h2 id="name-属性"><a href="#name-属性" class="headerlink" title="name 属性"></a>name 属性</h2><p><strong>函数的name属性，返回该函数的函数名。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">foo.name <span class="comment">// &quot;foo&quot;12</span></span><br></pre></td></tr></table></figure>

<p><strong>ES6 对这个属性的行为做出了一些修改。如果将一个匿名函数赋值给一个变量，ES5 的name属性，会返回空字符串，而 ES6 的name属性会返回实际的函数名。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5</span></span><br><span class="line">f.name <span class="comment">// &quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6</span></span><br><span class="line">f.name <span class="comment">// &quot;f&quot;1234567</span></span><br></pre></td></tr></table></figure>

<p><strong>如果将一个具名函数赋值给一个变量，则 ES5 和 ES6 的name属性都返回这个具名函数原本的名字。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bar = <span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5</span></span><br><span class="line">bar.name <span class="comment">// &quot;baz&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6</span></span><br><span class="line">bar.name <span class="comment">// &quot;baz&quot;1234567</span></span><br></pre></td></tr></table></figure>

<p><strong>Function构造函数返回的函数实例，name属性的值为anonymous。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">new</span> <span class="built_in">Function</span>).name <span class="comment">// &quot;anonymous&quot;</span></span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>(箭头函数导致this总是指向函数定义生效时所在的对象)</p>
<p>基本用法</p>
<p><strong>ES6允许使用“箭头”（=&gt;）定义函数。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="params">v</span> =&gt;</span> v;<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>上面的箭头函数等同于：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> v;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>

<p>如果箭头函数不需要参数或多个参数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function">() =&gt;</span> <span class="number">5</span>;</span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sum = <span class="function">(<span class="params">num1,num2</span>) =&gt;</span> num1 + num2;</span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">num1,num2</span>)</span>&#123;<span class="keyword">return</span> num1 + num2&#125;</span><br><span class="line"><span class="number">12345678</span></span><br></pre></td></tr></table></figure>

<p><strong>如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用return语句返回。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> &#123; <span class="keyword">return</span> num1 + num2; &#125;<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><strong>由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getTempItem = <span class="function"><span class="params">id</span> =&gt;</span> (&#123; <span class="attr">id</span>: id, <span class="attr">name</span>: <span class="string">&quot;Temp&quot;</span> &#125;);<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><strong>箭头函数可以与变量解构结合使用。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> full = <span class="function">(<span class="params">&#123;first,last&#125;</span>) =&gt;</span> first + <span class="string">&#x27; &#x27;</span> + last;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">full</span>(<span class="params">person</span>)</span>&#123;</span><br><span class="line">   <span class="keyword">return</span> person.first + <span class="string">&#x27; &#x27;</span> + person.last;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure>

<p><strong>箭头函数的一个用处是简化回调函数。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ES5写法</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].map(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>))</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ES6写法</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].map(<span class="function"><span class="params">x</span> =&gt;</span> x * x);</span><br><span class="line"><span class="number">12345678</span></span><br></pre></td></tr></table></figure>

<p><strong>rest参数与箭头函数结合</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = <span class="function">(<span class="params">...nums</span>) =&gt;</span> nums;</span><br><span class="line">numbers(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>) <span class="comment">//[1,2,3,4]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> headAndTail = <span class="function">(<span class="params">head, ...tail</span>) =&gt;</span> [head, tail];</span><br><span class="line">headAndTail(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="comment">// [1,[2,3,4,5]]</span></span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure>

<p><strong>使用注意点</strong></p>
<p>箭头函数有几个使用注意点。</p>
<p>（1）函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。</p>
<p>（2）不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。</p>
<p>（3）不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用Rest参数代替。</p>
<p>（4）不可以使用yield命令，因此箭头函数不能用作Generator函数。</p>
<p><strong>箭头函数this指向问题</strong><br>箭头函数里面的this，绑定定义时所在的作用域，而不是指向运行时所在的作用域。</p>
<p>this指向的固定化，并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this，导致内部的this就是外层代码块的this。正是因为它没有this，所以也就不能用作构造函数。</p>
<hr>
<h1 id="对象的扩展"><a href="#对象的扩展" class="headerlink" title="对象的扩展"></a>对象的扩展</h1><h2 id="属性的整洁表达法"><a href="#属性的整洁表达法" class="headerlink" title="属性的整洁表达法"></a>属性的整洁表达法</h2><p>ES6允许直接写入变量和函数，作为对象的属性和方法。这样书写更简洁。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;foo&#125;;</span><br><span class="line">obj <span class="comment">//&#123;foo: &quot;bar&quot;&#125;123</span></span><br></pre></td></tr></table></figure>

<p><strong>ES6 允许在对象之中，直接写变量。这时，属性名为变量名, 属性值为变量的值</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数参数名直接作为对象属性值</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x,y</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">obj1</span>: x , <span class="attr">obj2</span>: y&#125;;</span><br><span class="line">  &#125; </span><br><span class="line">  f(<span class="number">1</span>,<span class="number">2</span>) <span class="comment">//&#123;obj1: 1, obj2: 2&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure>

<p><strong>除了属性简写，方法也可以简写</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ES5写法 </span></span><br><span class="line"> <span class="keyword">var</span> o = &#123;</span><br><span class="line">    method: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//ES6写法</span></span><br><span class="line"> <span class="keyword">var</span> o2 = &#123;</span><br><span class="line">   method:<span class="function">() =&gt;</span> <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"> &#125;<span class="number">1234567891011</span></span><br></pre></td></tr></table></figure>

<p>例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">var</span> birth = <span class="string">&#x27;1995/1/5&#x27;</span></span><br><span class="line"> <span class="keyword">var</span> Person = &#123;</span><br><span class="line">     name:<span class="string">&#x27;阿蔡&#x27;</span>,</span><br><span class="line">     birth,</span><br><span class="line">     <span class="function"><span class="title">hello</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"><span class="built_in">console</span>.log(Person);<span class="number">12345678910</span></span><br></pre></td></tr></table></figure>

<p>控制台结果：<br><img src="/2021/05/06/ES6/20180531144134542" alt="这里写图片描述"></p>
<p><strong>还可以，用于函数的返回值</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPoint</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">var</span> y = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;x, y&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getPoint() <span class="comment">// &#123;x:1, y:10&#125;1234567</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="属性名表达式"><a href="#属性名表达式" class="headerlink" title="属性名表达式"></a>属性名表达式</h2><p>JavaScript语言定义对象的属性，有两种方法。</p>
<p>// 方法一：直接用标识符作为属性名<br>obj.foo = true;</p>
<p>// 方法二：表达式作为属性名，这时要将表达式放在方括号之内<br>obj[‘a’ + ‘bc’] = 123;</p>
<p><strong>ES5和ES6字面量定义对象写法：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// ES5</span></span><br><span class="line">  <span class="keyword">var</span> obj = &#123;</span><br><span class="line">       foo: <span class="literal">true</span>,</span><br><span class="line">       abc: <span class="number">123</span></span><br><span class="line">  &#125;</span><br><span class="line">   <span class="built_in">console</span>.log(obj);  <span class="comment">//&#123;foo: true, abc: 123&#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//ES6</span></span><br><span class="line">  <span class="keyword">let</span> propKey = <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line">  <span class="keyword">let</span> obj2 = &#123;</span><br><span class="line">      [propKey]: <span class="literal">true</span>,</span><br><span class="line">      [<span class="string">&#x27;a&#x27;</span> + <span class="string">&#x27;bc&#x27;</span>]: <span class="number">123</span> </span><br><span class="line">  &#125;; </span><br><span class="line">  <span class="built_in">console</span>.log(obj2);  <span class="comment">//&#123;foo: true, abc: 123&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="number">12345678910111213141516</span></span><br></pre></td></tr></table></figure>

<p>例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lastWord = <span class="string">&#x27;last word&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">  <span class="string">&#x27;first word&#x27;</span>: <span class="string">&#x27;hello&#x27;</span>,</span><br><span class="line">  [lastWord]: <span class="string">&#x27;world&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">a[<span class="string">&#x27;first word&#x27;</span>] <span class="comment">// &quot;hello&quot;</span></span><br><span class="line">a[lastWord] <span class="comment">// &quot;world&quot;</span></span><br><span class="line">a[<span class="string">&#x27;last word&#x27;</span>] <span class="comment">// &quot;world&quot;</span></span><br><span class="line"><span class="number">1234567891011</span></span><br></pre></td></tr></table></figure>

<p><strong>表达式还可以用于定义方法名</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">let</span> obj = &#123;</span><br><span class="line">      [<span class="string">&#x27;h&#x27;</span> + <span class="string">&#x27;ello&#x27;</span>]()&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">console</span>.log(obj.hello())    <span class="comment">//hello</span></span><br><span class="line">   <span class="comment">//或者可以这么写  obj[&#x27;h&#x27; + &#x27;ello&#x27;]()</span></span><br><span class="line"><span class="number">12345678</span></span><br></pre></td></tr></table></figure>

<p><strong>注意，属性名表达式与简洁表示法，不能同时使用，会报错。</strong></p>
<p>正确写法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">let</span> name = <span class="string">&#x27;姓名：&#x27;</span>;</span><br><span class="line">    <span class="keyword">let</span> obj = &#123;[name]:<span class="string">&#x27;阿蔡&#x27;</span>&#125; <span class="comment">//&#123;姓名：: &quot;阿蔡&quot;&#125; </span></span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="方法的-name-属性"><a href="#方法的-name-属性" class="headerlink" title="方法的 name 属性"></a>方法的 name 属性</h2><p><strong>1、函数的name属性，返回函数名。对象方法也是函数，因此也有name属性。</strong></p>
<p>例：name属性返回函数名</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">const</span> person = &#123;</span><br><span class="line">      <span class="function"><span class="title">sayName</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">console</span>.log(person.sayName.name); <span class="comment">//sayName</span></span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure>

<p><strong>2、name属性读取取值函数（getter）和存值函数（setter）上的方法</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">foo</span>() &#123;&#125;,</span><br><span class="line">  <span class="keyword">set</span> <span class="title">foo</span>(<span class="params">x</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.foo.name</span><br><span class="line"><span class="comment">// TypeError: Cannot read property &#x27;name&#x27; of undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"></span><br><span class="line">descriptor.get.name <span class="comment">// &quot;get foo&quot;</span></span><br><span class="line">descriptor.set.name <span class="comment">// &quot;set foo&quot;</span></span><br><span class="line"><span class="number">12345678910111213</span></span><br></pre></td></tr></table></figure>

<p><strong>3、bind方法创造的函数，name属性返回bound加上原函数的名字；Function构造函数创造的函数，name属性返回anonymous。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">new</span> <span class="built_in">Function</span>()).name <span class="comment">// &quot;anonymous&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> doSomething = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line">doSomething.bind().name <span class="comment">// &quot;bound doSomething&quot;</span></span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure>

<p><strong>4.如果对象的方法是一个 Symbol 值，那么name属性返回的是这个 Symbol 值的描述。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> key1 = <span class="built_in">Symbol</span>(<span class="string">&#x27;description&#x27;</span>);  <span class="comment">//新的原始数据类型Symbol,表示独一无二的值</span></span><br><span class="line"><span class="keyword">const</span> key2 = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  [key1]() &#123;&#125;,</span><br><span class="line">  [key2]() &#123;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">obj[key1].name <span class="comment">// &quot;[description]&quot;</span></span><br><span class="line">obj[key2].name <span class="comment">// &quot;&quot;12345678</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Object-is"><a href="#Object-is" class="headerlink" title="Object.is()"></a>Object.is()</h2><p><strong>在ES5中，比较两个值是否相等，只有两个运算符：相等运算符（==）和严格等于运算符（===）。</strong></p>
<p>但是缺点：<br>（==）会自动转换数据类型。<br>（===）NaN不等于自身，+0等于-0。</p>
<p><strong>在ES6中，Object.is()可以比较两个值是否相等，与严格相等运算符行为基本一致，不同处在于：NaN等于自身，+0不等于-0</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ES6写法</span></span><br><span class="line"> <span class="built_in">Object</span>.is(<span class="string">&#x27;foo&#x27;</span>,<span class="string">&#x27;foo&#x27;</span>) <span class="comment">//true</span></span><br><span class="line"> <span class="built_in">Object</span>.is(&#123;&#125;,&#123;&#125;)  <span class="comment">//false</span></span><br><span class="line"> <span class="built_in">Object</span>.is(<span class="string">&#x27;+0&#x27;</span>,<span class="string">&#x27;-0&#x27;</span>) <span class="comment">//false</span></span><br><span class="line"> <span class="built_in">Object</span>.is(<span class="literal">NaN</span>,<span class="literal">NaN</span>) <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//ES5写法</span></span><br><span class="line">+<span class="number">0</span> === -<span class="number">0</span> <span class="comment">//true</span></span><br><span class="line"><span class="literal">NaN</span> === <span class="literal">NaN</span> <span class="comment">//false</span></span><br><span class="line"><span class="number">12345678910</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h2><p><strong>基本用法</strong><br><strong>Object.assign方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> targeObject.assign方法的第一个参数是目标对象，后面的参数都是源对象t = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> source1 = &#123; <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> source2 = &#123; <span class="attr">c</span>: <span class="number">3</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.assign(target, source1, source2);</span><br><span class="line">target <span class="comment">// &#123;a:1, b:2, c:3&#125;1234567</span></span><br></pre></td></tr></table></figure>

<p><strong>Object.assign方法的第一个参数是目标对象，后面的参数都是源对象。</strong></p>
<p>*<strong>1.注意，如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。*</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> target = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> source1 = &#123; <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> source2 = &#123; <span class="attr">c</span>: <span class="number">3</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.assign(target, source1, source2);</span><br><span class="line">target <span class="comment">// &#123;a:1, b:2, c:3&#125;1234567</span></span><br></pre></td></tr></table></figure>

<p>例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> target = &#123; <span class="attr">a</span>: &#123; <span class="attr">b</span>: <span class="string">&#x27;c&#x27;</span>, <span class="attr">d</span>: <span class="string">&#x27;e&#x27;</span> &#125; &#125;</span><br><span class="line"><span class="keyword">var</span> source = &#123; <span class="attr">a</span>: &#123; <span class="attr">b</span>: <span class="string">&#x27;hello&#x27;</span> &#125; &#125;</span><br><span class="line"><span class="built_in">Object</span>.assign(target, source)</span><br><span class="line"><span class="comment">// &#123; a: &#123; b: &#x27;hello&#x27; &#125; &#125;1234</span></span><br></pre></td></tr></table></figure>

<p>*<strong>2.对于这种嵌套的对象，一旦遇到同名属性，Object.assign的处理方法是替换，而不是添加。*</strong></p>
<p><strong>3.如果该参数不是对象，则会先转成对象，然后返回。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="built_in">Object</span>.assign(<span class="number">2</span>) <span class="comment">// &quot;object&quot;1</span></span><br></pre></td></tr></table></figure>

<p><strong>4.undefined和null无法转成对象，所以如果它们作为参数，就会报错。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.assign(<span class="literal">undefined</span>) <span class="comment">// 报错</span></span><br><span class="line"><span class="built_in">Object</span>.assign(<span class="literal">null</span>) <span class="comment">// 报错12</span></span><br></pre></td></tr></table></figure>

<p><strong>5.非对象参数出现在源对象的位置（即非首参数），那么处理规则有所不同。首先，这些参数都会转成对象，如果无法转成对象，就会跳过。这意味着，如果undefined和null不在首参数，就不会报错。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="built_in">Object</span>.assign(obj, <span class="literal">undefined</span>) === obj <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span>.assign(obj, <span class="literal">null</span>) === obj <span class="comment">// true123</span></span><br></pre></td></tr></table></figure>

<p><strong>6.其他类型的值（即数值、字符串和布尔值）不在首参数，也不会报错。但是，除了字符串会以数组形式，拷贝入目标对象，其他值都不会产生效果。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> v1 = <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> v2 = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span> v3 = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.assign(&#123;&#125;, v1, v2, v3);</span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// &#123; &quot;0&quot;: &quot;a&quot;, &quot;1&quot;: &quot;b&quot;, &quot;2&quot;: &quot;c&quot; &#125;123456</span></span><br></pre></td></tr></table></figure>

<p>v1、v2、v3分别是字符串、布尔值和数值，结果只有字符串合入目标对象（以字符数组的形式），数值和布尔值都会被忽略。这是因为只有字符串的包装对象，会产生可枚举属性。</p>
<p><strong>7.Object.assign拷贝的属性是有限制的，只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝不可枚举的属性（enumerable: false）</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.assign(&#123;<span class="attr">b</span>: <span class="string">&#x27;c&#x27;</span>&#125;,</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(&#123;&#125;, <span class="string">&#x27;invisible&#x27;</span>, &#123;</span><br><span class="line">    enumerable: <span class="literal">false</span>,</span><br><span class="line">    value: <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">  &#125;)</span><br><span class="line">)</span><br><span class="line"><span class="comment">// &#123; b: &#x27;c&#x27; &#125;1234567</span></span><br></pre></td></tr></table></figure>

<p><strong>8.属性名为Symbol值的属性，也会被Object.assign拷贝。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.assign(&#123; <span class="attr">a</span>: <span class="string">&#x27;b&#x27;</span> &#125;, &#123; [<span class="built_in">Symbol</span>(<span class="string">&#x27;c&#x27;</span>)]: <span class="string">&#x27;d&#x27;</span> &#125;)</span><br><span class="line"><span class="comment">// &#123; a: &#x27;b&#x27;, Symbol(c): &#x27;d&#x27; &#125;12</span></span><br></pre></td></tr></table></figure>

<p>*<strong>注意：Object.assign方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。*</strong></p>
<p><strong>9.Object.assign可以用来处理数组，但是会把数组视为对象。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.assign([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>]) <span class="comment">//[4,5,3]</span></span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>

<p>上面代码，Object.assign把数组视为属性名为0、1、2的对象，因此源数组的0号属性4覆盖了目标数组的0号属性1。</p>
<h3 id="常见用途"><a href="#常见用途" class="headerlink" title="常见用途"></a>常见用途</h3><p><strong>（1）为对象添加属性</strong><br>通过Object.assign方法，将x属性和y属性添加到Point类的对象实例。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">x, y</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">Object</span>.assign(<span class="built_in">this</span>, &#123;x, y&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure>

<p><strong>（2）为对象添加方法</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.assign(SomeClass.prototype, &#123;</span><br><span class="line">  <span class="function"><span class="title">someMethod</span>(<span class="params">arg1, arg2</span>)</span> &#123;</span><br><span class="line">    ···</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">anotherMethod</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    ···</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);<span class="number">12345678</span></span><br></pre></td></tr></table></figure>

<p><strong>（3）克隆对象</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">origin</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, origin);</span><br><span class="line">&#125;<span class="number">123</span></span><br></pre></td></tr></table></figure>

<p>上面代码将原始对象拷贝到一个空对象，就得到了原始对象的克隆。</p>
<p>如果想要保持继承链，可以采用下面的代码。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">origin</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> originProto = <span class="built_in">Object</span>.getPrototypeOf(origin);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.assign(<span class="built_in">Object</span>.create(originProto), origin);</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure>

<p><strong>（4）合并多个对象</strong></p>
<p>将多个对象合并到某个对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> merge =</span><br><span class="line">  (target, ...sources) =&gt; <span class="built_in">Object</span>.assign(target, ...sources);<span class="number">12</span></span><br></pre></td></tr></table></figure>

<p>如果希望合并后返回一个新对象，可以改写上面函数，对一个空对象合并。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> merge =</span><br><span class="line">  (...sources) =&gt; <span class="built_in">Object</span>.assign(&#123;&#125;, ...sources);</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>

<p><strong>（5）为属性指定默认值</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> DEFAULTS = &#123;</span><br><span class="line">  logLevel: <span class="number">0</span>,</span><br><span class="line">  outputFormat: <span class="string">&#x27;html&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">processContent</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">  options = <span class="built_in">Object</span>.assign(&#123;&#125;, DEFAULTS, options);</span><br><span class="line">  <span class="built_in">console</span>.log(options);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;<span class="number">12345678910</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，DEFAULTS对象是默认值，options对象是用户提供的参数。Object.assign方法将DEFAULTS和options合并成一个新对象，如果两者有同名属性，则option的属性值会覆盖DEFAULTS的属性值。</p>
<hr>
<h2 id="属性可枚举性"><a href="#属性可枚举性" class="headerlink" title="属性可枚举性"></a>属性可枚举性</h2><p><strong>对象的每个属性都有一个描述对象（Descriptor），用来控制该属性的行为。Object.getOwnPropertyDescriptor方法可以获取该属性的描述对象。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">foo</span>:<span class="number">123</span>&#125;;</span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescripto(obj,<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"><span class="comment">//  &#123;</span></span><br><span class="line"><span class="comment">//    value: 123,</span></span><br><span class="line"><span class="comment">//    writable: true,</span></span><br><span class="line"><span class="comment">//    enumerable: true,  //描述对象enumerable属性，称为“可枚举性”，如果该属性为false，就表示某些操作会忽略当前属性。</span></span><br><span class="line"><span class="comment">//    configurable: true</span></span><br><span class="line"><span class="comment">//  &#125;</span></span><br><span class="line"><span class="number">123456789</span></span><br></pre></td></tr></table></figure>

<p><strong>ES5有三个操作会忽略enumerable为false的属性。</strong><br>for…in循环：只遍历对象自身的和继承的可枚举的属性<br>Object.keys()：返回对象自身的所有可枚举的属性的键名<br>JSON.stringify()：只串行化对象自身的可枚举的属性</p>
<p><strong>ES6新增了一个操作Object.assign()，会忽略enumerable为false的属性，只拷贝对象自身的可枚举的属性。</strong></p>
<p>toString和length属性的enumerable都是false，因此for…in不会遍历到这两个继承自原型的属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(<span class="built_in">Object</span>.prototype,<span class="string">&#x27;toString&#x27;</span>).enumerable <span class="comment">//false</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor([],<span class="string">&#x27;length&#x27;</span>).enumerable <span class="comment">//false</span></span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>

<p>另外，ES6规定，所有Class的原型的方法都是不可枚举的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(<span class="class"><span class="keyword">class</span> </span>&#123;<span class="function"><span class="title">foo</span>(<span class="params"></span>)</span>&#123;&#125;&#125;.prototype, <span class="string">&#x27;foo&#x27;</span>).enumerable <span class="comment">// false</span></span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="属性的遍历"><a href="#属性的遍历" class="headerlink" title="属性的遍历"></a>属性的遍历</h2><p>ES6一共有5种方法可以遍历对象的属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">a</span>:<span class="string">&#x27;1&#x27;</span>,[<span class="built_in">Symbol</span>(<span class="string">&#x27;b&#x27;</span>)]:<span class="number">2</span>,<span class="attr">d</span>:<span class="number">4</span>&#125;;</span><br><span class="line">    <span class="comment">//添加新的属性</span></span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(obj,<span class="string">&#x27;c&#x27;</span>,&#123;</span><br><span class="line">        value:<span class="number">3</span>,</span><br><span class="line">        enumerable:<span class="literal">false</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(obj); <span class="comment">//&#123;a: &quot;1&quot;, d: 4, c: 3, Symbol(b): 2&#125;</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">//属性遍历</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">//1.for...in循环，遍历对象自身和继承可枚举性</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> obj)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i) <span class="comment">//a , b</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//2.Object.keys返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含Symbol属性）。</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(obj)); <span class="comment">//[&quot;a&quot;, &quot;d&quot;]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.Object.getOwnPropertyNames返回一个数组，包含对象自身的所有属性（不含Symbol属性，但是包括不可枚举属性）。</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyNames(obj)) <span class="comment">//[&quot;a&quot;, &quot;d&quot;, &quot;c&quot;]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.Object.getOwnPropertySymbols(obj)返回一个数组，包含对象自身的所有Symbols属性</span></span><br><span class="line">   <span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertySymbols(obj))   <span class="comment">//[Symbol(b)]</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//5返回一个数组，包含对象自身的所有属性，不管是属性名是Symbol或字符串，也不管是否可枚举。</span></span><br><span class="line">   <span class="built_in">console</span>.log(<span class="built_in">Reflect</span>.ownKeys(obj)) <span class="comment">//[&quot;a&quot;, &quot;d&quot;, &quot;c&quot;, Symbol(b)]12345678910111213141516171819202122232425262728</span></span><br></pre></td></tr></table></figure>

<p>以上的5种方法遍历对象的属性，都遵守同样的属性遍历的次序规则。</p>
<p>首先遍历所有属性名为数值的属性，按照数字排序。<br>其次遍历所有属性名为字符串的属性，按照生成时间排序。<br>最后遍历所有属性名为Symbol值的属性，按照生成时间排序。</p>
<hr>
<h2 id="proto属性，Object-setPrototypeOf-，Object-getPrototypeOf"><a href="#proto属性，Object-setPrototypeOf-，Object-getPrototypeOf" class="headerlink" title="proto属性，Object.setPrototypeOf()，Object.getPrototypeOf()"></a><strong>proto</strong>属性，Object.setPrototypeOf()，Object.getPrototypeOf()</h2><h3 id="proto属性"><a href="#proto属性" class="headerlink" title="proto属性"></a><strong>proto</strong>属性</h3><p><strong>proto</strong>属性（前后各两个下划线），用来读取或设置当前对象的prototype(原型)对象。目前，所有浏览器（包括 IE11）都部署了这个属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//es6的写法</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  method:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;...&#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.__proto__ = someOtherObj;</span><br><span class="line"></span><br><span class="line"><span class="comment">//es5的写法</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.create(someOtherObj);</span><br><span class="line">obj.method = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; ... &#125;;</span><br><span class="line"><span class="number">12345678910</span></span><br></pre></td></tr></table></figure>

<p>注意：该属性没有写入 ES6 的正文，本质上是一个内部属性，而不是一个正式的对外的 API。无论从语义的角度，还是从兼容性的角度，都不要使用这个属性，而是使用下面的<strong>Object.setPrototypeOf()（写操作）、Object.getPrototypeOf()（读操作）、Object.create()（生成操作）</strong>代替。</p>
<hr>
<h2 id="Object-setPrototypeOf"><a href="#Object-setPrototypeOf" class="headerlink" title="Object.setPrototypeOf()"></a>Object.setPrototypeOf()</h2><p><strong>Object.setPrototypeOf方法的作用与*<em>proto</em>*相同，用来设置一个对象的prototype对象，返回参数对象本身。它是 ES6 正式推荐的设置原型对象的方法。</strong></p>
<p>格式：</p>
<blockquote>
<p>Object.setPrototypeOf(object, prototype)</p>
</blockquote>
<p>用法：</p>
<blockquote>
<p>var o = Object.setPrototypeOf({}, null)</p>
</blockquote>
<p>举个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> proto = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">x</span>:<span class="number">10</span>&#125;;</span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(obj,proto); <span class="comment">//proto对象设为obj对象的原型，所以从obj对象可以读取proto对象的属性。</span></span><br><span class="line"></span><br><span class="line">proto.y = <span class="number">20</span>;</span><br><span class="line">proto.z = <span class="number">40</span>;</span><br><span class="line">obj.x <span class="comment">//10</span></span><br><span class="line">obj.y <span class="comment">//20</span></span><br><span class="line">obj.z <span class="comment">//40</span></span><br><span class="line"><span class="number">12345678910</span></span><br></pre></td></tr></table></figure>

<p>如果第一个参数不是对象，会自动转为对象。但是由于返回的还是第一个参数，所以这个操作不会产生任何效果。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.setPrototypeOf(<span class="number">1</span>, &#123;&#125;) === <span class="number">1</span> <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(<span class="string">&#x27;foo&#x27;</span>, &#123;&#125;) === <span class="string">&#x27;foo&#x27;</span> <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(<span class="literal">true</span>, &#123;&#125;) === <span class="literal">true</span> <span class="comment">// true</span></span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>

<p>由于undefined和null无法转为对象，所以如果第一个参数是undefined或null，就会报错。</p>
<hr>
<h2 id="Object-getPrototypeOf"><a href="#Object-getPrototypeOf" class="headerlink" title="Object.getPrototypeOf()"></a>Object.getPrototypeOf()</h2><p><strong>该方法与Object.setPrototypeOf方法配套，用于读取一个对象的原型对象。</strong></p>
<blockquote>
<p>Object.getPrototypeOf(obj);</p>
</blockquote>
<p>举个例子</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> rec = <span class="keyword">new</span> foo();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(rec) === foo.prototype)；<span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.setPrototypeOf(rec, <span class="built_in">Object</span>.prototype)); <span class="comment">//__proto__ :Object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(rec) === foo.prototype)；<span class="comment">// false12345678910</span></span><br></pre></td></tr></table></figure>

<p><strong>如果参数不是对象，会被自动转为对象</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getPrototypeOf(<span class="number">1</span>) <span class="comment">// Number &#123;[[PrimitiveValue]]: 0&#125;</span></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(<span class="string">&#x27;foo&#x27;</span>) <span class="comment">//String &#123;length: 0, [[PrimitiveValue]]: &quot;&quot;&#125;</span></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(<span class="literal">true</span>) <span class="comment">// Boolean &#123;[[PrimitiveValue]]: false&#125;</span></span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>

<p><strong>如果参数是undefined或null,则无法转化为对象。直接报错。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getPrototypeOf(<span class="literal">undefined</span>)</span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(<span class="literal">null</span>)</span><br><span class="line"><span class="comment">// TypeError: Cannot convert undefined or null to object</span></span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Object-keys"><a href="#Object-keys" class="headerlink" title="Object.keys()"></a>Object.keys()</h2><p><strong>ES5 引入了Object.keys方法，返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键名。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">foo</span>:<span class="string">&#x27;bar&#x27;</span>,<span class="attr">baz</span>:<span class="number">42</span>&#125;;</span><br><span class="line"><span class="built_in">Object</span>.keys(obj) <span class="comment">//[&#x27;foo&#x27;,&#x27;baz&#x27;];</span></span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>

<p>ES7 引入了跟Object.keys配套的Object.values和Object.entries，作为遍历一个对象的补充手段，供for…of循环使用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;keys,values,entries&#125; = <span class="built_in">Object</span>;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">a</span>:<span class="number">1</span>,<span class="attr">b</span>:<span class="number">2</span>,<span class="attr">c</span>:<span class="number">3</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(keys(obj))  <span class="comment">//[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">of</span> keys(obj))&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key); <span class="comment">//a,b,c</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> value <span class="keyword">of</span> values(obj))&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(value) <span class="comment">// 1,2,3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> [key,value] <span class="keyword">of</span> entries(obj))&#123;</span><br><span class="line">   <span class="built_in">console</span>.log([key,value]);  <span class="comment">// [&#x27;a&#x27;, 1], [&#x27;b&#x27;, 2], [&#x27;c&#x27;, 3]</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Object-values"><a href="#Object-values" class="headerlink" title="Object.values()"></a>Object.values()</h2><p>Object.values方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">foo</span>:<span class="string">&#x27;bar&#x27;</span>,<span class="attr">baz</span>:<span class="number">42</span>&#125;;</span><br><span class="line"><span class="built_in">Object</span>.values(obj) <span class="comment">// [&quot;bar&quot;, 42]</span></span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>

<p><strong>属性名为数值的属性，是按照数值大小，从小到大遍历的。因此返回的顺序是b、c、a。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="number">100</span>: <span class="string">&#x27;a&#x27;</span>, <span class="number">2</span>: <span class="string">&#x27;b&#x27;</span>, <span class="number">7</span>: <span class="string">&#x27;c&#x27;</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.values(obj) <span class="comment">//[&quot;b&quot;, &quot;c&quot;, &quot;a&quot;]</span></span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>

<p><strong>Object.values只返回对象自身的可遍历属性。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.create(&#123;&#125;, &#123;<span class="attr">p</span>:&#123;<span class="attr">value</span>:<span class="number">1</span>&#125;&#125;);</span><br><span class="line"><span class="built_in">Object</span>.values(obj) <span class="comment">//[]</span></span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，用Object.create方法的第二参数添加对象属性，默认情况下不可遍历，因为p<strong>属性描述对象enumerable默认是false</strong>，<strong>Object.values不会返回这个属性。只要把enumerable改成true,Object.values就会返回属性p的值</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.create(&#123;&#125;,&#123;<span class="attr">p</span>:&#123;</span><br><span class="line">    value:<span class="number">1</span>,</span><br><span class="line">    enumerable:<span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">Object</span>.values(obj) <span class="comment">// [42]</span></span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure>

<p><strong>Object.values会过滤属性名为 Symbol 值的属性。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.values(&#123; [<span class="built_in">Symbol</span>()]: <span class="number">123</span>, <span class="attr">foo</span>: <span class="string">&#x27;abc&#x27;</span> &#125;);</span><br><span class="line"><span class="comment">// [&#x27;abc&#x27;]12</span></span><br></pre></td></tr></table></figure>

<p><strong>如果Object.values方法的参数是一个字符串，会返回各个字符组成的一个数组。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.values(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"><span class="comment">// [&#x27;f&#x27;, &#x27;o&#x27;, &#x27;o&#x27;]</span></span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>

<p><strong>如果参数不是对象，Object.values会先将其转为对象。由于数值和布尔值的包装对象，都不会为实例添加非继承的属性。所以，Object.values会返回空数组。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.values(<span class="number">42</span>) <span class="comment">// []</span></span><br><span class="line"><span class="built_in">Object</span>.values(<span class="literal">true</span>) <span class="comment">// []</span></span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Object-entries"><a href="#Object-entries" class="headerlink" title="Object.entries"></a>Object.entries</h2><p><strong>Object.entries方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对数组。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">foo</span>:<span class="string">&#x27;bar&#x27;</span>,<span class="attr">baz</span>:<span class="string">&#x27;42&#x27;</span>&#125;;</span><br><span class="line"><span class="built_in">Object</span>.entries(obj) <span class="comment">//[foo:&#x27;bar&#x27;,baz:&#x27;42&#x27;]</span></span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>

<p>除了返回值不一样，该方法的行为与Object.values基本一致。<br><strong>如果原对象的属性名是一个Symbol值，该属性会被忽略。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;[<span class="built_in">Symbol</span>()]:<span class="number">123</span>,<span class="attr">foo</span>:<span class="string">&#x27;abc&#x27;</span>&#125;;</span><br><span class="line"><span class="built_in">Object</span>.entries(obj) <span class="comment">// [&#x27;foo&#x27;,&#x27;abc&#x27;]</span></span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="对象的扩展运算符"><a href="#对象的扩展运算符" class="headerlink" title="对象的扩展运算符"></a>对象的扩展运算符</h2><p><strong>（1）解构赋值</strong><br>对象的解构赋值用于从一个对象取值，相当于将所有可遍历的，但尚未被读取的属性，分配到指定的对象上面。所有的键和它们的值，都会拷贝到新对象上面。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">let</span> &#123;x,y,...z&#125; = &#123;<span class="attr">x</span>:<span class="number">1</span>,<span class="attr">y</span>:<span class="number">2</span>,<span class="attr">a</span>:<span class="number">3</span>,<span class="attr">b</span>:<span class="number">4</span>&#125;;</span><br><span class="line">  x <span class="comment">//1</span></span><br><span class="line">  y <span class="comment">//2</span></span><br><span class="line">  z <span class="comment">//&#123;a:3,b:4&#125;</span></span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure>

<p><strong>解构赋值要求等会右边是一个对象，所以如果等会右边是undefined或null，就会报错。因为它们无法转化为对象。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;x,y,...z&#125; = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> &#123;x,y,...z&#125; = <span class="literal">undefined</span></span><br><span class="line"><span class="comment">//运行时发生错误</span></span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>

<p><strong>解构赋值必须是最后一个参数，否则会报错</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;...x,y,z&#125; = obj <span class="comment">//句法错误</span></span><br><span class="line"><span class="keyword">let</span> &#123;x,...y,...z&#125; = obj <span class="comment">//句法错误</span></span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>

<p>只要解构赋值不是最后一个参数，就会报错。</p>
<p><strong>注意，解构赋值的拷贝是浅拷贝，即如果一个键的值是复合类型的值（数组、对象、函数）、那么解构赋值拷贝的是这个值的引用，而不是这个值的副本。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">a</span>:&#123;<span class="attr">b</span>:<span class="number">1</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;...x&#125; = obj;</span><br><span class="line">obj.a.b = <span class="number">2</span>;</span><br><span class="line">x.a.b <span class="comment">//2</span></span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，x是结构赋值所在的对象，拷贝了对象的a属性。a属性引用了一个对象，修改了这个对象的值，会影响到解构赋值对它的引用。</p>
<p>另外，<strong>解构赋值不会拷贝继承自原型对象的属性</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o1 = &#123;<span class="attr">a</span>:<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> o2 = &#123;<span class="attr">b</span>:<span class="number">2</span>&#125;;</span><br><span class="line">o2.__proto__ = o1;</span><br><span class="line"><span class="keyword">let</span> o3 = &#123;...o2&#125;;</span><br><span class="line">o3 <span class="comment">//&#123;b:2&#125;</span></span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，对象o3是o2的拷贝，但是只复制了o2自身的属性，没有复制它的原型对象o1的属性。</p>
<p><strong>解构赋值的一个用处，是扩展某个函数的参数，引入其他操作。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">&#123;a,b&#125;</span>)</span>&#123;</span><br><span class="line"> <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wrapFoo</span>(<span class="params">&#123;x,y,...restConfig&#125;</span>)</span>&#123;</span><br><span class="line">   <span class="comment">// 使用x和y参数进行操作</span></span><br><span class="line">  <span class="comment">// 其余参数传给原始函数</span></span><br><span class="line">  <span class="keyword">return</span> foo(restConfig);</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789</span></span><br></pre></td></tr></table></figure>

<p>原始函数foo接受a和b作为参数，函数wrapFoo在foo的基础上进行了扩展，能够接受多余的参数，并且保留原始函数的行为。</p>
<p><strong>（2）扩展运算符</strong><br>扩展运算符（…）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> z = &#123;<span class="attr">a</span>:<span class="number">1</span>,<span class="attr">b</span>:<span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> n = &#123;...z&#125;;</span><br><span class="line">n <span class="comment">// &#123;a:1, b:2&#125;</span></span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>

<p>这等同于使用Object.assign方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> aClone = &#123;...a&#125;;</span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line"><span class="keyword">let</span> aClone = <span class="built_in">Object</span>.assign(&#123;&#125;,a)</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>

<p><strong>扩展运算符可以用于合并两个对象</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ab = &#123; ...a, ...b &#125;;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> ab = <span class="built_in">Object</span>.assign(&#123;&#125;, a, b);</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>

<p><strong>扩展运算符的参数对象之中，如果有取值函数get，这个函数是会执行的。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 并不会抛出错误，因为x属性只是被定义，但没执行</span></span><br><span class="line"><span class="keyword">let</span> aWithXGetter = &#123;</span><br><span class="line">  ...a,</span><br><span class="line">  <span class="keyword">get</span> <span class="title">x</span>() &#123;</span><br><span class="line">    throws <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;not thrown yet&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 会抛出错误，因为x属性被执行了</span></span><br><span class="line"><span class="keyword">let</span> runtimeError = &#123;</span><br><span class="line">  ...a,</span><br><span class="line">  ...&#123;</span><br><span class="line">    <span class="keyword">get</span> <span class="title">x</span>() &#123;</span><br><span class="line">      throws <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;thrown now&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="number">123456789101112131415161718</span></span><br></pre></td></tr></table></figure>

<p><strong>如果扩展运算符的参数是null或undefined,这两个值会被忽略，不会报错。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;...null,...undefined&#125;; <span class="comment">//不报错</span></span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Object-getOwnPropertyDescriptors"><a href="#Object-getOwnPropertyDescriptors" class="headerlink" title="Object.getOwnPropertyDescriptors()"></a>Object.getOwnPropertyDescriptors()</h2><p><strong>ES5有一个Object.getOwnPropertyDescriptor方法，返回某个对象属性的描述对象（descriptor）。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">p</span>:<span class="string">&#x27;a&#x27;</span>&#125;;</span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptors(obj,<span class="string">&#x27;p&#x27;</span>) <span class="comment">//切记描述对象要加上&#x27;&#x27;</span></span><br><span class="line"><span class="comment">//&#123;value: &quot;a&quot;, writable: true, enumerable: true, configurable: true&#125;</span></span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>

<p><strong>ES2017 引入了Object.getOwnPropertyDescriptors方法，返回指定对象所有自身属性（非继承属性）的描述对象。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    foo:<span class="number">123</span>,</span><br><span class="line">    <span class="keyword">get</span> <span class="title">bar</span>() &#123; <span class="keyword">return</span> <span class="string">&#x27;abc&#x27;</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptors(obj)</span><br><span class="line"><span class="comment">// &#123; foo:</span></span><br><span class="line"><span class="comment">//    &#123; value: 123,</span></span><br><span class="line"><span class="comment">//      writable: true,</span></span><br><span class="line"><span class="comment">//      enumerable: true,</span></span><br><span class="line"><span class="comment">//      configurable: true &#125;,</span></span><br><span class="line"><span class="comment">//   bar:</span></span><br><span class="line"><span class="comment">//    &#123; get: [Function: bar],</span></span><br><span class="line"><span class="comment">//      set: undefined,</span></span><br><span class="line"><span class="comment">//      enumerable: true,</span></span><br><span class="line"><span class="comment">//      configurable: true &#125; &#125;</span></span><br><span class="line"><span class="number">12345678910111213141516</span></span><br></pre></td></tr></table></figure>

<p><strong>Object.getOwnPropertyDescriptors方法返回一个对象，所有原对象的属性名都是该对象的属性名，对应的属性值就是该属性的描述对象。</strong></p>
<hr>
<h2 id="Null-传导运算符"><a href="#Null-传导运算符" class="headerlink" title="Null 传导运算符"></a>Null 传导运算符</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> firstName = message?.body?.user?.firstName || <span class="string">&#x27;default&#x27;</span>;<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>上面代码有三个?.运算符，只要其中一个返回null或undefined，就不再往下运算，而是返回undefined。</p>
<p>“Null 传导运算符”有四种用法。<br>obj?.prop // 读取对象属性<br>obj?.[expr] // 同上<br>func?.(…args) // 函数或对象方法的调用<br>new C?.(…args) // 构造函数的调用</p>
<p><strong>传导运算符之所以写成obj?.prop，而不是obj?prop，是为了方便编译器能够区分三元运算符?:（比如obj?prop:123）。</strong></p>
<p>例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果 a 是 null 或 undefined, 返回 undefined</span></span><br><span class="line"><span class="comment">// 否则返回 a.b.c().d</span></span><br><span class="line">a?.b.c().d</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果 a 是 null 或 undefined，下面的语句不产生任何效果</span></span><br><span class="line"><span class="comment">// 否则执行 a.b = 42</span></span><br><span class="line">a?.b = <span class="number">42</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果 a 是 null 或 undefined，下面的语句不产生任何效果</span></span><br><span class="line"><span class="keyword">delete</span> a?.b</span><br></pre></td></tr></table></figure>

<h1 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h1><p>ES6引入了一种新的原始数据类型Symbol，表示独一无二的值。它是JavaScript语言的第七种数据类型，前六种是：Undefined、Null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。</p>
<p><strong>1.Symbol值通过Symbol函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的Symbol类型。凡是属性名属于Symbol类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。</strong></p>
<p>如果Symbol的参数是一个对象，就会调用该对象的toString方法，将其转为字符串，然后生成一个Symbol值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sym = <span class="built_in">Symbol</span>(obj);</span><br><span class="line">sym  <span class="comment">//Symbol(abc);</span></span><br><span class="line"><span class="number">123456789</span></span><br></pre></td></tr></table></figure>

<p><strong>2.注意，Symbol函数的参数只是表示对当前Symbol的值的描述，因此相同参数的Symbol函数的返回值是不相等的</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//没有参数</span></span><br><span class="line"><span class="keyword">var</span> s1 = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">var</span> s2 = <span class="built_in">Symbol</span>();</span><br><span class="line">s1 === s2 <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//有参数</span></span><br><span class="line"><span class="keyword">var</span> s1 = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> s2 = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">s1 === s2 <span class="comment">//false</span></span><br><span class="line"><span class="number">12345678910</span></span><br></pre></td></tr></table></figure>

<p><strong>3.Symbol值不能与其他类型的值进行运算，会报错。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sym = <span class="built_in">Symbol</span>(<span class="string">&#x27;My symbol&#x27;</span>);</span><br><span class="line"><span class="string">&quot;your symbol is &quot;</span> + sym <span class="comment">// TypeError：不能将符号转换为字符串</span></span><br><span class="line"><span class="string">`your symbol is <span class="subst">$&#123;sym&#125;</span>`</span> <span class="comment">//TypeError：不能将符号转换为字符串</span></span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>

<p><strong>4.但，Symbol值可以显式转为字符串。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sym = <span class="built_in">Symbol</span>(<span class="string">&#x27;My symbol&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//String（）和toString（）方法都是将其它类型的变量转换为字符串的方法。</span></span><br><span class="line"><span class="comment">//但number.toString()无法转换null和undefined;</span></span><br><span class="line"><span class="comment">//String()方法较toString()方法应用范围上要更加广泛。</span></span><br><span class="line"><span class="built_in">String</span>(sym) <span class="comment">// &#x27;Symbol(My symbol)&#x27;</span></span><br><span class="line">sym.toString() <span class="comment">//Symbol(My symbol)</span></span><br><span class="line"><span class="number">12345678</span></span><br></pre></td></tr></table></figure>

<p><strong>5.Symbol值也可以转为布尔值，但不能转为数值。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sym = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="built_in">Boolean</span>(sym) <span class="comment">// true</span></span><br><span class="line">!sym <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(sym)&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>(sym) <span class="comment">//TypeError</span></span><br><span class="line">sym + <span class="number">2</span> <span class="comment">//TypeError</span></span><br><span class="line"><span class="number">1234567891011</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="作为属性名的Symbol"><a href="#作为属性名的Symbol" class="headerlink" title="作为属性名的Symbol"></a>作为属性名的Symbol</h2><p>每一个Symbol值都是不相等的，这意味着Symbol值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性。这对于一个对象由多个模块构成的情况非常有用，能防止某一个键被不小心改写或覆盖。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mySymbol = <span class="built_in">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一种写法</span></span><br><span class="line"><span class="keyword">var</span> a = &#123;&#125;;</span><br><span class="line">a[mySymbol] = <span class="string">&#x27;Hello!&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种写法</span></span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">  [mySymbol]: <span class="string">&#x27;Hello!&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三种写法</span></span><br><span class="line"><span class="keyword">var</span> a = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(a, mySymbol, &#123; <span class="attr">value</span>: <span class="string">&#x27;Hello!&#x27;</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上写法都得到同样结果</span></span><br><span class="line">a[mySymbol] <span class="comment">// &quot;Hello!&quot;</span></span><br><span class="line"><span class="number">123456789101112131415161718</span></span><br></pre></td></tr></table></figure>

<p>注意，Symbol值作为对象属性名时，不能用点运算符。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mySymbol = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">var</span> a = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">a.mySymbol = <span class="string">&#x27;Hello!&#x27;</span>;</span><br><span class="line">a[mySymbol] <span class="comment">// undefined</span></span><br><span class="line">a[<span class="string">&#x27;mySymbol&#x27;</span>] <span class="comment">// &quot;Hello!&quot;</span></span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，因为点运算符后面总是字符串，所以不会读取mySymbol作为标识名所指代的那个值，导致a的属性名实际上是一个字符串，而不是一个Symbol值。</p>
<p>同理，在对象的内部，使用Symbol值定义属性时，Symbol值必须放在方括号之中。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  [s]: <span class="function"><span class="keyword">function</span> (<span class="params">arg</span>) </span>&#123; ... &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj[s](<span class="number">123</span>);</span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，如果s不放在方括号中，该属性的键名就是字符串s，而不是s所代表的那个Symbol值。</p>
<p>采用增强的对象写法，上面代码的obj对象可以写得更简洁一些。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  [s](arg) &#123; ... &#125;</span><br><span class="line">&#125;;<span class="number">123</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="属性名的遍历"><a href="#属性名的遍历" class="headerlink" title="属性名的遍历"></a>属性名的遍历</h2><hr>
<h2 id="Symbol-for-Symbol-keyFor"><a href="#Symbol-for-Symbol-keyFor" class="headerlink" title="Symbol.for(),Symbol.keyFor()"></a>Symbol.for(),Symbol.keyFor()</h2><p><strong>1.Symbol.for方法：重新使用同一个Symbol值。</strong>它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的Symbol值。如果有，就返回这个Symbol值，否则就新建并返回一个以该字符串为名称的Symbol值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> s2 = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">s1 === s2 <span class="comment">//true</span></span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>

<p>s1和s2都是Symbol值，但是它们都是同样参数的symbol.for方法生成的。所以实际上是同一值。<br>Symbol.for()与Symbol()这两种写法，都会生成新的Symbol。它们的区别是，前者会被登记在全局环境中供搜索，后者不会。</p>
<p><strong>Symbol.for()不会每次调用就返回一个新的 Symbol 类型的值，而是会先检查给定的key是否已经存在，如果不存在才会新建一个值。</strong>比如，如果你调用Symbol.for(“cat”)30次，每次都会返回同一个 Symbol 值，但是调用Symbol(“cat”)30次，会返回30个不同的Symbol值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Symbol</span>.for(<span class="string">&#x27;bar&#x27;</span>) === Symobl.for(<span class="string">&#x27;bar&#x27;</span>) <span class="comment">//true</span></span><br><span class="line"><span class="built_in">Symbol</span>(<span class="string">&#x27;bar&#x27;</span>) === <span class="built_in">Symbol</span>(<span class="string">&#x27;bar&#x27;</span>) <span class="comment">//false</span></span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>

<p><strong>由于Symbol()写法没有登记机制，所以每次调用都会返回一个不同的值。</strong></p>
<p><strong>2.Symbol.keyFor方法返回一个已登记的 Symbol 类型值的key。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="built_in">Symbol</span>.keyFor(s1) <span class="comment">// &#x27;foo&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s2 = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="built_in">Symbol</span>.keyFor(s2) <span class="comment">//undefined</span></span><br><span class="line"><span class="comment">//变量s2属于未登记的Symbol值，所以返回undefined。123456</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="实例：模块的-Singleton-模式"><a href="#实例：模块的-Singleton-模式" class="headerlink" title="实例：模块的 Singleton 模式"></a>实例：模块的 Singleton 模式</h2><p><strong>Singleton模式指的是调用一个类，任何时候返回的都是同一个实例。</strong></p>
<hr>
<h2 id="内置的Symbol值"><a href="#内置的Symbol值" class="headerlink" title="内置的Symbol值"></a>内置的Symbol值</h2><p>ES6还提供了11个内置的Symbol值，指向语言内部使用的方法。</p>
<h3 id="Symbol-hasInstance"><a href="#Symbol-hasInstance" class="headerlink" title="Symbol.hasInstance"></a>Symbol.hasInstance</h3><p>Symbol.hasInstance属性，指向一个内部方法。当其他对象使用instanceof运算符，判断是否为该对象的实例时，会调用该方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//foo instanceof Foo在语言内部，实际调用的是Foo[Symbol.hasInstance](foo)。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span>&#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>.hasInstance](foo)&#123;</span><br><span class="line">     <span class="keyword">return</span> foo <span class="keyword">instanceof</span> <span class="built_in">Array</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] <span class="keyword">instanceof</span> <span class="keyword">new</span> MyClass() <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，MyClass是一个类，new MyClass()会返回一个实例。该实例的Symbol.hasInstance方法，会在进行instanceof运算时自动调用，判断左侧的运算子是否为Array的实例。</p>
<p>例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Even</span></span>&#123;</span><br><span class="line">  <span class="keyword">static</span> [<span class="built_in">Symbol</span>.hasInstance](obj)&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="built_in">Number</span>(obj) % <span class="number">2</span> === <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用了Even类的Symbol.hasInstance方法。</span></span><br><span class="line"><span class="comment">//在进行instanceof运算时自动调用。</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">instanceof</span> Even <span class="comment">//false</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">instanceof</span> Even <span class="comment">//true</span></span><br><span class="line"><span class="number">12345</span> <span class="keyword">instanceof</span> Even <span class="comment">//false</span></span><br><span class="line"><span class="number">123456789101112</span></span><br></pre></td></tr></table></figure>

<h3 id="Symbol-isConcatSpreadable"><a href="#Symbol-isConcatSpreadable" class="headerlink" title="Symbol.isConcatSpreadable"></a>Symbol.isConcatSpreadable</h3><p>Symbol.isConcatSpreadable属性等于一个布尔值，表示该对象使用Array.prototype.concat()时，是否可以展开。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>];</span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>].concat(arr1, <span class="string">&#x27;e&#x27;</span>) <span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;]</span></span><br><span class="line">arr1[<span class="built_in">Symbol</span>.isConcatSpreadable] <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>];</span><br><span class="line">arr2[<span class="built_in">Symbol</span>.isConcatSpreadable] = <span class="literal">false</span>;</span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>].concat(arr2, <span class="string">&#x27;e&#x27;</span>) <span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;, [&#x27;c&#x27;,&#x27;d&#x27;], &#x27;e&#x27;]</span></span><br><span class="line"><span class="number">12345678</span></span><br></pre></td></tr></table></figure>

<p>上面代码说明，<strong>数组的默认行为是可以展开</strong>。<strong>Symbol.isConcatSpreadable属性等于true或undefined，都有这个效果。</strong></p>
<p><strong>类似数组的对象也可以展开，但它的Symbol.isConcatSpreadable属性默认为false，必须手动打开。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">length</span>:<span class="number">2</span>, <span class="number">0</span>:<span class="string">&#x27;c, 1:&#x27;</span>d<span class="string">&#x27;&#125;;</span></span><br><span class="line"><span class="string">[&#x27;</span>a<span class="string">&#x27;,&#x27;</span>b<span class="string">&#x27;].concat(obj,&#x27;</span>e<span class="string">&#x27;) //[&#x27;</span>a<span class="string">&#x27;, &#x27;</span>b<span class="string">&#x27;, obj, &#x27;</span>e<span class="string">&#x27;]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//数组的对象展开</span></span><br><span class="line"><span class="string">obj[Symbol.isConcatSpreadable] = true;</span></span><br><span class="line"><span class="string">[&#x27;</span>a<span class="string">&#x27;,&#x27;</span>b<span class="string">&#x27;].concat(obj,&#x27;</span>e<span class="string">&#x27;) //[&#x27;</span>a<span class="string">&#x27;, &#x27;</span>b<span class="string">&#x27;, &#x27;</span>c<span class="string">&#x27;, &#x27;</span>d<span class="string">&#x27;, &#x27;</span>e<span class="string">&#x27;]</span></span><br><span class="line"><span class="string">1234567</span></span><br></pre></td></tr></table></figure>

<p><strong>对于一个类来说，Symbol.isConcatSpreadable属性必须写成实例的属性。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//子类A1继承了父类Array</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A1</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">args</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(args);</span><br><span class="line">    <span class="built_in">this</span>[<span class="built_in">Symbol</span>.isConcatSpreadable] = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A2</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">args</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(args);</span><br><span class="line">    <span class="built_in">this</span>[<span class="built_in">Symbol</span>.isConcatSpreadable] = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a1 = <span class="keyword">new</span> A1();</span><br><span class="line">a1[<span class="number">0</span>] = <span class="number">3</span>;</span><br><span class="line">a1[<span class="number">1</span>] = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">let</span> a2 = <span class="keyword">new</span> A2();</span><br><span class="line">a2[<span class="number">0</span>] = <span class="number">5</span>;</span><br><span class="line">a2[<span class="number">1</span>] = <span class="number">6</span>;</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>].concat(a1).concat(a2)</span><br><span class="line"><span class="comment">// [1, 2, 3, 4, [5, 6]]</span></span><br><span class="line"><span class="number">12345678910111213141516171819202122</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，类A1是可展开的，类A2是不可展开的，所以使用concat时有不一样的结果。</p>
<h3 id="Symbol-species"><a href="#Symbol-species" class="headerlink" title="Symbol.species"></a>Symbol.species</h3><p><strong>Symbol.species属性，指向当前对象的构造函数。创造实例时，默认会调用这个方法，即使用这个属性返回的函数当作构造函数，来创造新的实例对象。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//子类MyArray继承了父类Array</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyArray</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 覆盖父类 Array 的构造函数</span></span><br><span class="line">  <span class="keyword">static</span> get [<span class="built_in">Symbol</span>.species]() &#123; <span class="keyword">return</span> <span class="built_in">Array</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure>

<p>Symbol.species属性要采用get读取器。默认的Symbol.species属性等同于下面的写法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> get [<span class="built_in">Symbol</span>.species]() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>

<p>例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyArray</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> get [<span class="built_in">Symbol</span>.species]() &#123; <span class="keyword">return</span> <span class="built_in">Array</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> MyArray(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">var</span> mapped = a.map(<span class="function"><span class="params">x</span> =&gt;</span> x * x);</span><br><span class="line"></span><br><span class="line">mapped <span class="keyword">instanceof</span> MyArray <span class="comment">// false</span></span><br><span class="line">mapped <span class="keyword">instanceof</span> <span class="built_in">Array</span> <span class="comment">// true</span></span><br><span class="line"><span class="number">123456789</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，由于构造函数被替换成了Array。所以，mapped对象不是MyArray的实例，而是Array的实例。</p>
<h3 id="Symbol-match"><a href="#Symbol-match" class="headerlink" title="Symbol.match"></a>Symbol.match</h3><p><strong>Symbol.match属性，指向一个函数。当执行str.match(myObject)时，如果该属性存在，会调用它，返回该方法的返回值。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="built_in">String</span>.prototype.match(regexp) <span class="comment">// match()可在字符串内检索指定的值,返回指定的值，而不是字符串位置。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//上面等同于</span></span><br><span class="line">regexp[<span class="built_in">Symbol</span>.match](<span class="built_in">this</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyMatcher</span></span>&#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>.match](string)&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="string">&#x27;hello world&#x27;</span>.indexOfz(string);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">&#x27;e&#x27;</span>.macth(<span class="keyword">new</span> MyMatcher()) <span class="comment">//1</span></span><br><span class="line"><span class="number">123456789101112</span></span><br></pre></td></tr></table></figure>

<h3 id="Symbol-replace"><a href="#Symbol-replace" class="headerlink" title="Symbol.replace"></a>Symbol.replace</h3><p><strong>Symbol.replace属性，指向一个方法，当该对象被String.prototype.replace方法调用时，会返回该方法的返回值。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="built_in">String</span>.prototype.replace(searchValue,replaceValue)</span><br><span class="line"> <span class="comment">//等同于</span></span><br><span class="line"> searchValue[<span class="built_in">Symbol</span>.replace](<span class="built_in">this</span>,replaceValue)</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>

<p>例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> x = &#123;&#125;;</span><br><span class="line">x[<span class="built_in">Symbol</span>.replace] = <span class="function">(<span class="params">...s</span>) =&gt;</span> <span class="built_in">console</span>.log(s);</span><br><span class="line"><span class="string">&#x27;Hello&#x27;</span>.replace(x, <span class="string">&#x27;World&#x27;</span>) <span class="comment">// [&quot;Hello&quot;, &quot;World&quot;]</span></span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>

<p>ymbol.replace方法会收到两个参数，第一个参数是replace方法正在作用的对象，上面例子是Hello，第二个参数是替换后的值，上面例子是World。</p>
<h3 id="Symbol-search"><a href="#Symbol-search" class="headerlink" title="Symbol.search"></a>Symbol.search</h3><p><strong>Symbol.search属性，指向一个方法，当该对象被String.prototype.search方法调用时，会返回该方法的返回值。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>.prototype.search(regexp)</span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line">regexp[<span class="built_in">Symbol</span>.search](<span class="built_in">this</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySearch</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="title">constructor</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">     <span class="built_in">this</span>.value = value;</span><br><span class="line">   &#125;</span><br><span class="line">   [<span class="built_in">Symbol</span>.search](string)&#123;</span><br><span class="line">      <span class="keyword">return</span> string.indexOf(<span class="built_in">this</span>.value);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">&#x27;foobar&#x27;</span>.search(<span class="keyword">new</span> MySearch(<span class="string">&#x27;foo)) //0</span></span><br><span class="line"><span class="string">12345678910111213</span></span><br></pre></td></tr></table></figure>

<h3 id="Symbol-split"><a href="#Symbol-split" class="headerlink" title="Symbol.split"></a>Symbol.split</h3><p>Symbol.split属性，指向一个方法，当该对象被String.prototype.split方法调用时，会返回该方法的返回值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="built_in">String</span>.prototype.split(separator, limit)</span><br><span class="line"> <span class="comment">//等同于</span></span><br><span class="line"> separator[<span class="built_in">Symbol</span>.split](<span class="built_in">this</span>,limit)</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>

<p>例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySplitter</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.value = value;</span><br><span class="line">  &#125;</span><br><span class="line">  [<span class="built_in">Symbol</span>.split](string) &#123;</span><br><span class="line">    <span class="keyword">var</span> index = string.indexOf(<span class="built_in">this</span>.value);<span class="comment">//指定值在字符串的索引值</span></span><br><span class="line">    <span class="keyword">if</span> (index === -<span class="number">1</span>) &#123; <span class="comment">//如果查找不到，则返回整个字符串</span></span><br><span class="line">      <span class="keyword">return</span> string;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="comment">//否则</span></span><br><span class="line">      string.substr(<span class="number">0</span>, index), <span class="comment">//字符串中抽取下标0开始，字符串长度index的指定数目的字符。</span></span><br><span class="line">      string.substr(index + <span class="built_in">this</span>.value.length)</span><br><span class="line">    ];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;foobar&#x27;</span>.split(<span class="keyword">new</span> MySplitter(<span class="string">&#x27;foo&#x27;</span>))</span><br><span class="line"><span class="comment">// [&#x27;&#x27;, &#x27;bar&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;foobar&#x27;</span>.split(<span class="keyword">new</span> MySplitter(<span class="string">&#x27;bar&#x27;</span>))</span><br><span class="line"><span class="comment">// [&#x27;foo&#x27;, &#x27;&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;foobar&#x27;</span>.split(<span class="keyword">new</span> MySplitter(<span class="string">&#x27;baz&#x27;</span>))</span><br><span class="line"><span class="comment">// &#x27;foobar&#x27;123456789101112131415161718192021222324</span></span><br></pre></td></tr></table></figure>

<p>上面方法使用Symbol.split方法，重新定义了字符串对象的split方法的行为。</p>
<h3 id="Symbol-iterator"><a href="#Symbol-iterator" class="headerlink" title="Symbol.iterator"></a>Symbol.iterator</h3><p><strong>ymbol.iterator属性，指向该对象的默认遍历器方法。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myIterable = &#123;&#125;;</span><br><span class="line">myIterable[<span class="built_in">Symbol</span>.iterator] = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">[...myIterable] <span class="comment">// [1, 2, 3]12345678</span></span><br></pre></td></tr></table></figure>

<p>对象进行for…of循环时，会调用Symbol.iterator方法，返回该对象的默认遍历器，详细介绍参见《Iterator和for…of循环》一章。</p>
<h3 id="Symbol-toPrimitive"><a href="#Symbol-toPrimitive" class="headerlink" title="Symbol.toPrimitive"></a>Symbol.toPrimitive</h3><p><strong>Symbol.toPrimitive属性，指向一个方法。该对象被转为原始类型的值时，会调用这个方法，返回该对象对应的原始类型值。</strong></p>
<p>Symbol.toPrimitive被调用时，会接受一个字符串参数，表示当前运算的模式，一共有三种模式。</p>
<p>Number：该场合需要转成数值<br>String：该场合需要转成字符串<br>Default：该场合可以转成数值，也可以转成字符串</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>.toPrimitive](hint) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (hint) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;number&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;string&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;str&#x27;</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;default&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;default&#x27;</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="number">2</span> * obj <span class="comment">// 246</span></span><br><span class="line"><span class="number">3</span> + obj <span class="comment">// &#x27;3default&#x27;</span></span><br><span class="line">obj == <span class="string">&#x27;default&#x27;</span> <span class="comment">// true</span></span><br><span class="line"><span class="built_in">String</span>(obj) <span class="comment">// &#x27;str&#x27;</span></span><br><span class="line"><span class="number">1234567891011121314151617181920</span></span><br></pre></td></tr></table></figure>

<h3 id="Symbol-toStringTag"><a href="#Symbol-toStringTag" class="headerlink" title="Symbol.toStringTag"></a>Symbol.toStringTag</h3><p>ymbol.toStringTag属性，指向一个方法。在该对象上面调用Object.prototype.toString方法时，如果这个属性存在，它的返回值会出现在toString方法返回的字符串之中，表示对象的类型。也就是说，这个属性可以用来定制[object Object]或[object Array]中object后面的那个字符串。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例一</span></span><br><span class="line">(&#123;[<span class="built_in">Symbol</span>.toStringTag]: <span class="string">&#x27;Foo&#x27;</span>&#125;.toString())</span><br><span class="line"><span class="comment">// &quot;[object Foo]&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 例二</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Collection</span> </span>&#123;</span><br><span class="line">  get [<span class="built_in">Symbol</span>.toStringTag]() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;xxx&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> x = <span class="keyword">new</span> Collection();</span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(x) <span class="comment">// &quot;[object xxx]&quot;</span></span><br><span class="line"><span class="number">12345678910111213</span></span><br></pre></td></tr></table></figure>

<h3 id="Symbol-unscopables"><a href="#Symbol-unscopables" class="headerlink" title="Symbol.unscopables"></a>Symbol.unscopables</h3><p><strong>对象的Symbol.unscopables属性，指向一个对象。该对象指定了使用with关键字时，哪些属性会被with环境排除。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">rray.prototype[<span class="built_in">Symbol</span>.unscopables]</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   copyWithin: true,</span></span><br><span class="line"><span class="comment">//   entries: true,</span></span><br><span class="line"><span class="comment">//   fill: true,</span></span><br><span class="line"><span class="comment">//   find: true,</span></span><br><span class="line"><span class="comment">//   findIndex: true,</span></span><br><span class="line"><span class="comment">//   includes: true,</span></span><br><span class="line"><span class="comment">//   keys: true</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.keys(<span class="built_in">Array</span>.prototype[<span class="built_in">Symbol</span>.unscopables])</span><br><span class="line"><span class="comment">// [&#x27;copyWithin&#x27;, &#x27;entries&#x27;, &#x27;fill&#x27;, &#x27;find&#x27;, &#x27;findIndex&#x27;, &#x27;includes&#x27;, &#x27;keys&#x27;]12345678910111213</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="Set和Map数据结构"><a href="#Set和Map数据结构" class="headerlink" title="Set和Map数据结构"></a>Set和Map数据结构</h1><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p><strong>ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。</strong></p>
<p><strong>1.Set 本身是一个构造函数，用来生成 Set 数据结构。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"></span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>].forEach(<span class="function"><span class="params">x</span> =&gt;</span> s.add(x)); <span class="comment">//add方法向 Set 结构加入成员</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> s) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2 3 5 4  结果表明 Set 结构不会添加重复的值。12345678</span></span><br></pre></td></tr></table></figure>

<p><strong>2.Set 函数可以接受一个数组（或类似数组的对象）作为参数，用来初始化。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例一 Set函数接受数组作为参数</span></span><br><span class="line"><span class="keyword">var</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>]);</span><br><span class="line">[...set] <span class="comment">//[1,2,3,4]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 例二</span></span><br><span class="line"><span class="keyword">var</span> items = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>]);</span><br><span class="line">items.size <span class="comment">//5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 例三 接受类似数组的对象作为参数。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">divs</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [...document.querySelectorAll(<span class="string">&#x27;div&#x27;</span>)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>(divs());</span><br><span class="line">set.size <span class="comment">// 56</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//类似于</span></span><br><span class="line">div().forEach(<span class="function"><span class="params">div</span> =&gt;</span> set.add(div));</span><br><span class="line">set.size <span class="comment">// 56</span></span><br><span class="line"><span class="number">1234567891011121314151617181920</span></span><br></pre></td></tr></table></figure>

<p><strong>3.Set去除数组重复成员的方法。</strong></p>
<blockquote>
<p>[…new Set(array)]</p>
</blockquote>
<p><strong>4.Set内部判断,NaN等于自身,而精确相等运算符认为NaN不等于自身。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"><span class="keyword">let</span> a = <span class="literal">NaN</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="literal">NaN</span>;</span><br><span class="line">set.add(a);</span><br><span class="line">set.add(b);</span><br><span class="line">set <span class="comment">// Set &#123;NaN&#125;</span></span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure>

<p>上面代码向Set实例添加了两个NaN，但是只能加入一个。这表明，在Set内部，两个NaN是相等。</p>
<p><strong>另外，两个对象总是不相等的。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"></span><br><span class="line">set.add(&#123;&#125;);</span><br><span class="line">set.size <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">set.add(&#123;&#125;);</span><br><span class="line">set.size <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>上面代码表示，由于<strong>两个空对象不相等，所以它们被视为两个值。</strong></p>
<h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>map是ES提供的一种字典数据结构。<br>字典结构——用来存储不重复key的hash结构。不同于集合（set）的是，字典使用的是键值对的形式来存储数据<br>JavaScript对象（object：{}）只能用字符串来当key，这对使用带来了不便<br>ES6提供了map数据结构。其类似于对象，也是键值对的集合，但“key”的范围不仅限于字符串，而是各种类型的值都可以当做key。也就是说，object提供了“字符串-值”的对应结构，map则提供的是“值-值”的对应。是一种更加完善的hash结构<br>对象对map结构的支持演示</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data1=&#123;<span class="attr">a</span>:<span class="number">1</span>&#125;,</span><br><span class="line">      data2=&#123;<span class="attr">b</span>:<span class="number">2</span>&#125;,</span><br><span class="line">      obj=&#123;&#125;;</span><br><span class="line">      <span class="comment">//为obj对象添加属性（将data1和data2作为属性名）</span></span><br><span class="line">      obj[data1]=<span class="number">1</span>;</span><br><span class="line">      obj[data2]=<span class="number">2</span>;</span><br><span class="line">      <span class="built_in">console</span>.log(obj);</span><br></pre></td></tr></table></figure>

<p>可以看到结果并非我们需要的<br>创建一个map</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map=<span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">     [<span class="string">&#x27;a&#x27;</span>,<span class="number">1</span>],</span><br><span class="line">     [<span class="string">&#x27;b&#x27;</span>,<span class="number">2</span>]</span><br><span class="line">]);</span><br><span class="line"><span class="built_in">console</span>.log(map);</span><br></pre></td></tr></table></figure>
<p>上面的[‘a’,1]代表，将a作为key，1作为value声明<br>[‘a’,1]中能写入第三个元素呢？ES6不会给予响应<br>map类的属性——size     用于获取map的长度</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(map.size);</span><br></pre></td></tr></table></figure>
<p>map类的方法——set   Map.set(key,value)  设置键名key对应的键值为value，然后返回整个map结构。如果key已经有值，则键值会被更新，否则生成新的键</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(map.set([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],<span class="string">&#x27;3元素的数组&#x27;</span>));</span><br><span class="line"><span class="comment">//也可以链式添加</span></span><br><span class="line">map.set(<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;张三&#x27;</span>).set(<span class="string">&#x27;age&#x27;</span>,<span class="number">28</span>);</span><br><span class="line"><span class="built_in">console</span>.log(map);</span><br></pre></td></tr></table></figure>
<p>map类的方法——get  Map.get(key)    读取key对应的键值，如果获取不到则返回undefined</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(map.get(<span class="string">&#x27;name&#x27;</span>));</span><br></pre></td></tr></table></figure>
<p>获取数组对应的键值——后续补充<br>map类的方法——delete   Map.delete(key)     删除某个键，如果删除成功返回true，否则返回false</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(map.delete(<span class="string">&#x27;name&#x27;</span>));</span><br></pre></td></tr></table></figure>
<p>map类的方法——has      Map.has(key)        判断某个键是否存在于map中，返回布尔值js</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(map.has(<span class="string">&#x27;age&#x27;</span>));</span><br></pre></td></tr></table></figure>
<p>map类的方法——clear    Map.clear()         清除所有数据，没有返回值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map.clear();</span><br></pre></td></tr></table></figure>
<p>map类的方法——keys     Map.keys()          返回键名的遍历器</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(map.keys());</span><br></pre></td></tr></table></figure>
<p>map类的方法——values   Map.values()        返回键值的遍历器</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(map.values());</span><br></pre></td></tr></table></figure>
<p>map类的方法——entries  Map.entries()       返回键值对的遍历器</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(map.entries());</span><br></pre></td></tr></table></figure>
<p>map类的方法——forEach  map.forEach(function(){})   使用回调遍历每一个成员</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">map.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">value, key, map</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`这是key：<span class="subst">$&#123;key&#125;</span>,这是value：<span class="subst">$&#123;value&#125;</span>,这是map本身：<span class="subst">$&#123;map&#125;</span>`</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Map在使用过程中需要注意的地方<br>1.在js中NaN是不等于自身的一种数据类型，但是在map中，多次set以NaN为key的数据的时候，会产生覆盖的行为。说明map会将NaN视为同一个键</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">map.set(<span class="literal">NaN</span>,<span class="number">1</span>).set(<span class="literal">NaN</span>,<span class="number">10</span>);</span><br><span class="line"><span class="built_in">console</span>.log(map);</span><br></pre></td></tr></table></figure>
<p>2.如果map数据中以空对象作为key（{}）的话，会发现，出现了两个key，这是因为每一个{}都是全新的引用,其不同的是内存地址。而反观上面的NaN，其地址只有一个，所以才会出现覆盖的情况</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">map.set(&#123;&#125;,<span class="number">1</span>).set(&#123;&#125;,<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(map);</span><br></pre></td></tr></table></figure>

<h1 id="Reflect反射"><a href="#Reflect反射" class="headerlink" title="Reflect反射"></a>Reflect反射</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Reflect 是 ES6 为了操作对象引入的 API 。</p>
<p>Reflect 可以用于获取目标对象的行为，它与 Object 类似，它的方法与 Proxy 是对应的。</p>
<p><strong>基本用法：</strong></p>
<p>1、Reflect.get(target, name, receiver) 查找并返回 target 对象的 name 属性。</p>
<p><a href="javascript:void(0);"><img src="/2021/05/06/ES6/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">let exam &#x3D; &#123;</span><br><span class="line">    name: &quot;Tom&quot;,</span><br><span class="line">    age: 24,</span><br><span class="line">    get info()&#123;</span><br><span class="line">        return this.name + this.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Reflect.get(exam, &#39;name&#39;); &#x2F;&#x2F; &quot;Tom&quot;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; 当 target对象中存在属性的getter方法， getter方法的this会绑定 receiver</span><br><span class="line">let receiver &#x3D; &#123;</span><br><span class="line">    name: &quot;Jerry&quot;,</span><br><span class="line">    age: 20</span><br><span class="line">&#125;</span><br><span class="line">Reflect.get(exam, &#39;info&#39;, receiver); &#x2F;&#x2F; Jerry20</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="/2021/05/06/ES6/copycode.gif" alt="复制代码"></a></p>
<p>2、Reflect.set(target, name, value, receiver) 返回boolean类型</p>
<p><a href="javascript:void(0);"><img src="/2021/05/06/ES6/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let exam &#x3D; &#123;</span><br><span class="line">    name: &quot;Tom&quot;,</span><br><span class="line">    age: 24,</span><br><span class="line">    set info(value)&#123;</span><br><span class="line">        return this.age &#x3D; value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">exam.age; &#x2F;&#x2F; 24</span><br><span class="line">Reflect.set(exam, &#39;age&#39;, 25); &#x2F;&#x2F; true</span><br><span class="line">console.log(exam.age); &#x2F;&#x2F; 25</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="/2021/05/06/ES6/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let receiver &#x3D; &#123;&#x2F;&#x2F;当 target对象中存在属性setter方法时，setter方法中的this会绑定receiver</span><br><span class="line">    age: 18</span><br><span class="line">&#125;</span><br><span class="line">Reflect.set(exam, &#39;info&#39;, 1, receiver); &#x2F;&#x2F; true</span><br><span class="line">receiver.age; &#x2F;&#x2F; 1   </span><br></pre></td></tr></table></figure>

<p>3、Reflect.has(obj, name) 是 name in obj 指令的函数化，用于查找 name 属性在 obj 对象中是否存在。</p>
<p>……</p>
<h2 id="组合使用（Reflect与Proxy）"><a href="#组合使用（Reflect与Proxy）" class="headerlink" title="组合使用（Reflect与Proxy）"></a>组合使用（Reflect与Proxy）</h2><p>Reflect 对象的方法与 Proxy 对象的方法是一一对应的。所以 Proxy 对象的方法可以通过调用 Reflect 对象的方法获取默认行为，然后进行额外操作。</p>
<p><a href="javascript:void(0);"><img src="/2021/05/06/ES6/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">let exam &#x3D; &#123;</span><br><span class="line">    name: &quot;Tom&quot;,</span><br><span class="line">    age: 24</span><br><span class="line">&#125;</span><br><span class="line">let handler &#x3D; &#123;</span><br><span class="line">    get: function(target, key)&#123;</span><br><span class="line">        return Reflect.get(target,key);</span><br><span class="line">    &#125;,</span><br><span class="line">    set: function(target, key, value)&#123;</span><br><span class="line">        Reflect.set(target, key, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let proxy &#x3D; new Proxy(exam, handler)</span><br><span class="line">proxy.name &#x3D; &quot;Jerry&quot; </span><br><span class="line">proxy.name &#x2F;&#x2F; &quot;Jerry&quot;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="/2021/05/06/ES6/copycode.gif" alt="复制代码"></a></p>
<p>比对下：上面的get方法等同于下面的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">get(target, propKey, receiver) &#123;</span><br><span class="line">       return target[propKey]; &#x2F;&#x2F;这边用Reflect.get(target,key)替换，结果一样。&#125;</span><br></pre></td></tr></table></figure>

<p><strong>观察者模式</strong> Observer</p>
<p>当一个对象被修改时,则会自动通知它的依赖对象。</p>
<p><a href="javascript:void(0);"><img src="/2021/05/06/ES6/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 定义 Set 集合</span><br><span class="line">const queuedObservers &#x3D; new Set();</span><br><span class="line">&#x2F;&#x2F; 把观察者函数都放入 Set 集合中</span><br><span class="line">const observe &#x3D; fn &#x3D;&gt; queuedObservers.add(fn);</span><br><span class="line">&#x2F;&#x2F; observable 返回原始对象的代理，拦截赋值操作</span><br><span class="line">const observable &#x3D; obj &#x3D;&gt; new Proxy(obj, &#123;set&#125;);</span><br><span class="line">function set(target, key, value, receiver) &#123;</span><br><span class="line">  &#x2F;&#x2F; 获取对象的赋值操作</span><br><span class="line">  const result &#x3D; Reflect.set(target, key, value, receiver);</span><br><span class="line">  &#x2F;&#x2F; 执行所有观察者</span><br><span class="line">  queuedObservers.forEach(observer &#x3D;&gt; observer());</span><br><span class="line">  &#x2F;&#x2F; 执行赋值操作</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="/2021/05/06/ES6/copycode.gif" alt="复制代码"></a></p>
<p><a href="javascript:void(0);"><img src="/2021/05/06/ES6/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const person &#x3D; observable(&#123;</span><br><span class="line">  name: &#39;张三&#39;,</span><br><span class="line">  age: 20</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">function print() &#123;</span><br><span class="line">  console.log(&#96;person的姓名更改为$&#123;person.name&#125;&#96;); &#x2F;&#x2F;&#96;$&#123;&#125;&#96;是es6中新增的字符串方法,用来替换字符串用的，在字符串中引入变量。</span><br><span class="line">&#125; </span><br><span class="line">observe(print);&#x2F;&#x2F;当person的属性变动时，自动通知print去打印信息。（Observer模式） </span><br><span class="line">person.name &#x3D; &#39;李四&#39;; &#x2F;&#x2F; person的姓名更改为李四</span><br></pre></td></tr></table></figure>

<h1 id="proxy代理"><a href="#proxy代理" class="headerlink" title="proxy代理"></a>proxy代理</h1><h2 id="一、proxy概述"><a href="#一、proxy概述" class="headerlink" title="一、proxy概述"></a>一、proxy概述</h2><p><strong>Proxy的兼容性</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/1480597-0dc9afceebb025e1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>image.png</p>
<blockquote>
<p><code>proxy</code>在目标对象的外层搭建了一层拦截，外界对目标对象的某些操作，必须通过这层拦截</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>new Proxy()</code>表示生成一个<code>Proxy</code>实例，<code>target</code>参数表示所要拦截的目标对象，<code>handler</code>参数也是一个对象，用来定制拦截行为</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> target = &#123;</span><br><span class="line">   name: <span class="string">&#x27;poetries&#x27;</span></span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="keyword">var</span> logHandler = &#123;</span><br><span class="line">   get: <span class="function"><span class="keyword">function</span>(<span class="params">target, key</span>) </span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;key&#125;</span> 被读取`</span>);</span><br><span class="line">     <span class="keyword">return</span> target[key];</span><br><span class="line">   &#125;,</span><br><span class="line">   set: <span class="function"><span class="keyword">function</span>(<span class="params">target, key, value</span>) </span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;key&#125;</span> 被设置为 <span class="subst">$&#123;value&#125;</span>`</span>);</span><br><span class="line">     target[key] = value;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">var</span> targetWithLog = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, logHandler);</span><br><span class="line"> </span><br><span class="line"> targetWithLog.name; <span class="comment">// 控制台输出：name 被读取</span></span><br><span class="line"> targetWithLog.name = <span class="string">&#x27;others&#x27;</span>; <span class="comment">// 控制台输出：name 被设置为 others</span></span><br><span class="line"> </span><br><span class="line"> <span class="built_in">console</span>.log(target.name); <span class="comment">// 控制台输出: others</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>targetWithLog</code> 读取属性的值时，实际上执行的是 <code>logHandler.get</code> ：在控制台输出信息，并且读取被代理对象 <code>target</code> 的属性。</li>
<li>在 <code>targetWithLog</code> 设置属性值时，实际上执行的是 <code>logHandler.set</code> ：在控制台输出信息，并且设置被代理对象 <code>target</code> 的属性的值</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由于拦截函数总是返回35，所以访问任何属性都得到35</span></span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  get: <span class="function"><span class="keyword">function</span>(<span class="params">target, property</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">35</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">proxy.time <span class="comment">// 35</span></span><br><span class="line">proxy.name <span class="comment">// 35</span></span><br><span class="line">proxy.title <span class="comment">// 35</span></span><br></pre></td></tr></table></figure>

<p><strong>Proxy 实例也可以作为其他对象的原型对象</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  get: <span class="function"><span class="keyword">function</span>(<span class="params">target, property</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">35</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="built_in">Object</span>.create(proxy);</span><br><span class="line">obj.time <span class="comment">// 35</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>proxy</code>对象是<code>obj</code>对象的原型，<code>obj</code>对象本身并没有<code>time</code>属性，所以根据原型链，会在<code>proxy</code>对象上读取该属性，导致被拦截</p>
</blockquote>
<p><strong>Proxy的作用</strong></p>
<blockquote>
<p>对于代理模式 <code>Proxy</code> 的作用主要体现在三个方面</p>
</blockquote>
<ul>
<li>拦截和监视外部对对象的访问</li>
<li>降低函数或类的复杂度</li>
<li>在复杂操作前对操作进行校验或对所需资源进行管理</li>
</ul>
<h2 id="二、Proxy所能代理的范围–handler"><a href="#二、Proxy所能代理的范围–handler" class="headerlink" title="二、Proxy所能代理的范围–handler"></a>二、Proxy所能代理的范围–handler</h2><blockquote>
<p>实际上 <code>handler</code> 本身就是<code>ES6</code>所新设计的一个对象.它的作用就是用来 自定义代理对象的各种可代理操作 。它本身一共有<code>13</code>中方法,每种方法都可以代理一种操作.其<code>13</code>种方法如下</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在读取代理对象的原型时触发该操作，比如在执行 Object.getPrototypeOf(proxy) 时。</span></span><br><span class="line">handler.getPrototypeOf()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在设置代理对象的原型时触发该操作，比如在执行 Object.setPrototypeOf(proxy, null) 时。</span></span><br><span class="line">handler.setPrototypeOf()</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 在判断一个代理对象是否是可扩展时触发该操作，比如在执行 Object.isExtensible(proxy) 时。</span></span><br><span class="line">handler.isExtensible()</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 在让一个代理对象不可扩展时触发该操作，比如在执行 Object.preventExtensions(proxy) 时。</span></span><br><span class="line">handler.preventExtensions()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在获取代理对象某个属性的属性描述时触发该操作，比如在执行 Object.getOwnPropertyDescriptor(proxy, &quot;foo&quot;) 时。</span></span><br><span class="line">handler.getOwnPropertyDescriptor()</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 在定义代理对象某个属性时的属性描述时触发该操作，比如在执行 Object.defineProperty(proxy, &quot;foo&quot;, &#123;&#125;) 时。</span></span><br><span class="line">andler.defineProperty()</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 在判断代理对象是否拥有某个属性时触发该操作，比如在执行 &quot;foo&quot; in proxy 时。</span></span><br><span class="line">handler.has()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在读取代理对象的某个属性时触发该操作，比如在执行 proxy.foo 时。</span></span><br><span class="line">handler.get()</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 在给代理对象的某个属性赋值时触发该操作，比如在执行 proxy.foo = 1 时。</span></span><br><span class="line">handler.set()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在删除代理对象的某个属性时触发该操作，比如在执行 delete proxy.foo 时。</span></span><br><span class="line">handler.deleteProperty()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在获取代理对象的所有属性键时触发该操作，比如在执行 Object.getOwnPropertyNames(proxy) 时。</span></span><br><span class="line">handler.ownKeys()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在调用一个目标对象为函数的代理对象时触发该操作，比如在执行 proxy() 时。</span></span><br><span class="line">handler.apply()</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 在给一个目标对象为构造函数的代理对象构造实例时触发该操作，比如在执行new proxy() 时。</span></span><br><span class="line">handler.construct()</span><br></pre></td></tr></table></figure>

<h2 id="三、Proxy场景"><a href="#三、Proxy场景" class="headerlink" title="三、Proxy场景"></a>三、Proxy场景</h2><h3 id="3-1-实现私有变量"><a href="#3-1-实现私有变量" class="headerlink" title="3.1 实现私有变量"></a>3.1 实现私有变量</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> target = &#123;</span><br><span class="line">   name: <span class="string">&#x27;poetries&#x27;</span>,</span><br><span class="line">   _age: <span class="number">22</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> logHandler = &#123;</span><br><span class="line">  get: <span class="function"><span class="keyword">function</span>(<span class="params">target,key</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(key.startsWith(<span class="string">&#x27;_&#x27;</span>))&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;私有变量age不能被访问&#x27;</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target[key];</span><br><span class="line">  &#125;,</span><br><span class="line">  set: <span class="function"><span class="keyword">function</span>(<span class="params">target, key, value</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(key.startsWith(<span class="string">&#x27;_&#x27;</span>))&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;私有变量age不能被修改&#x27;</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">     target[key] = value;</span><br><span class="line">   &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">var</span> targetWithLog = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, logHandler);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 私有变量age不能被访问</span></span><br><span class="line">targetWithLog.name; </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 私有变量age不能被修改</span></span><br><span class="line">targetWithLog.name = <span class="string">&#x27;others&#x27;</span>; </span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> api = &#123;  </span><br><span class="line">    _apiKey: <span class="string">&#x27;123abc456def&#x27;</span>,</span><br><span class="line">    <span class="comment">/* mock methods that use this._apiKey */</span></span><br><span class="line">    getUsers: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;, </span><br><span class="line">    getUser: <span class="function"><span class="keyword">function</span>(<span class="params">userId</span>)</span>&#123;&#125;, </span><br><span class="line">    setUser: <span class="function"><span class="keyword">function</span>(<span class="params">userId, config</span>)</span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// logs &#x27;123abc456def&#x27;;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;An apiKey we want to keep private&quot;</span>, api._apiKey);</span><br><span class="line"></span><br><span class="line"><span class="comment">// get and mutate _apiKeys as desired</span></span><br><span class="line"><span class="keyword">var</span> apiKey = api._apiKey;  </span><br><span class="line">api._apiKey = <span class="string">&#x27;987654321&#x27;</span>;</span><br></pre></td></tr></table></figure>



<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> api = &#123;  </span><br><span class="line">    _apiKey: <span class="string">&#x27;123abc456def&#x27;</span>,</span><br><span class="line">    getUsers: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; &#125;, </span><br><span class="line">    getUser: <span class="function"><span class="keyword">function</span>(<span class="params">userId</span>)</span>&#123; &#125;, </span><br><span class="line">    setUser: <span class="function"><span class="keyword">function</span>(<span class="params">userId, config</span>)</span>&#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> RESTRICTED = [<span class="string">&#x27;_apiKey&#x27;</span>];</span><br><span class="line">api = <span class="keyword">new</span> <span class="built_in">Proxy</span>(api, &#123;  </span><br><span class="line">    <span class="function"><span class="title">get</span>(<span class="params">target, key, proxy</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(RESTRICTED.indexOf(key) &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">`<span class="subst">$&#123;key&#125;</span> is restricted. Please see api documentation for further info.`</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, key, proxy);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">set</span>(<span class="params">target, key, value, proxy</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(RESTRICTED.indexOf(key) &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">`<span class="subst">$&#123;key&#125;</span> is restricted. Please see api documentation for further info.`</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, key, value, proxy);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下操作都会抛出错误</span></span><br><span class="line"><span class="built_in">console</span>.log(api._apiKey);</span><br><span class="line">api._apiKey = <span class="string">&#x27;987654321&#x27;</span>;  </span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用 <code>has</code> 拦截 <code>in</code> 操作</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> api = &#123;  </span><br><span class="line">    _apiKey: <span class="string">&#x27;123abc456def&#x27;</span>,</span><br><span class="line">    getUsers: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; &#125;, </span><br><span class="line">    getUser: <span class="function"><span class="keyword">function</span>(<span class="params">userId</span>)</span>&#123; &#125;, </span><br><span class="line">    setUser: <span class="function"><span class="keyword">function</span>(<span class="params">userId, config</span>)</span>&#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> RESTRICTED = [<span class="string">&#x27;_apiKey&#x27;</span>];</span><br><span class="line">api = <span class="keyword">new</span> <span class="built_in">Proxy</span>(api, &#123;  </span><br><span class="line">    <span class="function"><span class="title">has</span>(<span class="params">target, key</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (RESTRICTED.indexOf(key) &gt; -<span class="number">1</span>) ?</span><br><span class="line">            <span class="literal">false</span> :</span><br><span class="line">            <span class="built_in">Reflect</span>.has(target, key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// these log false, and `for in` iterators will ignore _apiKey</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;_apiKey&quot;</span> <span class="keyword">in</span> api);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> api) &#123;  </span><br><span class="line">    <span class="keyword">if</span> (api.hasOwnProperty(key) &amp;&amp; key === <span class="string">&quot;_apiKey&quot;</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;This will never be logged because the proxy obscures _apiKey...&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-抽离校验模块"><a href="#3-2-抽离校验模块" class="headerlink" title="3.2 抽离校验模块"></a>3.2 抽离校验模块</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numericDataStore = &#123;  </span><br><span class="line">    count: <span class="number">0</span>,</span><br><span class="line">    amount: <span class="number">1234</span>,</span><br><span class="line">    total: <span class="number">14</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">numericDataStore = <span class="keyword">new</span> <span class="built_in">Proxy</span>(numericDataStore, &#123;  </span><br><span class="line">    <span class="function"><span class="title">set</span>(<span class="params">target, key, value, proxy</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> value !== <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">&quot;Properties in numericDataStore can only be numbers&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target, key, value, proxy);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抛出错误，因为 &quot;foo&quot; 不是数值</span></span><br><span class="line">numericDataStore.count = <span class="string">&quot;foo&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 赋值成功</span></span><br><span class="line">numericDataStore.count = <span class="number">333</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createValidator</span>(<span class="params">target, validator</span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</span><br><span class="line">        _validator: validator,</span><br><span class="line">        <span class="function"><span class="title">set</span>(<span class="params">target, key, value, proxy</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (target.hasOwnProperty(key)) &#123;</span><br><span class="line">                <span class="keyword">let</span> validator = <span class="built_in">this</span>._validator[key];</span><br><span class="line">                <span class="keyword">if</span> (!!validator(value)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target, key, value, proxy);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">`Cannot set <span class="subst">$&#123;key&#125;</span> to <span class="subst">$&#123;value&#125;</span>. Invalid.`</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">`<span class="subst">$&#123;key&#125;</span> is not a valid property`</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> personValidators = &#123;  </span><br><span class="line">    <span class="function"><span class="title">name</span>(<span class="params">val</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">typeof</span> val === <span class="string">&#x27;string&#x27;</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">age</span>(<span class="params">val</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">typeof</span> age === <span class="string">&#x27;number&#x27;</span> &amp;&amp; val &gt; <span class="number">18</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name, age</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="keyword">return</span> createValidator(<span class="built_in">this</span>, personValidators);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bill = <span class="keyword">new</span> Person(<span class="string">&#x27;Bill&#x27;</span>, <span class="number">25</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下操作都会报错</span></span><br><span class="line">bill.name = <span class="number">0</span>;  </span><br><span class="line">bill.age = <span class="string">&#x27;Bill&#x27;</span>;  </span><br><span class="line">bill.age = <span class="number">15</span>;  </span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;  </span><br><span class="line">    pickyMethodOne: <span class="function"><span class="keyword">function</span>(<span class="params">obj, str, num</span>) </span>&#123; <span class="comment">/* ... */</span> &#125;,</span><br><span class="line">    pickyMethodTwo: <span class="function"><span class="keyword">function</span>(<span class="params">num, obj</span>) </span>&#123; <span class="comment">/*... */</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> argTypes = &#123;  </span><br><span class="line">    pickyMethodOne: [<span class="string">&quot;object&quot;</span>, <span class="string">&quot;string&quot;</span>, <span class="string">&quot;number&quot;</span>],</span><br><span class="line">    pickyMethodTwo: [<span class="string">&quot;number&quot;</span>, <span class="string">&quot;object&quot;</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, &#123;  </span><br><span class="line">    get: <span class="function"><span class="keyword">function</span>(<span class="params">target, key, proxy</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> value = target[key];</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> checkArgs = argChecker(key, args, argTypes[key]);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Reflect</span>.apply(value, target, args);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">argChecker</span>(<span class="params">name, args, checkers</span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> idx = <span class="number">0</span>; idx &lt; args.length; idx++) &#123;</span><br><span class="line">        <span class="keyword">var</span> arg = args[idx];</span><br><span class="line">        <span class="keyword">var</span> type = checkers[idx];</span><br><span class="line">        <span class="keyword">if</span> (!arg || <span class="keyword">typeof</span> arg !== type) &#123;</span><br><span class="line">            <span class="built_in">console</span>.warn(<span class="string">`You are incorrectly implementing the signature of <span class="subst">$&#123;name&#125;</span>. Check param <span class="subst">$&#123;idx + <span class="number">1</span>&#125;</span>`</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.pickyMethodOne();  </span><br><span class="line"><span class="comment">// &gt; You are incorrectly implementing the signature of pickyMethodOne. Check param 1</span></span><br><span class="line"><span class="comment">// &gt; You are incorrectly implementing the signature of pickyMethodOne. Check param 2</span></span><br><span class="line"><span class="comment">// &gt; You are incorrectly implementing the signature of pickyMethodOne. Check param 3</span></span><br><span class="line"></span><br><span class="line">obj.pickyMethodTwo(<span class="string">&quot;wopdopadoo&quot;</span>, &#123;&#125;);  </span><br><span class="line"><span class="comment">// &gt; You are incorrectly implementing the signature of pickyMethodTwo. Check param 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// No warnings logged</span></span><br><span class="line">obj.pickyMethodOne(&#123;&#125;, <span class="string">&quot;a little string&quot;</span>, <span class="number">123</span>);  </span><br><span class="line">obj.pickyMethodOne(<span class="number">123</span>, &#123;&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="3-3-访问日志"><a href="#3-3-访问日志" class="headerlink" title="3.3 访问日志"></a>3.3 访问日志</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> api = &#123;  </span><br><span class="line">    _apiKey: <span class="string">&#x27;123abc456def&#x27;</span>,</span><br><span class="line">    getUsers: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">/* ... */</span> &#125;,</span><br><span class="line">    getUser: <span class="function"><span class="keyword">function</span>(<span class="params">userId</span>) </span>&#123; <span class="comment">/* ... */</span> &#125;,</span><br><span class="line">    setUser: <span class="function"><span class="keyword">function</span>(<span class="params">userId, config</span>) </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logMethodAsync</span>(<span class="params">timestamp, method</span>) </span>&#123;  </span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;timestamp&#125;</span> - Logging <span class="subst">$&#123;method&#125;</span> request asynchronously.`</span>);</span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">api = <span class="keyword">new</span> <span class="built_in">Proxy</span>(api, &#123;  </span><br><span class="line">    get: <span class="function"><span class="keyword">function</span>(<span class="params">target, key, proxy</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> value = target[key];</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...<span class="built_in">arguments</span></span>) </span>&#123;</span><br><span class="line">            logMethodAsync(<span class="keyword">new</span> <span class="built_in">Date</span>(), key);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Reflect</span>.apply(value, target, <span class="built_in">arguments</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">api.getUsers();</span><br></pre></td></tr></table></figure>

<h3 id="3-4-预警和拦截"><a href="#3-4-预警和拦截" class="headerlink" title="3.4 预警和拦截"></a>3.4 预警和拦截</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dataStore = &#123;  </span><br><span class="line">    noDelete: <span class="number">1235</span>,</span><br><span class="line">    oldMethod: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="comment">/*...*/</span> &#125;,</span><br><span class="line">    doNotChange: <span class="string">&quot;tried and true&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> NODELETE = [<span class="string">&#x27;noDelete&#x27;</span>];  </span><br><span class="line"><span class="keyword">const</span> NOCHANGE = [<span class="string">&#x27;doNotChange&#x27;</span>];</span><br><span class="line"><span class="keyword">const</span> DEPRECATED = [<span class="string">&#x27;oldMethod&#x27;</span>];  </span><br><span class="line"></span><br><span class="line">dataStore = <span class="keyword">new</span> <span class="built_in">Proxy</span>(dataStore, &#123;  </span><br><span class="line">    <span class="function"><span class="title">set</span>(<span class="params">target, key, value, proxy</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (NOCHANGE.includes(key)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">`Error! <span class="subst">$&#123;key&#125;</span> is immutable.`</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target, key, value, proxy);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">deleteProperty</span>(<span class="params">target, key</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (NODELETE.includes(key)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">`Error! <span class="subst">$&#123;key&#125;</span> cannot be deleted.`</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.deleteProperty(target, key);</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">get</span>(<span class="params">target, key, proxy</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEPRECATED.includes(key)) &#123;</span><br><span class="line">            <span class="built_in">console</span>.warn(<span class="string">`Warning! <span class="subst">$&#123;key&#125;</span> is deprecated.`</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> val = target[key];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">typeof</span> val === <span class="string">&#x27;function&#x27;</span> ?</span><br><span class="line">            <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">                <span class="built_in">Reflect</span>.apply(target[key], target, args);</span><br><span class="line">            &#125; :</span><br><span class="line">            val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// these will throw errors or log warnings, respectively</span></span><br><span class="line">dataStore.doNotChange = <span class="string">&quot;foo&quot;</span>;  </span><br><span class="line"><span class="keyword">delete</span> dataStore.noDelete;  </span><br><span class="line">dataStore.oldMethod();</span><br></pre></td></tr></table></figure>

<h3 id="3-5-过滤操作"><a href="#3-5-过滤操作" class="headerlink" title="3.5 过滤操作"></a>3.5 过滤操作</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;  </span><br><span class="line">    getGiantFile: <span class="function"><span class="keyword">function</span>(<span class="params">fileId</span>) </span>&#123;<span class="comment">/*...*/</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, &#123;  </span><br><span class="line">    <span class="function"><span class="title">get</span>(<span class="params">target, key, proxy</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">const</span> id = args[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">let</span> isEnroute = checkEnroute(id);</span><br><span class="line">            <span class="keyword">let</span> isDownloading = checkStatus(id);      </span><br><span class="line">            <span class="keyword">let</span> cached = getCached(id);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (isEnroute || isDownloading) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cached) &#123;</span><br><span class="line">                <span class="keyword">return</span> cached;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Reflect</span>.apply(target[key], target, args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="3-6-中断代理"><a href="#3-6-中断代理" class="headerlink" title="3.6 中断代理"></a>3.6 中断代理</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sensitiveData = &#123; <span class="attr">username</span>: <span class="string">&#x27;devbryce&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> &#123;sensitiveData, revokeAccess&#125; = <span class="built_in">Proxy</span>.revocable(sensitiveData, handler);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleSuspectedHack</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line">    revokeAccess();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// logs &#x27;devbryce&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(sensitiveData.username);</span><br><span class="line">handleSuspectedHack();</span><br><span class="line"><span class="comment">// TypeError: Revoked</span></span><br><span class="line"><span class="built_in">console</span>.log(sensitiveData.username);</span><br></pre></td></tr></table></figure>

<h1 id="class"><a href="#class" class="headerlink" title="class"></a>class</h1><p>class是一个语法糖，其底层还是通过 <code>构造函数</code> 去创建的。所以它的绝大部分功能，ES5 都可以做到。新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> xiaoming = <span class="keyword">new</span> Person(<span class="string">&#x27;小明&#x27;</span>, <span class="number">18</span>);</span><br><span class="line"><span class="built_in">console</span>.log(xiaoming);</span><br></pre></td></tr></table></figure>

<p>用<code>ES6</code>的<code>class</code>实现</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name, age</span>)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.name = name;</span><br><span class="line">      <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="title">sayName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> xiaoming = <span class="keyword">new</span> Person(<span class="string">&#x27;小明&#x27;</span>, <span class="number">18</span>)</span><br><span class="line"><span class="built_in">console</span>.log(xiaoming);</span><br><span class="line"><span class="comment">// &#123; name: &#x27;小明&#x27;, age: 18 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log((<span class="keyword">typeof</span> Person));</span><br><span class="line"><span class="comment">// function</span></span><br><span class="line"><span class="built_in">console</span>.log(Person === Person.prototype.constructor);</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>constructor方法，这就是构造方法，this关键字代表实例对象。<br> 类的数据类型就是函数，类本身就指向构造函数。</p>
<blockquote>
<p>定义类的时候，前面不需要加 function, 而且方法之间不需要逗号分隔，加了会报错。</p>
</blockquote>
<p>类的所有方法都定义在类的prototype属性上面。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">    <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">    <span class="function"><span class="title">toValue</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"></span><br><span class="line">A.prototype = &#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;&#125;,</span><br><span class="line">  <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span> &#123;&#125;,</span><br><span class="line">  <span class="function"><span class="title">toValue</span>(<span class="params"></span>)</span> &#123;&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在类的实例上面调用方法，其实就是调用原型上的方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> A();</span><br><span class="line">a.constructor === A.prototype.constructor <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="constructor-方法"><a href="#constructor-方法" class="headerlink" title="constructor 方法"></a>constructor 方法</h3><p>constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>constructor方法默认返回实例对象（即this），完全可以指定返回另外一个对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log((<span class="keyword">new</span> A()) <span class="keyword">instanceof</span> A);</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h3 id="类的实例"><a href="#类的实例" class="headerlink" title="类的实例"></a>类的实例</h3><p>实例的属性除非显式定义在其本身（即定义在this对象上），否则都是定义在原型上（即定义在class上）。</p>
<h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><ol>
<li>class不存在变量提升</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> A(); <span class="comment">// ReferenceError</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>ES6 不会把类的声明提升到代码头部。这种规定的原因与继承有关，必须保证子类在父类之后定义。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> A = <span class="class"><span class="keyword">class</span> </span>&#123;&#125;;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不会报错，因为 B继承 A的时候，A已经有了定义。但是，如果存在 class提升，上面代码就会报错，因为 class 会被提升到代码头部，而let命令是不提升的，所以导致 B 继承 A 的时候，Foo还没有定义。</p>
<ol>
<li>this的指向<br> 类的方法内部如果含有this，它默认指向类的实例。但是，必须非常小心，一旦单独使用该方法，很可能报错。</li>
</ol>
<h2 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h2><p>类相当于实例的原型，所有在类中定义的方法，都会被实例继承。<br> 如果在一个方法前，加上 static 关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为”静态方法”。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">classMethod</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">A.classMethod();</span><br><span class="line"><span class="built_in">console</span>.log(A.classMethod());</span><br><span class="line"><span class="comment">// &#x27;hello&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> A();</span><br><span class="line">a.classMethod();</span><br><span class="line"><span class="comment">// TypeError: a.classMethod is not a function</span></span><br></pre></td></tr></table></figure>

<p><code>A</code> 类的<code>classMethod</code> 方法前有 <code>static</code>关键字，表明这是一个静态方法，可以在 <code>A</code> 类上直接调用，而不是在实例上调用<br> 在实例<code>a</code>上调用静态方法，会抛出一个错误，表示不存在改方法。</p>
<p>如果静态方法包含this关键字，这个this指的是类，而不是实例。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">classMethod</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.baz();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">baz</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">baz</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;world&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">A.classMethod();</span><br><span class="line"><span class="comment">// hello</span></span><br></pre></td></tr></table></figure>

<p>静态方法<code>classMethod</code>调用了<code>this.baz</code>，这里的<code>this</code>指的是<code>A</code>类，而不是<code>A</code>的实例，等同于调用<code>A.baz</code>。另外，从这个例子还可以看出，静态方法可以与非静态方法重名。</p>
<p>父类的静态方法，可以被子类继承。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">classMethod</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">B.classMethod() <span class="comment">// &#x27;hello&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h2><p>静态属性指的是 Class 本身的属性，即Class.propName，而不是定义在实例对象（this）上的属性。<br> 写法是在实例属性的前面，加上static关键字。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> myStaticProp = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(MyClass.myStaticProp); <span class="comment">// 42</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>Class 可以通过extends关键字实现继承</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123; &#125;;</span><br></pre></td></tr></table></figure>

<p>上面代码中 定义了一个 Cat 类，该类通过 <code>extends</code>关键字，继承了 Animal 类中所有的属性和方法。<br>由于没有部署任何代码，所以这两个类完全一样，等于复制了一个Animal类。<br>在Cat内部加上代码。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name, age, color</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 调用父类的constructor(name, age)</span></span><br><span class="line">        <span class="built_in">super</span>(name, age);</span><br><span class="line">        <span class="built_in">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.color + <span class="string">&#x27; &#x27;</span> + <span class="built_in">super</span>.toString(); <span class="comment">// 调用父类的toString()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>constructor方法和toString方法之中，都出现了super关键字，它在这里表示父类的构造函数，用来新建父类的this对象。</p>
<p>子类必须在 constructor 方法中调用 super 方法，否则就会报错。<br>子类自己的this对象，必须先通过 父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用super方法，子类就得不到this对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cp = <span class="keyword">new</span> Cat();</span><br><span class="line"><span class="comment">// ReferenceError</span></span><br></pre></td></tr></table></figure>

<p>Cat 继承了父类 Animal，但是它的构造函数没有调用super方法，导致新建实例报错。</p>
<p><strong>ES5的继承，实质是先创建了子类的实例对象 this, 然后再将 父类的方法添加到 this上面。</strong></p>
<p><strong>ES6的继承机制完全不同，实质是先将 父类实例对象的属性和方法，加到 this 上面（所以必须先调用 super 方法），然后再用子类的构造函数修改 this。</strong><br> 如果子类没有定义constructor方法，这个方法会被默认添加，不管有没有显式定义，任何一个子类都有constructor方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">...args</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(...args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在子类的构造函数中，只有调用<code>super</code>之后，才可以使用<code>this</code>关键字，否则会报错。这是因为子类实例的构建，基于父类实例，只有<code>super</code>方法才能调用父类实例。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">x, y</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.x = x;</span><br><span class="line">    <span class="built_in">this</span>.y = y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">x, y, name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name; <span class="comment">// ReferenceError</span></span><br><span class="line">    <span class="built_in">super</span>(x, y);</span><br><span class="line">    <span class="built_in">this</span>.name = name; <span class="comment">// 正确</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>子类的constructor方法没有调用super之前，就使用this关键字，结果报错，而放在super方法之后就是正确的。</p>
<p>父类的静态方法，也会被子类继承。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">hello</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;hello world&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">B.hello()  <span class="comment">// hello world</span></span><br></pre></td></tr></table></figure>

<h1 id="super"><a href="#super" class="headerlink" title="super"></a>super</h1><p>super既可以当作函数使用，也可以当作对象使用</p>
<h3 id="super作为函数调用"><a href="#super作为函数调用" class="headerlink" title="super作为函数调用"></a>super作为函数调用</h3><p>super作为函数调用时，代表父类的构造函数。ES6 要求，子类的构造函数必须执行一次super函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>子类B的构造函数之中的super()，代表调用父类的构造函数。这是必须的，否则 JavaScript 引擎会报错。</p>
<p>注意，super虽然代表了父类A的构造函数，但是返回的是子类B的实例，即super内部的this指的是B的实例，因此super()在这里相当于A.prototype.constructor.call(this)。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// new.target 指向正在执行的函数</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">new</span>.target.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> A() <span class="comment">// A</span></span><br><span class="line"><span class="keyword">new</span> B() <span class="comment">// B</span></span><br></pre></td></tr></table></figure>

<p>在<code>super()</code>执行时，它指向的是子类<code>B</code>的构造函数，而不是父类A的构造函数。也就是说，<code>super()</code>内部的<code>this</code>指向的是<code>B</code>。</p>
<h3 id="super作为对象调用"><a href="#super作为对象调用" class="headerlink" title="super作为对象调用"></a>super作为对象调用</h3><p><strong>在普通方法中，指向父类的原型对象；</strong><br> <strong>在静态方法中，指向父类</strong>。</p>
<h4 id="super对象在普通函数中调用"><a href="#super对象在普通函数中调用" class="headerlink" title="super对象在普通函数中调用"></a>super对象在普通函数中调用</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">p</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">super</span>.p()); <span class="comment">// 2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> B();</span><br></pre></td></tr></table></figure>

<p>子类<code>B</code>当中的<code>super.p()</code>，就是将<code>super</code>当作一个对象使用。这时，<code>super</code>在普通方法之中，指向<code>A.prototype</code>，所以<code>super.p()</code>就相当于<code>A.prototype.p()</code>。</p>
<p>这里需要注意，由于super指向父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过super调用的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.p = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">m</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.p;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> B();</span><br><span class="line">b.m <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>p是父类A实例的属性，super.p就引用不到它。</p>
<p>如果属性定义在父类的原型对象上，<code>super</code>就可以取到。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line">A.prototype.x = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">super</span>.x) <span class="comment">// 2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> B();</span><br></pre></td></tr></table></figure>

<p>属性x是定义在<code>A.prototype</code>上面的，所以<code>super.x</code>可以取到它的值。</p>
<h4 id="super对象在静态方法中调用"><a href="#super对象在静态方法中调用" class="headerlink" title="super对象在静态方法中调用"></a>super对象在静态方法中调用</h4><p>用在静态方法之中，这时super将指向父类，而不是父类的原型对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">myMethod</span>(<span class="params">msg</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;static&#x27;</span>, msg);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">myMethod</span>(<span class="params">msg</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;instance&#x27;</span>, msg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">myMethod</span>(<span class="params">msg</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.myMethod(msg);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">myMethod</span>(<span class="params">msg</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.myMethod(msg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child.myMethod(<span class="number">1</span>); <span class="comment">// static 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> child = <span class="keyword">new</span> Child();</span><br><span class="line">child.myMethod(<span class="number">2</span>); <span class="comment">// instance 2</span></span><br></pre></td></tr></table></figure>

<p>super在静态方法之中指向父类，在普通方法之中指向父类的原型对象。</p>
<p>另外，在子类的静态方法中通过<code>super</code>调用父类的方法时，方法内部的<code>this</code>指向当前的子类，而不是子类的实例。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.x = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">print</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    <span class="built_in">this</span>.x = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">m</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.print();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">B.x = <span class="number">3</span>;</span><br><span class="line">B.m() <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>静态方法<code>B.m</code>里面，<code>super.print</code>指向父类的静态方法。这个方法里面的<code>this</code>指向的是<code>B</code>，而不是<code>B</code>的实例。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>class是一个语法糖，其底层还是通过 <code>构造函数</code> 去创建的。</li>
<li>类的所有方法都定义在类的prototype属性上面。</li>
<li>静态方法：在方法前加static，表示该方法不会被实例继承，而是直接通过类来调用。</li>
<li>静态属性：在属性前加static，指的是 Class 本身的属性，而不是定义在实例对象（this）上的属性。</li>
<li>ES6的继承和ES5的继承区别在于：<ul>
<li>ES5的继承，实质是先创建了子类的实例对象 this, 然后再将 父类的方法添加到 this上面</li>
<li>ES6的继承是先将父类实例对象的属性和方法，加到 this 上面（所以必须先调用 super 方法），然后再用子类的构造函数修改 this。</li>
</ul>
</li>
<li>super<ul>
<li>作为函数调用，代表父类的构造函数</li>
<li>作为对象调用，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。</li>
</ul>
</li>
</ul>
<p><strong><span style="color:red">注意：文章仅供网站所有者自身学习使用</span></strong></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">manyfish</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://example.com/2021/05/06/ES6/">http://example.com/2021/05/06/ES6/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/Banner_img.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/05/06/%E7%A7%BB%E5%8A%A8%E7%AB%AFweb%E5%BC%80%E5%8F%91%E6%B5%81%E5%BC%8F%E5%B8%83%E5%B1%80/"><img class="prev-cover" src="/img/Banner_img.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">移动端web开发流式布局</div></div></a></div><div class="next-post pull-right"><a href="/2021/04/26/jQuery/"><img class="next-cover" src="/img/Banner_img.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">jQuery</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> Comment</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src="/img/head_img.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">manyfish</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">17</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="/" target="_blank" title=""><i></i></a><a class="social-icon" href="/i" target="_blank" title=""><i class="1"></i></a><a class="social-icon" href="/m" target="_blank" title=""><i class="2"></i></a><a class="social-icon" href="/g" target="_blank" title=""><i class="3"></i></a><a class="social-icon" href="/" target="_blank" title=""><i class="4"></i></a><a class="social-icon" href="/h" target="_blank" title=""><i class="5"></i></a><a class="social-icon" href="/e" target="_blank" title=""><i class="6"></i></a><a class="social-icon" href="/a" target="_blank" title=""><i class="7"></i></a><a class="social-icon" href="/d" target="_blank" title=""><i class="8"></i></a><a class="social-icon" href="/_" target="_blank" title=""><i class="9"></i></a><a class="social-icon" href="/i" target="_blank" title=""><i class="10"></i></a><a class="social-icon" href="/m" target="_blank" title=""><i class="11"></i></a><a class="social-icon" href="/g" target="_blank" title=""><i class="12"></i></a><a class="social-icon" href="/." target="_blank" title=""><i class="13"></i></a><a class="social-icon" href="/j" target="_blank" title=""><i class="14"></i></a><a class="social-icon" href="/p" target="_blank" title=""><i class="15"></i></a><a class="social-icon" href="/g" target="_blank" title=""><i class="16"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#ES6"><span class="toc-number">1.</span> <span class="toc-text">ES6</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ES6%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.1.</span> <span class="toc-text">ES6是什么</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ES6%E6%96%B0%E7%9A%84%E8%AF%AD%E6%B3%95"><span class="toc-number">2.</span> <span class="toc-text">ES6新的语法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%B8%B8%E9%87%8F"><span class="toc-number">2.1.</span> <span class="toc-text">1.常量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">2.2.</span> <span class="toc-text">2.块级作用域</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">2.2.1.</span> <span class="toc-text">2.1.**作用域 **</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-let%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">2.2.2.</span> <span class="toc-text">2.2.let关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-const%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">2.2.3.</span> <span class="toc-text">2.3.const关键字</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC"><span class="toc-number">2.3.</span> <span class="toc-text">3.解构赋值</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1%E8%A7%A3%E6%9E%84%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.3.1.</span> <span class="toc-text">3.1解构模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2%E6%95%B0%E7%BB%84%E8%A7%A3%E6%9E%84"><span class="toc-number">2.3.2.</span> <span class="toc-text">3.2数组解构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3%E5%AF%B9%E8%B1%A1%E8%A7%A3%E6%9E%84"><span class="toc-number">2.3.3.</span> <span class="toc-text">3.3对象解构</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9C%A8%E7%BA%BF%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.</span> <span class="toc-text">在线转换</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#let%E5%92%8Cconst%E5%91%BD%E4%BB%A4"><span class="toc-number">4.</span> <span class="toc-text">let和const命令</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#let%E5%92%8Cvar%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.1.</span> <span class="toc-text">let和var的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E5%AD%98%E5%9C%A8%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87"><span class="toc-number">4.2.</span> <span class="toc-text">不存在变量提升</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9A%82%E6%97%B6%E6%80%A7%E6%AD%BB%E5%8C%BA"><span class="toc-number">4.3.</span> <span class="toc-text">暂时性死区</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E5%85%81%E8%AE%B8%E9%87%8D%E5%A4%8D%E5%A3%B0%E6%98%8E"><span class="toc-number">4.4.</span> <span class="toc-text">不允许重复声明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">4.5.</span> <span class="toc-text">块级作用域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ES6-%E7%9A%84%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">4.6.</span> <span class="toc-text">ES6 的块级作用域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E"><span class="toc-number">4.7.</span> <span class="toc-text">块级作用域与函数声明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#do-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">4.8.</span> <span class="toc-text">do 表达式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#const-%E5%91%BD%E4%BB%A4"><span class="toc-number">4.9.</span> <span class="toc-text">const 命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ES6-%E5%A3%B0%E6%98%8E%E5%8F%98%E9%87%8F%E7%9A%84%E5%85%AD%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="toc-number">4.10.</span> <span class="toc-text">ES6 声明变量的六种方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC"><span class="toc-number">4.11.</span> <span class="toc-text">字符串的解构赋值</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC"><span class="toc-number">5.</span> <span class="toc-text">变量的解构赋值</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E9%80%94"><span class="toc-number">5.1.</span> <span class="toc-text">用途</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%89%A9%E5%B1%95"><span class="toc-number">6.</span> <span class="toc-text">字符串的扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#codePointAt"><span class="toc-number">6.1.</span> <span class="toc-text">codePointAt()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String-fromCodePoint"><span class="toc-number">6.2.</span> <span class="toc-text">String.fromCodePoint()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E9%81%8D%E5%8E%86%E5%99%A8%E6%8E%A5%E5%8F%A3"><span class="toc-number">6.3.</span> <span class="toc-text">字符串的遍历器接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#at"><span class="toc-number">6.4.</span> <span class="toc-text">at()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#normalize"><span class="toc-number">6.5.</span> <span class="toc-text">normalize()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#includes-startsWith-endsWith"><span class="toc-number">6.6.</span> <span class="toc-text">includes(), startsWith(), endsWith()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#repeat"><span class="toc-number">6.7.</span> <span class="toc-text">repeat()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#padStart-%EF%BC%8CpadEnd"><span class="toc-number">6.8.</span> <span class="toc-text">padStart()，padEnd()</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E5%80%BC%E7%9A%84%E6%89%A9%E5%B1%95"><span class="toc-number">7.</span> <span class="toc-text">数值的扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Number-isFinite-Number-isNaN"><span class="toc-number">7.1.</span> <span class="toc-text">Number.isFinite(), Number.isNaN()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Number-parseInt-Number-parseFloat"><span class="toc-number">7.2.</span> <span class="toc-text">Number.parseInt(), Number.parseFloat()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Number-isInteger"><span class="toc-number">7.3.</span> <span class="toc-text">Number.isInteger()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Number-EPSILON"><span class="toc-number">7.4.</span> <span class="toc-text">Number.EPSILON</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E6%95%B4%E6%95%B0%E5%92%8CNumber-isSafeInteger"><span class="toc-number">7.5.</span> <span class="toc-text">安全整数和Number.isSafeInteger()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Math%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%89%A9%E5%B1%95"><span class="toc-number">7.6.</span> <span class="toc-text">Math对象的扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Math-trunc"><span class="toc-number">7.6.1.</span> <span class="toc-text">Math.trunc()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Math-sign"><span class="toc-number">7.6.2.</span> <span class="toc-text">Math.sign()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Math-cbrt"><span class="toc-number">7.6.3.</span> <span class="toc-text">Math.cbrt()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Math-clz32"><span class="toc-number">7.6.4.</span> <span class="toc-text">Math.clz32()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Math-imul"><span class="toc-number">7.6.5.</span> <span class="toc-text">Math.imul()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Math-fround"><span class="toc-number">7.6.6.</span> <span class="toc-text">Math.fround()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Math-hypot"><span class="toc-number">7.6.7.</span> <span class="toc-text">Math.hypot()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E6%95%B0%E6%96%B9%E6%B3%95"><span class="toc-number">7.6.8.</span> <span class="toc-text">对数方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0%E6%96%B9%E6%B3%95"><span class="toc-number">7.6.9.</span> <span class="toc-text">三角函数方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Math-signbit"><span class="toc-number">7.6.10.</span> <span class="toc-text">Math.signbit()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E6%95%B0%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">7.6.11.</span> <span class="toc-text">指数运算符</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E6%89%A9%E5%B1%95"><span class="toc-number">8.</span> <span class="toc-text">数组的扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Array-from"><span class="toc-number">8.1.</span> <span class="toc-text">Array.from()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Array-of"><span class="toc-number">8.2.</span> <span class="toc-text">Array.of()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%AE%9E%E4%BE%8B%E7%9A%84copyWithin"><span class="toc-number">8.3.</span> <span class="toc-text">数组实例的copyWithin()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%AE%9E%E4%BE%8B%E7%9A%84find-%E5%92%8CfindIndex"><span class="toc-number">8.4.</span> <span class="toc-text">数组实例的find()和findIndex()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%AE%9E%E4%BE%8B%E7%9A%84fill"><span class="toc-number">8.5.</span> <span class="toc-text">数组实例的fill()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#entries-%EF%BC%8Ckeys-%E5%92%8Cvalues-%E7%94%A8%E4%BA%8E%E9%81%8D%E5%8E%86%E6%95%B0%E7%BB%84"><span class="toc-number">8.6.</span> <span class="toc-text">entries()，keys()和values()用于遍历数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#includes"><span class="toc-number">8.7.</span> <span class="toc-text">includes()</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A9%E5%B1%95"><span class="toc-number">9.</span> <span class="toc-text">函数的扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="toc-number">9.1.</span> <span class="toc-text">基本用法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E9%BB%98%E8%AE%A4%E5%80%BC%E7%9A%84%E4%BD%8D%E7%BD%AE"><span class="toc-number">9.2.</span> <span class="toc-text">参数默认值的位置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84-length-%E5%B1%9E%E6%80%A7"><span class="toc-number">9.3.</span> <span class="toc-text">函数的 length 属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">9.4.</span> <span class="toc-text">作用域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%94%E7%94%A8"><span class="toc-number">9.5.</span> <span class="toc-text">应用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#rest%E5%8F%82%E6%95%B0"><span class="toc-number">9.6.</span> <span class="toc-text">rest参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">9.7.</span> <span class="toc-text">扩展运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%BF%E4%BB%A3%E6%95%B0%E7%BB%84%E7%9A%84apply%E6%96%B9%E6%B3%95"><span class="toc-number">9.7.1.</span> <span class="toc-text">替代数组的apply方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">9.7.2.</span> <span class="toc-text">扩展运算符的应用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#name-%E5%B1%9E%E6%80%A7"><span class="toc-number">9.8.</span> <span class="toc-text">name 属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0"><span class="toc-number">9.9.</span> <span class="toc-text">箭头函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%89%A9%E5%B1%95"><span class="toc-number">10.</span> <span class="toc-text">对象的扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E7%9A%84%E6%95%B4%E6%B4%81%E8%A1%A8%E8%BE%BE%E6%B3%95"><span class="toc-number">10.1.</span> <span class="toc-text">属性的整洁表达法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E5%90%8D%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">10.2.</span> <span class="toc-text">属性名表达式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84-name-%E5%B1%9E%E6%80%A7"><span class="toc-number">10.3.</span> <span class="toc-text">方法的 name 属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Object-is"><span class="toc-number">10.4.</span> <span class="toc-text">Object.is()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Object-assign"><span class="toc-number">10.5.</span> <span class="toc-text">Object.assign()</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%94%A8%E9%80%94"><span class="toc-number">10.5.1.</span> <span class="toc-text">常见用途</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E5%8F%AF%E6%9E%9A%E4%B8%BE%E6%80%A7"><span class="toc-number">10.6.</span> <span class="toc-text">属性可枚举性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">10.7.</span> <span class="toc-text">属性的遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#proto%E5%B1%9E%E6%80%A7%EF%BC%8CObject-setPrototypeOf-%EF%BC%8CObject-getPrototypeOf"><span class="toc-number">10.8.</span> <span class="toc-text">proto属性，Object.setPrototypeOf()，Object.getPrototypeOf()</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#proto%E5%B1%9E%E6%80%A7"><span class="toc-number">10.8.1.</span> <span class="toc-text">proto属性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Object-setPrototypeOf"><span class="toc-number">10.9.</span> <span class="toc-text">Object.setPrototypeOf()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Object-getPrototypeOf"><span class="toc-number">10.10.</span> <span class="toc-text">Object.getPrototypeOf()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Object-keys"><span class="toc-number">10.11.</span> <span class="toc-text">Object.keys()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Object-values"><span class="toc-number">10.12.</span> <span class="toc-text">Object.values()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Object-entries"><span class="toc-number">10.13.</span> <span class="toc-text">Object.entries</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">10.14.</span> <span class="toc-text">对象的扩展运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Object-getOwnPropertyDescriptors"><span class="toc-number">10.15.</span> <span class="toc-text">Object.getOwnPropertyDescriptors()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Null-%E4%BC%A0%E5%AF%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">10.16.</span> <span class="toc-text">Null 传导运算符</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Symbol"><span class="toc-number">11.</span> <span class="toc-text">Symbol</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%9C%E4%B8%BA%E5%B1%9E%E6%80%A7%E5%90%8D%E7%9A%84Symbol"><span class="toc-number">11.1.</span> <span class="toc-text">作为属性名的Symbol</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E5%90%8D%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">11.2.</span> <span class="toc-text">属性名的遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Symbol-for-Symbol-keyFor"><span class="toc-number">11.3.</span> <span class="toc-text">Symbol.for(),Symbol.keyFor()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%EF%BC%9A%E6%A8%A1%E5%9D%97%E7%9A%84-Singleton-%E6%A8%A1%E5%BC%8F"><span class="toc-number">11.4.</span> <span class="toc-text">实例：模块的 Singleton 模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E7%BD%AE%E7%9A%84Symbol%E5%80%BC"><span class="toc-number">11.5.</span> <span class="toc-text">内置的Symbol值</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Symbol-hasInstance"><span class="toc-number">11.5.1.</span> <span class="toc-text">Symbol.hasInstance</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Symbol-isConcatSpreadable"><span class="toc-number">11.5.2.</span> <span class="toc-text">Symbol.isConcatSpreadable</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Symbol-species"><span class="toc-number">11.5.3.</span> <span class="toc-text">Symbol.species</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Symbol-match"><span class="toc-number">11.5.4.</span> <span class="toc-text">Symbol.match</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Symbol-replace"><span class="toc-number">11.5.5.</span> <span class="toc-text">Symbol.replace</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Symbol-search"><span class="toc-number">11.5.6.</span> <span class="toc-text">Symbol.search</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Symbol-split"><span class="toc-number">11.5.7.</span> <span class="toc-text">Symbol.split</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Symbol-iterator"><span class="toc-number">11.5.8.</span> <span class="toc-text">Symbol.iterator</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Symbol-toPrimitive"><span class="toc-number">11.5.9.</span> <span class="toc-text">Symbol.toPrimitive</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Symbol-toStringTag"><span class="toc-number">11.5.10.</span> <span class="toc-text">Symbol.toStringTag</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Symbol-unscopables"><span class="toc-number">11.5.11.</span> <span class="toc-text">Symbol.unscopables</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Set%E5%92%8CMap%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">12.</span> <span class="toc-text">Set和Map数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Set"><span class="toc-number">12.1.</span> <span class="toc-text">Set</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#map"><span class="toc-number">12.2.</span> <span class="toc-text">map</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Reflect%E5%8F%8D%E5%B0%84"><span class="toc-number">13.</span> <span class="toc-text">Reflect反射</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">13.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E4%BD%BF%E7%94%A8%EF%BC%88Reflect%E4%B8%8EProxy%EF%BC%89"><span class="toc-number">13.2.</span> <span class="toc-text">组合使用（Reflect与Proxy）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#proxy%E4%BB%A3%E7%90%86"><span class="toc-number">14.</span> <span class="toc-text">proxy代理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81proxy%E6%A6%82%E8%BF%B0"><span class="toc-number">14.1.</span> <span class="toc-text">一、proxy概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Proxy%E6%89%80%E8%83%BD%E4%BB%A3%E7%90%86%E7%9A%84%E8%8C%83%E5%9B%B4%E2%80%93handler"><span class="toc-number">14.2.</span> <span class="toc-text">二、Proxy所能代理的范围–handler</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81Proxy%E5%9C%BA%E6%99%AF"><span class="toc-number">14.3.</span> <span class="toc-text">三、Proxy场景</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E5%AE%9E%E7%8E%B0%E7%A7%81%E6%9C%89%E5%8F%98%E9%87%8F"><span class="toc-number">14.3.1.</span> <span class="toc-text">3.1 实现私有变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E6%8A%BD%E7%A6%BB%E6%A0%A1%E9%AA%8C%E6%A8%A1%E5%9D%97"><span class="toc-number">14.3.2.</span> <span class="toc-text">3.2 抽离校验模块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E8%AE%BF%E9%97%AE%E6%97%A5%E5%BF%97"><span class="toc-number">14.3.3.</span> <span class="toc-text">3.3 访问日志</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E9%A2%84%E8%AD%A6%E5%92%8C%E6%8B%A6%E6%88%AA"><span class="toc-number">14.3.4.</span> <span class="toc-text">3.4 预警和拦截</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-%E8%BF%87%E6%BB%A4%E6%93%8D%E4%BD%9C"><span class="toc-number">14.3.5.</span> <span class="toc-text">3.5 过滤操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-%E4%B8%AD%E6%96%AD%E4%BB%A3%E7%90%86"><span class="toc-number">14.3.6.</span> <span class="toc-text">3.6 中断代理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#class"><span class="toc-number">15.</span> <span class="toc-text">class</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#constructor-%E6%96%B9%E6%B3%95"><span class="toc-number">15.0.1.</span> <span class="toc-text">constructor 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B"><span class="toc-number">15.0.2.</span> <span class="toc-text">类的实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%EF%BC%9A"><span class="toc-number">15.0.3.</span> <span class="toc-text">注意：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-number">15.1.</span> <span class="toc-text">静态方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%B1%9E%E6%80%A7"><span class="toc-number">15.2.</span> <span class="toc-text">静态属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">15.3.</span> <span class="toc-text">继承</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#super"><span class="toc-number">16.</span> <span class="toc-text">super</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#super%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8"><span class="toc-number">16.0.1.</span> <span class="toc-text">super作为函数调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#super%E4%BD%9C%E4%B8%BA%E5%AF%B9%E8%B1%A1%E8%B0%83%E7%94%A8"><span class="toc-number">16.0.2.</span> <span class="toc-text">super作为对象调用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#super%E5%AF%B9%E8%B1%A1%E5%9C%A8%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E4%B8%AD%E8%B0%83%E7%94%A8"><span class="toc-number">16.0.2.1.</span> <span class="toc-text">super对象在普通函数中调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#super%E5%AF%B9%E8%B1%A1%E5%9C%A8%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E4%B8%AD%E8%B0%83%E7%94%A8"><span class="toc-number">16.0.2.2.</span> <span class="toc-text">super对象在静态方法中调用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">16.1.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/06/22/%E7%BB%84%E4%BB%B6%E7%9A%84%E7%BB%84%E7%BB%87/" title="No title">No title</a><time datetime="2021-06-22T07:13:44.272Z" title="Created 2021-06-22 15:13:44">2021-06-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/06/01/Express%E7%9A%84%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/" title="No title">No title</a><time datetime="2021-06-01T01:26:36.916Z" title="Created 2021-06-01 09:26:36">2021-06-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/05/18/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5/" title="No title">No title</a><time datetime="2021-05-18T08:53:12.503Z" title="Created 2021-05-18 16:53:12">2021-05-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/05/12/%E5%B0%8F%E8%AE%B0/" title="小记">小记</a><time datetime="2021-05-12T06:36:00.000Z" title="Created 2021-05-12 14:36:00">2021-05-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/05/10/Boostrap%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80/" title="Boostrap响应式布局">Boostrap响应式布局</a><time datetime="2021-05-10T00:36:00.000Z" title="Created 2021-05-10 08:36:00">2021-05-10</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By manyfish</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="Increase font size"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="Decrease font size"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="Toggle Between Traditional Chinese And Simplified Chinese">繁</button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="rightside.chat_btn"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="Scroll To Comments"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'AFItm5az9ElXBoaK1FVBD0WI-gzGzoHsz',
      appKey: 'zxKTlpuHwpY4p7brYypV5sB2',
      placeholder: 'o(*￣▽￣*)ブ欢迎吐槽',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'en',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      path: window.location.pathname,
      requiredFields: ["nick,mail"],
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><link rel="stylesheet" href="css/Lete.css"><script data-pjax src="js/Lete.js"></script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-show-text.min.js" data-mobile="true" data-text="♥好多愚♥,♥欢迎♥" data-fontsize="15px" data-random="true" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>