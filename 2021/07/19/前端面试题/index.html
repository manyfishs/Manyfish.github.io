<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>ManyFish's Blog | ManyFish's Blog</title><meta name="author" content="manyfish"><meta name="copyright" content="manyfish"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="VUE面试题1、v-show 和 v-if的区别，v-show 和 keep-alive 的区别 答案：v-show是 CSS display 控制显示和隐藏 v-if 是组件真正的渲染和销毁，而不是显示和隐藏 频繁切换显示状态用 v-show，否则用 v-if keep-alive 是在vue 框架层级进行的JS 对象渲染 一般简单的可用 v-show， 复杂一点的一般用 keep-alive，">
<meta property="og:type" content="article">
<meta property="og:title" content="ManyFish&#39;s Blog">
<meta property="og:url" content="http://example.com/2021/07/19/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/index.html">
<meta property="og:site_name" content="ManyFish&#39;s Blog">
<meta property="og:description" content="VUE面试题1、v-show 和 v-if的区别，v-show 和 keep-alive 的区别 答案：v-show是 CSS display 控制显示和隐藏 v-if 是组件真正的渲染和销毁，而不是显示和隐藏 频繁切换显示状态用 v-show，否则用 v-if keep-alive 是在vue 框架层级进行的JS 对象渲染 一般简单的可用 v-show， 复杂一点的一般用 keep-alive，">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/Banner_img.jpg">
<meta property="article:published_time" content="2021-07-19T09:17:35.287Z">
<meta property="article:modified_time" content="2021-07-19T09:29:06.431Z">
<meta property="article:author" content="manyfish">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/Banner_img.jpg"><link rel="shortcut icon" href="/img/frog.png"><link rel="canonical" href="http://example.com/2021/07/19/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'ManyFish\'s Blog',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-07-19 17:29:06'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/static-butterfly/dist/css/index.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css"><script src="https://cdn.jsdelivr.net/gh/stevenjoezhang/live2d-widget@latest/autoload.js"></script><html style="cursor:url('img/Arrow.cur'),default"><meta name="generator" content="Hexo 5.4.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/head_img.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">24</div></a></div></div></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/Banner_img.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">ManyFish's Blog</a></span><div id="menus"><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">无题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-07-19T09:17:35.287Z" title="发表于 2021-07-19 17:17:35">2021-07-19</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-07-19T09:29:06.431Z" title="更新于 2021-07-19 17:29:06">2021-07-19</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/2021/07/19/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count" data-xid="/2021/07/19/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/" itemprop="commentCount"></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h3 id="VUE面试题"><a href="#VUE面试题" class="headerlink" title="VUE面试题"></a>VUE面试题</h3><p>1、v-show 和 v-if的区别，v-show 和 keep-alive 的区别</p>
<p>答案：v-show是 CSS display 控制显示和隐藏</p>
<p>v-if 是组件真正的渲染和销毁，而不是显示和隐藏</p>
<p>频繁切换显示状态用 v-show，否则用 v-if</p>
<p>keep-alive 是在vue 框架层级进行的JS 对象渲染</p>
<p>一般简单的可用 v-show，</p>
<p>复杂一点的一般用 keep-alive，keep-alive 通常用于 tab 的切换</p>
<p>2、为何 v-for 要用 key</p>
<p>答案：必须要用 key, 而且不能用 index 和 random，</p>
<p>key是vue中vnode的唯一标记，通过这个key，我们的diff操作可以更准确，更快速</p>
<p>在 diff 算法中用 tag 和 key来判断，是否是sameNode</p>
<p>可以减少渲染次数，提高渲染性能</p>
<p>3、描述 Vue 组件生命周期（有父子组件的情况）</p>
<p>答案：单组件生命周期，生命周期可分为</p>
<ul>
<li>挂载阶段（<ul>
<li>beforeCreate:此阶段为实例初始化之后,此时数据观察和事件机制还没有形成,不能获取到dom节点；</li>
<li>created：此阶段的vue实例已经创建,仍不能获取DOM 节点.把vue 的一个实例给初始化了，只是存在于 js 内存的一个变量而已，这个时候并没有开始渲染；</li>
<li>beforeMount:在这一阶段,我们虽然还不能获取到具体 DOM 元素,但 vue 挂载的根节点已经创建,下面 vue 对DOM 的操作将围绕这个根元素继续进行,beforeMount 这个阶段是过渡性的,一般一个项目只能用到一两次；</li>
<li>mounted：组件真正绘制完成了，页面已经渲染完了,数据和DOM 都已被渲染出来,一般我们的异步请求都写在这里)</li>
</ul>
</li>
<li>更新阶段（<ul>
<li>beforeUpdate: 这一阶段，vue遵循数据驱动DOM 的原则，beforeUpdate 函数在数据更新后没有立即更新数据，但是DOM 数据会改变，这是双向数据绑定的作用；</li>
<li>updated：这一阶段，DOM 会和更改过的内容同步)</li>
</ul>
</li>
<li>销毁阶段（<ul>
<li>beforeDestroy：在上一阶段vue已经成功通过数据驱动DOM 的修改，当我们不再需要 vue 操纵 DOM 时，就要销毁 vue，也就是清除vue 实例与 DOM 的关联，调用destroy方法可以销毁当前组件。在销毁前，会触发 beforeDestroy 钩子函数；</li>
<li>destroyed：在销毁后，会触发destroyed 钩子函数）</li>
</ul>
</li>
</ul>
<p>beforeDestroy要做的事：</p>
<ul>
<li>自定义事件解除绑定：（eventBus 等）</li>
<li>销毁定时任务：（setTimeout,setInterval等）</li>
<li>绑定的window 或 document 事件要销毁</li>
</ul>
<p>总之就是该销毁的要在这里销毁，不要让他们留在内存中</p>
<p>具体参考：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/queenya/p/13416654.html">https://www.cnblogs.com/queenya/p/13416654.html</a></p>
<p>多组件生命周期：</p>
<ul>
<li>挂载阶段（加载渲染过程）：</li>
<li>父 beforeCreate –&gt; 父 created –&gt; 父 beforeMount –&gt; 子 beforeCreate –&gt; 子 created –&gt; 子 beforeMount –&gt; 子 mounted –&gt; 父 mounted</li>
<li>更新阶段：</li>
<li>父 beforeUpdate –&gt; 子 beforeUpdate –&gt; 子 updated –&gt; 父 updated</li>
<li>销毁阶段：</li>
<li>父 beforeDestroy –&gt; 子 beforeDestroy –&gt; 子 destroyed –&gt; 父 destroyed</li>
</ul>
<p>4、Vue 组件如何通讯</p>
<p>答案：</p>
<ul>
<li>父子组件通讯：使用属性和触发事件，props，$emit，this.$emit 调用父组件的事件，父组件向子组件传递一个信息，或者说子组件向父组件触发一个事件</li>
<li>组件之间没有关系或层级较深：使用自定义事件 ，event是vue实例，vue本身就具有自定义事件的能力。调用自定义事件： event.$emit(‘xxx’, 变量名)；绑定自定义事件：event.$on(‘xxx’, 函数名字)。在beforeDestroy 要做的一件事是及时解绑自定义事件，及时销毁，否则可能造成内存泄漏，写法：event.$off(‘xxx’, 函数名).</li>
<li>vuex 通讯</li>
</ul>
<p>5、描述组件渲染和更新的过程</p>
<p>答案：</p>
<ul>
<li>初次渲染过程：</li>
</ul>
<ol>
<li>解析模板为 render 函数（或在开发环境已完成， vue-loader）</li>
<li>触发响应式，监听 data 属性 getter，setter</li>
<li>执行 render 函数，生成 vnode, patch(elem, vnode)</li>
</ol>
<ul>
<li>更新过程：</li>
</ul>
<ol>
<li>修改 data，触发 setter （此前在 getter 中 已被 监听）</li>
<li>重新执行 render 函数，生成 newVnode</li>
<li>patch(vnode, newVnode)</li>
</ol>
<p><img src="https://img2020.cnblogs.com/blog/2086015/202008/2086015-20200828001411796-2025830332.png" alt="img"></p>
<ul>
<li>异步渲染：</li>
</ul>
<ol>
<li>回顾 $nextTick，（以下这是对 $nextTick的回顾： $nextTick: vue 是异步渲染；data改变之后，DOM 不会立刻渲染；$nextTick 会在 DOM 渲染之后被触发，以获取最新 DOM 节点。vue 为何是异步渲染，$nextTick何用？异步渲染（以及合并data修改），以提高渲染性能，$nextTick 在DOM 更新完之后，触发回调。另外，在 vue 中可以通过 ref 获取元素：给元素添加ref属性并设置名称，然后通过 this.$refs.ref 属性名称获取该DOM 元素）总结：1、异步渲染，$nextTick待 DOM 渲染完再回调；2、页面渲染时会将 data 的修改做整合，多次data修改只做一次渲染。</li>
<li>汇总 data 的修改，一次性更新视图</li>
<li>减少 DOM 操作次数，提高性能</li>
</ol>
<p>6、双向事件绑定 v-model 的实现原理</p>
<p>答案：通过 input 元素的 value = this.name</p>
<p>绑定 input 事件 this.name = $event.target.value</p>
<p>data 更新触发 re-render</p>
<p>数据双向绑定的原理可参考：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/queenya/p/13426695.html">https://www.cnblogs.com/queenya/p/13426695.html</a> 的第3 点**<br>**</p>
<p>7、对 MVVM 的理解</p>
<p>答案：参考：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/queenya/p/13426695.html">https://www.cnblogs.com/queenya/p/13426695.html</a> 第1、2点</p>
<p><img src="https://img2020.cnblogs.com/blog/2086015/202008/2086015-20200828144655100-789834958.png" alt="img"></p>
<p>8、computed 有何特点，computed 和 watch，methods 的区别</p>
<p>答案：</p>
<ul>
<li>computed： 有缓存，data 不变不会重新计算；提高性能。</li>
<li>computed 为什么需要缓存？简单说就是可以提高性能。假设我们有一个性能开销比较大的计算属性A,它需要遍历一个巨大的数组做大量的计算，然后我们可能有其他的属性依赖于A，如果没有缓存，将不可避免的多次执行A 的getter，如果不希望有缓存请用方法代替</li>
<li>computed 和 methods的区别: computed 计算属性是基于它的响应式依赖进行缓存的，只在相关响应式依赖发生改变时它们才会重新求值，这意味着只要原属性还没发生改变，多次访问相关属性，计算属性会立即返回之前的计算结果，而不必再次执行函数；而 methods 每当触发重新渲染时，调用方法总会再次执行函数</li>
<li>computed 和 watch的区别：computed 默认只要 getter，不过需要时也可以提供 setter；watch 侦听器，当需要在数据变化时执行异步或开销较大的操作时，watch是最有用的，使用 watch选项允许执行异步操作（访问一个API）,限制我们执行该操作的频率，并在得到最终结果前，设置中间状态，这些都是计算属性无法做到的</li>
</ul>
<p>（</p>
<ul>
<li>computed 是属性</li>
</ul>
<ol>
<li>当需要根据已有数据产生一些派生数据的时候，可使用计算属性</li>
<li>注意：计算属性不支持异步操作，因为计算属性一般要绑定到模板中</li>
<li>更重要的一点是：计算属性会缓存调用的结果，提高性能</li>
<li>计算属性必须有返回值，没有返回值就没有意义</li>
</ol>
<ul>
<li>watch 是一个功能：</li>
</ul>
<ol>
<li>watch不需要返回值，根据某个数据变化执行xx逻辑</li>
<li>watch可以执行异步操作</li>
</ol>
<p>）</p>
<ul>
<li>computed 和 watch的使用场景：如果一个数据需要经过复杂计算就用 computed；如果一个数据需要被监听并且对数据做一些操作就用watch；watch擅长处理的场景：一个数据影响多个数据；computed擅长处理的场景：一个数据受多个数据影响</li>
</ul>
<p>9、为何组件 data 必须是一个函数？</p>
<p>答案：防止组件重用的时候导致数据相互影响。根本上 .vue 文件编译出来是一个类，这个组件是一个class，我们在使用这个组件的时候相当于对class 实现实例化，在实例化的时候执行data，如果 data不是函数的话拿每个组件的实例结果都一样了，共享了，如果 data不是函数的话在一个地方改了，另一个地方也改了。如果data是函数在左边实例化一个右边实例化一个都会执行这个函数，这两个data都在闭包中，两个不会相互影响</p>
<p><img src="https://img2020.cnblogs.com/blog/2086015/202008/2086015-20200828144926765-929997092.png" alt="img"></p>
<p>10、Ajax 请求应该放在哪个生命周期</p>
<p>答案：应该放在 mounted 生命周期，JS 是单线程的，Ajax 异步获取数据，放在 mounted 之前没有用，只会让逻辑更加混乱</p>
<p>11、如何将组件所有 props 传递给子组件？</p>
<p>答案：$props　　<user v-bind="$props"></user></p>
<p>12、如何自己实现 v-model？</p>
<p>答案：<img src="https://img2020.cnblogs.com/blog/2086015/202008/2086015-20200828145415929-707137042.png" alt="img"></p>
<p>13、多个组件有相同逻辑，如何抽离？</p>
<p>答案： 用 mixin, mixin 的一些缺点</p>
<p>mixin 的用法：；定义一个 js文件将export default 中的共有内容写到里面，然后在组件中import，放到 mixin数组中</p>
<p><img src="https://img2020.cnblogs.com/blog/2086015/202008/2086015-20200828150352393-1211637052.jpg" alt="img"><img src="https://img2020.cnblogs.com/blog/2086015/202008/2086015-20200828150400436-1994225499.jpg" alt="img"></p>
<p>mixin 的一些缺点：</p>
<ol>
<li>变量来源不明，不利于阅读。我们希望编程红的变量和方法是可查找的，但是 mixin 引入的内容编辑是不可寻找</li>
<li>多mixin 可能造成命名冲突</li>
<li>迷信和组件可能出现多对多的关系（一个组件引用多个 mixin, 一个mixin被多个组件引用），复杂度较高。多对多是最复杂的关系，很容易剪不断理还乱</li>
</ol>
<p>在vue3 提出的 Composition API 旨在解决这些问题</p>
<p>14、何时使用异步组件？</p>
<p>答案：</p>
<ul>
<li>加载大组件</li>
<li>路由异步加载</li>
</ul>
<p>15、何时需要使用 keep-alive？</p>
<p>答案：</p>
<ul>
<li>缓存组件，不需要重复渲染</li>
<li>如多个静态 tab 页的切换</li>
<li>优化性能</li>
</ul>
<p>16、何时需要使用 beforeDestroy？</p>
<p>答案：</p>
<ul>
<li>解除自定义事件 event.$off</li>
<li>清除定时器</li>
<li>解绑自定义的 DOM 事件，如 window scroll等</li>
</ul>
<p> 17、什么是作用域插槽？</p>
<p>答案：父组件通过 slot 获取子组件中的的值：子组件中通过自定义属性绑定数据，父组件通过 template的 v-slot 属性来接收数据</p>
<p><img src="https://img2020.cnblogs.com/blog/2086015/202008/2086015-20200828142117996-2061614703.png" alt="img"></p>
<p>18、vuex 中 action 和 mutation有何区别？</p>
<p>答案：</p>
<ul>
<li>action 中处理异步，mutation 不可以</li>
<li>mutation 做原子操作</li>
<li>action 可以整合多个 mutation</li>
</ul>
<p>19、vue-router 常用的路由模式</p>
<p>答案：</p>
<ul>
<li>hash 默认：有 #，也就是路由的hash，后面是路由</li>
<li>H5 history(需要服务端支持)：没有 #，需要服务端再次，无特殊需求可选择 hash模式</li>
</ul>
<p>20、如何配置 vue-router 异步加载？</p>
<p>答案：异步加载性能会优化很多，配置：component: () =&gt; import(……)</p>
<p><img src="https://img2020.cnblogs.com/blog/2086015/202008/2086015-20200828143509805-642380269.png" alt="img"></p>
<p>21、请用 vnode 描述一个 DOM 结构</p>
<p>答案：</p>
<p><img src="https://img2020.cnblogs.com/blog/2086015/202008/2086015-20200828163217966-718967369.png" alt="img"></p>
<p>22、监听 data 变化的核心 API 是什么？</p>
<p>答案： Object.defineProperty,以及要想一下如何深度监听、监听数组，有何缺点</p>
<p>如何深度监听：</p>
<p><img src="https://img2020.cnblogs.com/blog/2086015/202008/2086015-20200828164616653-2145349299.png" alt="img"><img src="https://img2020.cnblogs.com/blog/2086015/202008/2086015-20200828164628248-856927862.png" alt="img"><img src="https://img2020.cnblogs.com/blog/2086015/202008/2086015-20200828164645301-561665795.png" alt="img"></p>
<p>如何监听数组：</p>
<p><img src="https://img2020.cnblogs.com/blog/2086015/202008/2086015-20200828165830524-762393245.png" alt="img"><img src="https://img2020.cnblogs.com/blog/2086015/202008/2086015-20200828165839340-816677951.png" alt="img"></p>
<p>不可像以下这样做会污染全局的Array 原型：</p>
<p><img src="https://img2020.cnblogs.com/blog/2086015/202008/2086015-20200828170054805-1985733181.png" alt="img"></p>
<p>缺点：</p>
<ul>
<li><ul>
<li>深度监听，需要递归到底，一次性计算量大</li>
<li>无法监听新增/删除属性（所以需要 vue.set vue.delete 实现新增/删除属性）</li>
<li>无法监听原生数组，需要特殊处理</li>
</ul>
</li>
</ul>
<p>23、vue 如何监听数组变化</p>
<p>答案：</p>
<ul>
<li>Object.defineProperty 不能监听数组变化</li>
<li>重新定义原型，重写push pop 等方法，实现监听</li>
<li><img src="https://img2020.cnblogs.com/blog/2086015/202008/2086015-20200828165830524-762393245.png" alt="img"></li>
<li><img src="https://img2020.cnblogs.com/blog/2086015/202008/2086015-20200828165839340-816677951.png" alt="img"></li>
<li>Proxy 可以原生支持监听数组变化</li>
</ul>
<p>24、请描述响应式原理</p>
<p>答案：</p>
<ul>
<li>监听data变化，监听data属性getter，setter（包括数组）参考：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/queenya/p/13426695.html">https://www.cnblogs.com/queenya/p/13426695.html</a> 第3点</li>
<li>组件渲染和更新的流程：</li>
</ul>
<p><img src="https://img2020.cnblogs.com/blog/2086015/202008/2086015-20200828172721212-836149298.png" alt="img"></p>
<p>25、diff 算法的时间复杂度</p>
<p>答案：</p>
<p>O(n)</p>
<p>在O(n^3)基础上做了一些调整</p>
<p>26、简述diff算法过程：</p>
<p>答案：</p>
<ul>
<li>patch(elem, vnode) 和 patch(vnode, newVnode)</li>
<li>patchVnode 和 addVnode 和 removeVnode</li>
<li>updateChildren(key 的重要性)</li>
</ul>
<p>27、Vue 常见性能优化方式</p>
<p>答案：</p>
<ul>
<li>合理使用v-show 和 v-if</li>
<li>合理使用computed</li>
<li>v-for 时要加key，以及避免和 v-if 同时使用</li>
<li>自定义事件、DOM 事件及时销毁</li>
<li>合理使用异步组件</li>
<li>合理使用keep-alive</li>
<li>data层级不要太深（因为深度监听一次性监听到底）</li>
<li>使用 vue-loader 在开发环境做模板编译（预编译）</li>
<li>webpack层面的优化</li>
<li>前端通用的性能优化，如果图片懒加载</li>
<li>使用 SSR</li>
</ul>
<p>28、vuex</p>
<p>vuex 是一个专门为 vue.js 应用程序开发的状态管理模式,它采用集中式存储管理应用的所有组件的状态,并以相应的规则保证状态以一种可预测的方式发生变化.</p>
<p>构建中大型单页应用是这个状态管理应该包含以下几个部分:</p>
<ul>
<li>state,驱动应用的数据源</li>
<li>view,以声明方式将state映射到视图</li>
<li>actions,响应在view上的用户输入导致的状态变化</li>
</ul>
<p>几个基本概念(属性):</p>
<ol>
<li>state:单一状态树,储存的单一状态,是储存的基本数据.vuex 的状态储存是响应式的</li>
<li>getters:可以认为是 store的计算属性,对 state加工,是派生出来的数据,返回值会根据它的依赖被缓存起来,且只有当它的依赖值发生了改变才会重新计算</li>
<li>mutation:更改 vuex 的store中的状态的唯一方法是提交 mutation(mutation提交修改状态).每个mutation 都有一个字符串的事件类型(type)和一个回调函数(handler),这个回调函数就是我们实际进行状态更改的地方,并且它会接受 state 作为第一个参数,使用 store.commit, (mutation是同步的)</li>
<li>action: 像一个装饰器,action提交的是mutation,而不是直接更改状态,action可以包含任意异步操作,通过store.dispatch 方法触发,也可以使用 mapAction</li>
<li>module: 是 store 分割的模块,每个模块拥有直接的 state,getter,mutation,action, 甚至是嵌套子模块 – 从上至下进行同样方式的分割模块内部的 action,局部状态通过 context.state暴露出来,根节点则为 context.rootState</li>
</ol>
<p>用于Vue 组件(API):</p>
<ul>
<li>dispatch</li>
<li>commit</li>
<li>mapState</li>
<li>mapGetters</li>
<li>mapMutations</li>
<li>mapActions</li>
</ul>
<p>vuex设计思想,借鉴了 Flux,Redux,将数据存放到全局的store,再将 store挂载到每个 vue实例组件中,利用 vue.js 的细粒对数据响应机制来进行高效的状态更新</p>
<p>vuex的store是如何挂载注入到组件中的呢?</p>
<ol>
<li>在vue 项目中先安装 vuex</li>
<li>利用vue 的插件机制,使用 vue.use(vuex)时,会调用 vuex 的install方法,安装 vuex</li>
<li>applyMixin 方法使用 vue 混入机制,vue的生命周期 beforeCreate 钩子函数混入 vuexInit 方法</li>
</ol>
<p>vuex是利用 vue 的 mixin 混入机制,在beforeCreate 钩子函数混入 vuexInit 方法,vuexInit 方法实现了 store 注入 vue 组件实例,并注册了 vuex store 的引用属性 $store</p>
<p>vuex 的state 和 getter 是如何映射到各个组件实例中响应式更新状态的?</p>
<p>vuex 的state 状态是响应式,是借助 vue的data是响应式,将 state存入vue实例组件的data中;vuex 的getters则是借助 vue的计算属性 computed 实现数据实时监听</p>
<h3 id="Webpack-面试题"><a href="#Webpack-面试题" class="headerlink" title="Webpack 面试题"></a>Webpack 面试题</h3><p>1、前端代码为何要进行构建和打包</p>
<p>答案：</p>
<p>代码方面：</p>
<ul>
<li>体积更小（Tree-Shaking、压缩、合并），加载更快</li>
<li>编译高级语言或语法（TS,ES6+,模块化，scss）</li>
<li>兼容性和错误检查（Polyfilll, postcss, eslint）</li>
</ul>
<p>　　研发流程方面：</p>
<ul>
<li>统一、高效的开发环境</li>
<li>统一的构建流程和产出标准</li>
<li>集成公司构建规范（体测、上线等）</li>
</ul>
<p>2、module、chunk、bundle分别是什么意思，有何区别</p>
<p>答案：</p>
<ul>
<li>module – 各个源码文件，webpack 中一切皆模块</li>
<li>chunk – 多模块合并成的，如 entry import() splitChunk</li>
<li>bundle – 最终的输出文件</li>
</ul>
<p>3、loader 和 plugin 的区别</p>
<p>答案：</p>
<p>loader：模块转换器，如 less –&gt; css, 如识别 js 结尾的，css 结尾的，图片格式结尾的，通过 loader 转换成相应的文件格式</p>
<p>plugin：扩展插件，如 HtmlWebpackPlugin</p>
<p>常见 loader 和 plugin：</p>
<p><a target="_blank" rel="noopener" href="https://www.webpackjs.com/loaders/%EF%BC%8C">https://www.webpackjs.com/loaders/，</a></p>
<p>本人在项目中常用到的loader有</p>
<ol>
<li>babel-loader – This package allows transpiling JavaScript files using <a target="_blank" rel="noopener" href="https://github.com/babel/babel">Babel</a> and <a target="_blank" rel="noopener" href="https://github.com/webpack/webpack">webpack</a>.</li>
<li>css-loader – <code>css-loader</code> 解释(interpret) <code>@import</code> 和 <code>url()</code> ，会 <code>import/require()</code> 后再解析(resolve)它们。引用资源的合适 loader 是 <a target="_blank" rel="noopener" href="https://www.webpackjs.com/loaders/file-loader/">file-loader</a>和 <a target="_blank" rel="noopener" href="https://www.webpackjs.com/loaders/url-loader/">url-loade</a></li>
<li>expose-loader – The expose loader adds modules to the global object. This is useful for debugging, or <a target="_blank" rel="noopener" href="https://webpack.js.org/guides/shimming/">supporting libraries that depend on libraries in globals</a>.，模块必须在你的 bundle 中被 <code>require()</code> 过</li>
<li>file-loader – Instructs webpack to emit the required object as file and to return its public URL</li>
<li>json-loader – 注意：由于 <code>webpack &gt;= v2.0.0</code> 默认支持导入 JSON 文件。如果你使用自定义文件扩展名，你可能仍然需要使用此 loader。See the <a target="_blank" rel="noopener" href="https://webpack.js.org/guides/migrating/#json-loader-is-not-required-anymore">v1.0.0 -&gt; v2.0.0 Migration Guide</a> for more information</li>
<li>less-loader – Compiles Less to CSS.</li>
<li>postcss-loader – Loader for <a target="_blank" rel="noopener" href="http://webpack.js.org/">webpack</a> to process CSS with <a target="_blank" rel="noopener" href="http://postcss.org/">PostCSS</a></li>
<li>style-loader – Adds CSS to the DOM by injecting a <code>&lt;style&gt;</code> tag</li>
<li>url-loader – Loads files as <code>base64</code> encoded URL</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://www.webpackjs.com/plugins/">https://www.webpackjs.com/plugins/</a></p>
<p>本人在项目中常用的 plugin 有：</p>
<ol>
<li>HtmlWebpackPlugin（html-webpack-plugin） – <a target="_blank" rel="noopener" href="https://github.com/jantimon/html-webpack-plugin"><code>HtmlWebpackPlugin</code></a>简化了HTML文件的创建，以便为你的webpack包提供服务。这对于在文件名中包含每次会随着编译而发生变化哈希的 webpack bundle 尤其有用。 你可以让插件为你生成一个HTML文件，使用<a target="_blank" rel="noopener" href="https://lodash.com/docs#template">lodash模板</a>提供你自己的模板，或使用你自己的<a target="_blank" rel="noopener" href="https://www.webpackjs.com/loaders">loader</a></li>
<li>ExtractTextWebpackPlugin（extract-text-webpack-plugin）– Extract text from a bundle, or bundles, into a separate file.</li>
<li>CopyWebpackPlugin（copy-webpack-plugin）– Copies individual files or entire directories to the build directory</li>
<li>UglifyjsWebpackPlugin（uglifyjs-webpack-plugin）– This plugin uses <a target="_blank" rel="noopener" href="https://github.com/mishoo/UglifyJS2/tree/harmony">UglifyJS v3 </a><a target="_blank" rel="noopener" href="https://npmjs.com/package/uglify-es">(<code>uglify-es</code>)</a> to minify your JavaScript</li>
<li>DllPlugin – <code>DLLPlugin</code> 和 <code>DLLReferencePlugin</code> 用某种方法实现了拆分 bundles，同时还大大提升了构建的速度。</li>
<li>IgnorePlugin – 防止在 <code>import</code> 或 <code>require</code> 调用时，生成以下正则表达式匹配的模块：</li>
</ol>
<ul>
<li><ul>
<li><ul>
<li><code>requestRegExp</code> 匹配(test)资源请求路径的正则表达式。</li>
<li><code>contextRegExp</code> （可选）匹配(test)资源上下文（目录）的正则表达式。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>4、babel 和 webpack 的区别</p>
<p>答案：</p>
<ul>
<li>Babel –&gt; JS 新语法编译工具，不关心模块化</li>
<li>webpack –&gt; 打包构建工具，是多个 loader plugin的集合</li>
</ul>
<p>5、webpack 如何实现懒加载</p>
<p>答案：</p>
<p>import()</p>
<p>结合Vue React 异步组件</p>
<p>结合vue-router React-router 异步加载路由</p>
<p>6、为何 Proxy 不能被 Polyfill</p>
<p>答案：</p>
<p>如class 可以用 function 模拟</p>
<p>如 Promise 可以用 callback 模拟</p>
<p>但 Proxy 的功能用 Object.defineProperty 无法模拟（没有任何一个语法可以模拟 Proxy）</p>
<p>7、如何产出一个lib</p>
<p>答案：</p>
<p><img src="https://img2020.cnblogs.com/blog/2086015/202009/2086015-20200902123515539-690993864.png" alt="img"></p>
<p>8、webpack 常见性能优化</p>
<p>答案：</p>
<ul>
<li>webpack 优化构建速度（可用于生产）</li>
</ul>
<ol>
<li>优化 babel-loader</li>
<li>IgnorePlugin</li>
<li>noParse</li>
<li>happyPack</li>
<li>ParallelUgligyPlugin</li>
</ol>
<ul>
<li>webpack 优化构建速度（不可用于生产）</li>
</ul>
<ol>
<li>自动刷新</li>
<li>热更新</li>
<li>DllPlugin</li>
</ol>
<ul>
<li>webpack 优化产出代码</li>
</ul>
<ol>
<li>小图片 base64 编码</li>
<li>bundle 加 hash</li>
<li>懒加载</li>
<li>提取公共代码</li>
<li>使用 CDN 加速</li>
<li>IgnorePlugin</li>
<li>使用 Production</li>
<li>Scope Hosting</li>
</ol>
<p>9、babel-runtime 和 babel-polyfill 的区别</p>
<p>答案：</p>
<ul>
<li>babel-polyfill 会污染全局</li>
<li>babel-runtime 不会污染全局</li>
<li>产出第三方 lib 要用 babel-runtime</li>
</ul>
<p>人生也有涯 而知也无涯 以有涯随无涯 殆已！ –庄子<br>部分内容转载自网络，侵立删！如有错误，请指正！</p>
<p>1、手写jsonp的实现<br>参考自： <a target="_blank" rel="noopener" href="http://www.qdfuns.com/notes/16738/1b6ad6125747d28592a53a960b44c6f4.html">http://www.qdfuns.com/notes/16738/1b6ad6125747d28592a53a960b44c6f4.html</a></p>
<p>先说说JSONP是怎么产生的：</p>
<p>其实网上关于JSONP的讲解有很多，但却千篇一律，而且云里雾里，对于很多刚接触的人来讲理解起来有些困难，着用自己的方式来阐释一下这个问题，看看是否有帮助。</p>
<p>1、一个众所周知的问题，Ajax直接请求普通文件存在跨域无权限访问的问题，甭管你是静态页面、动态网页、web服务、WCF，只要是跨域请求，一律不准。</p>
<p>2、不过我们又发现，Web页面上调用js文件时则不受是否跨域的影响（不仅如此，我们还发现凡是拥有”src”这个属性的标签都拥有跨域的能力，比如script、img、iframe）。</p>
<p>3、于是可以判断，当前阶段如果想通过纯web端（ActiveX控件、服务端代理、属于未来的HTML5之Websocket等方式不算）跨域访问数据就只有一种可能，那就是在远程服务器上设法把数据装进js格式的文件里，供客户端调用和进一步处理。</p>
<p>4、恰巧我们已经知道有一种叫做JSON的纯字符数据格式可以简洁的描述复杂数据，更妙的是JSON还被js原生支持，所以在客户端几乎可以随心所欲的处理这种格式的数据。</p>
<p>5、这样子解决方案就呼之欲出了，web客户端通过与调用脚本一模一样的方式，来调用跨域服务器上动态生成的js格式文件（一般以JSON为后缀），显而易见，服务器之所以要动态生成JSON文件，目的就在于把客户端需要的数据装入进去。</p>
<p>6、客户端在对JSON文件调用成功之后，也就获得了自己所需的数据，剩下的就是按照自己需求进行处理和展现了，这种获取远程数据的方式看起来非常像AJAX，但其实并不一样。</p>
<p>7、为了便于客户端使用数据，逐渐形成了一种非正式传输协议，人们把它称作JSONP，该协议的一个要点就是允许用户传递一个callback参数给服务端，然后服务端返回数据时会将这个callback参数作为函数名来包裹住JSON数据，这样客户端就可以随意定制自己的函数来自动处理返回数据了。</p>
<p>JSONP的客户端具体实现：<br>1、我们知道，哪怕跨域js文件中的代码（当然指符合web脚本安全策略的），web页面也是可以无条件执行的。<br>远程服务器remoteserver.com根目录下有个remote.js文件代码如下：</p>
<p>alert(‘我是远程文件’);<br>1<br>本地服务器localserver.com下有个jsonp.html页面代码如下：</p>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <title></title>
    <script type="text/javascript" src="http://remoteserver.com/remote.js"></script>
</head>
<body>

</body>
</html>
1
2
3
4
5
6
7
8
9
10
毫无疑问，页面将会弹出一个提示窗体，显示跨域调用成功。

<p>2、现在我们在jsonp.html页面定义一个函数，然后在远程remote.js中传入数据进行调用。</p>
<p>jsonp.html页面代码如下：</p>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <title></title>
    <script type="text/javascript">
    var localHandler = function(data){
        alert('我是本地函数，可以被跨域的remote.js文件调用，远程js带来的数据是：' + data.result);
    };
    </script>
    <script type="text/javascript" src="http://remoteserver.com/remote.js"></script>
</head>
<body>

</body>
</html>
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
remote.js文件代码如下：

<p>localHandler({“result”:”我是远程js带来的数据”});<br>1<br>运行之后查看结果，页面成功弹出提示窗口，显示本地函数被跨域的远程js调用成功，并且还接收到了远程js带来的数据。<br>很欣喜，跨域远程获取数据的目的基本实现了，但是又一个问题出现了，我怎么让远程js知道它应该调用的本地函数叫什么名字呢？毕竟是jsonp的服务者都要面对很多服务对象，而这些服务对象各自的本地函数都不相同啊？我们接着往下看。</p>
<p>3、聪明的开发者很容易想到，只要服务端提供的js脚本是动态生成的就行了呗，这样调用者可以传一个参数过去告诉服务端 “我想要一段调用XXX函数的js代码，请你返回给我”，于是服务器就可以按照客户端的需求来生成js脚本并响应了。</p>
<p>看jsonp.html页面的代码：</p>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <title></title>
    <script type="text/javascript">
    // 得到航班信息查询结果后的回调函数
    var flightHandler = function(data){
        alert('你查询的航班结果是：票价 ' + data.price + ' 元，' + '余票 ' + data.tickets + ' 张。');
    };
    // 提供jsonp服务的url地址（不管是什么类型的地址，最终生成的返回值都是一段javascript代码）
    var url = "http://flightQuery.com/jsonp/flightResult.aspx?code=CA1998&callback=flightHandler";
    // 创建script标签，设置其属性
    var script = document.createElement('script');
    script.setAttribute('src', url);
    // 把script标签加入head，此时调用开始
    document.getElementsByTagName('head')[0].appendChild(script); 
    </script>
</head>
<body>
</body>
</html>
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
这次的代码变化比较大，不再直接把远程js文件写死，而是编码实现动态查询，而这也正是jsonp客户端实现的核心部分，本例中的重点也就在于如何完成jsonp调用的全过程。
我们看到调用的url中传递了一个code参数，告诉服务器我要查的是CA1998次航班的信息，而callback参数则告诉服务器，我的本地回调函数叫做flightHandler，所以请把查询结果传入这个函数中进行调用。
OK，服务器很聪明，这个叫做flightResult.aspx的页面生成了一段这样的代码提供给jsonp.html

<p>（服务端的实现这里就不演示了，与你选用的语言无关，说到底就是拼接字符串）：<br>HTML 代码</p>
<p>flightHandler({<br>    “code”: “CA1998”,<br>    “price”: 1780,<br>    “tickets”: 5<br>});<br>1<br>2<br>3<br>4<br>5<br>我们看到，传递给flightHandler函数的是一个json，它描述了航班的基本信息。运行一下页面，成功弹出提示窗口，jsonp的执行全过程顺利完成！</p>
<p>4、到这里为止的话，相信你已经能够理解jsonp的客户端实现原理了吧？剩下的就是如何把代码封装一下，以便于与用户界面交互，从而实现多次和重复调用。</p>
<p>jQuery如何实现jsonp调用？</p>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
     <title>Untitled Page</title>
      <script type="text/javascript" src="jquery.min.js""></script>
      <script type="text/javascript">
     jQuery(document).ready(function(){ 
        $.ajax({
             type: "get",
             async: false,
             url: "http://flightQuery.com/jsonp/flightResult.aspx?code=CA1998",
             dataType: "jsonp",
             jsonp: "callback",//传递给请求处理程序或页面的，用以获得jsonp回调函数名的参数名(一般默认为:callback)
             jsonpCallback:"flightHandler",//自定义的jsonp回调函数名称，默认为jQuery自动生成的随机函数名，也可以写"?"，jQuery会自动为你处理数据
             success: function(json){
                 alert('您查询到航班信息：票价： ' + json.price + ' 元，余票： ' + json.tickets + ' 张。');
             },
             error: function(){
                 alert('fail');
             }
         });
     });
     </script>
     </head>
  <body>
  </body>
</html>
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
这里针对ajax与jsonp的异同再做一些补充说明：

<p>1、ajax和jsonp这两种技术在调用方式上”看起来”很像，目的也一样，都是请求一个url，然后把服务器返回的数据进行处理，因此jquery和ext等框架都把jsonp作为ajax的一种形式进行了封装。</p>
<p>2、但ajax和jsonp其实本质上是不同的东西。ajax的核心是通过XmlHttpRequest获取非本页内容，而jsonp的核心则是动态添加script标签来调用服务器提供的js脚本。</p>
<p>3、所以说，其实ajax与jsonp的区别不在于是否跨域，ajax通过服务端代理一样可以实现跨域，jsonp本身也不排斥同域的数据的获取。</p>
<p>4、还有就是，jsonp是一种方式或者说非强制性协议，如同ajax一样，它也不一定非要用json格式来传递数据，如果你愿意，字符串都行，只不过这样不利于用jsonp提供公开服务。</p>
<p>总而言之，jsonp不是ajax的一个特例，哪怕jquery等巨头把jsonp封装进了ajax，也不能改变这一点！</p>
<p>2、手写单链表查找倒数第k个节点<br>1、为了找出倒数第k个元素，最容易想到的办法是首先遍历一遍单链表，求出整个单链表的长度n，然后将倒数第k个，转换为正数第n-k个，接下来遍历一次就可以得到结果。但是该方法存在一个问题，即需要对链表进行两次遍历，第一次遍历用于求解单链表的长度，第二次遍历用于查找正数第n-k个元素。<br>这种思路的时间复杂度是O(n)，但需要遍历链表两次。</p>
<p>2、如果我们在遍历时维持两个指针，第一个指针从链表的头指针开始遍历，在第k-1步之前，第二个指针保持不动；在第k-1步开始，第二个指针也开始从链表的头指针开始遍历。由于两个指针的距离保持在k-1，当第一个（走在前面的）指针到达链表的尾结点时，第二个指针（走在后面的）指针正好是倒数第k个结点。这种思路只需要遍历链表一次。对于很长的链表，只需要把每个结点从硬盘导入到内存一次。因此这一方法的时间效率前面的方法要高。</p>
<p>class Node{<br>    Node next=null;<br>    int data;<br>    public Node(int data){<br>        this.data=data;<br>    }<br>}<br>public class MyLinkedList {</p>
<pre><code>Node head=null;//链表头的引用
public Node findElem(Node head,int k)&#123;
    if(k&lt;1||k&gt;this.length())&#123;
        return null;
    &#125;
    Node p1=head;
    Node p2=head;
    for(int i=0;i&lt;k;i++)
        p1=p1.next;
    while(p1!=null)&#123;
        p1=p1.next;
        p2=p2.next;
    &#125;
    return p2;
&#125;
public static void main(String[] args) &#123;
    
    MyLinkedList list=new MyLinkedList();
    list.addNode(1);
    list.addNode(2);
    list.addNode(3);
    list.addNode(4);
    list.addNode(5);
    MyLinkedList p=new MyLinkedList();
    p.head=list.findElem(list.head, 3);
    p.printList();
    
&#125;
</code></pre>
<p>}<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>3、http请求头，请求体，cookie在哪个里面？url在哪里面？<br>参考菜鸟教程HTTP专栏：<a target="_blank" rel="noopener" href="http://www.runoob.com/http/http-tutorial.html">http://www.runoob.com/http/http-tutorial.html</a><br>人人三面的时候问我http请求头都有哪些值，答不上来。。GG<br>客户端请求消息</p>
<p>服务器响应消息<br>HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。</p>
<p>实例<br>下面实例是一点典型的使用GET来传递数据的实例：<br>客户端请求：</p>
<p>GET /hello.txt HTTP/1.1<br>User-Agent: curl/7.16.3 libcurl/7.16.3 OpenSSL/0.9.7l zlib/1.2.3<br>Host: <a target="_blank" rel="noopener" href="http://www.example.com/">www.example.com</a><br>Accept-Language: en, mi<br>1<br>2<br>3<br>4<br>服务端响应:</p>
<p>HTTP/1.1 200 OK<br>Date: Mon, 27 Jul 2009 12:28:53 GMT<br>Server: Apache<br>Last-Modified: Wed, 22 Jul 2009 19:15:56 GMT<br>ETag: “34aa387-d-1568eb00”<br>Accept-Ranges: bytes<br>Content-Length: 51<br>Vary: Accept-Encoding<br>Content-Type: text/plain<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>输出结果：</p>
<p>Hello World! My payload includes a trailing CRLF.<br>1<br>4、原型链的解释<br>饿了么面试的时候问到了，用友也问到了。没答好，GG.</p>
<p>5、对闭包的理解，实现一个暴露内部变量，而且外部可以访问修改的函数<br>闭包的作用：<br>匿名自执行函数、缓存、实现封装（主要作用）、实现面向对象中的对象</p>
<p>var person = function(){<br>    //变量作用域为函数内部，外部无法访问<br>    var name = “default”;<br>    return {<br>       getName : function(){<br>           return name;<br>       },<br>       setName : function(newName){<br>           name = newName;<br>       }<br>    }<br>}();<br>print(person.name);//直接访问，结果为undefined<br>print(person.getName());<br>person.setName(“a”);<br>print(person.getName());<br>//得到结果如下：<br>undefined<br>default<br>a<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>6、基本的数据类型<br>5个简单数据类型（基本数据类型）+ 1个复杂数据类型<br>undefiend, number string null boolean + object<br>ES6 新增Symbol</p>
<p>7、基本的两列自适应布局<br>左定右适应：</p>
<p>#div1{<br>    width: 100px;<br>    display: inline-block;<br>    background-color: black;<br>}<br>#div2{<br>    display: inline-block;<br>    position: absolute;<br>    left: 100px;<br>    right: 0px;<br>    background-color: red;<br>}<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>8、unix中常用的命令行<br>虽然上过linux课，但是命令忘得差不多了 尴尬。。。</p>
<p>9、OSI模型，HTTP,TCP,UDP分别在哪些层<br>这个可以参考我另一个博客：<br><a target="_blank" rel="noopener" href="http://blog.csdn.net/qq_22944825/article/details/78160659">http://blog.csdn.net/qq_22944825/article/details/78160659</a><br>OSI：物理层-数据链路层-网络层-传输层-会话层-表现层-应用层</p>
<p>10、解释平衡二叉树，以及在数据结构中的应用（红黑树）<br>11、快排的时间复杂度和空间复杂度<br>一个特别好的总结的博客：</p>
<p>12、手写一个jQuery插件<br>1、$.extend(src)<br>　　该方法就是将src合并到jquery的全局对象中去，如：</p>
<p> $.extend({<br>      hello:function(){alert(‘hello’);}<br>      });<br>1<br>2<br>3<br>2、$.fn.extend(src)<br>　　该方法将src合并到jquery的实例对象中去，如:</p>
<p> $.fn.extend({<br>  hello:function(){alert(‘hello’);}<br> });<br>1<br>2<br>3<br>13、在jquery方法和原型上面添加方法的区别和实现，以及jquery对象的实现<br>参考上一个问题答案~</p>
<p>使用jquery的第一件事就是要使用jquery对象，jquery对象和javascript中的DOM对象是不同的。</p>
<p>什么是jquery对象？jquery将一个DOM对象转化为jquery对象后就可以使用jquery类库提供的各种函数。可以将jquery对象理解为一个类，并且封装了很多的方法，而且可以动态的通过加载插件扩展这个类，类似于C#中的分布类partial class。</p>
<p>除了jQuery工具函数，jQuery的操作都是从jQuery对象开始。比如：</p>
<pre><code>attr(key,value)

&lt;img id=&quot;myphoto&quot; alt=&quot;my photo&quot; src=&quot;&quot;/&gt;

$(&quot;#myphoto&quot;).attr(&quot;src&quot;,&quot;/pic/1.jpg&quot;);
</code></pre>
<p>1<br>2<br>3<br>4<br>5<br>jQuery对象是一个特殊的集合对象。即使只有一个元素，jQuery对象仍然是一个集合。说其特殊是因为实际上jQuery对象是包含一个集合对象和各种函数的类。</p>
<p>14、手写一个递归函数<br> function fact(num) {<br>    if (num &lt;= 1) {<br>        return 1;<br>    } else {<br>        return num * fact(num - 1);<br>    }<br>}<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>以下代码可导致出错：</p>
<p>var anotherFact = fact;<br> fact = null;<br> alert(antherFact(4)); //出错<br>1<br>2<br>3<br>由于fact已经不是函数了，所以出错。<br>用arguments.callee可解决问题，这是一个指向正在执行的函数的指针,arguments.callee返回正在被执行的对现象。<br>新的函数为：</p>
<p>function fact(num) {<br>            if (num &lt;= 1) {<br>                return 1;<br>            } else {<br>                return num * arguments.callee(num - 1); //此处更改了。<br>            }<br>}<br>var anotherFact = fact;<br>fact = null;<br>alert(antherFact(4)); //结果为24.<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>15、对前端路由的理解？前后端路由的区别？<br>前端的路由和后端的路由在实现技术上不一样，但是原理都是一样的。在 HTML5 的 history API 出现之前，前端的路由都是通过 hash 来实现的，hash 能兼容低版本的浏览器。</p>
<p><a target="_blank" rel="noopener" href="http://10.0.0.1/">http://10.0.0.1/</a><br><a target="_blank" rel="noopener" href="http://10.0.0.1/#/about">http://10.0.0.1/#/about</a><br><a target="_blank" rel="noopener" href="http://10.0.0.1/#/concat">http://10.0.0.1/#/concat</a><br>1<br>2<br>3<br>服务端路由：每跳转到不同的URL，都是重新访问服务端，然后服务端返回页面，页面也可以是服务端获取数据，然后和模板组合，返回HTML，也可以是直接返回模板HTML，然后由前端JS再去请求数据，使用前端模板和数据进行组合，生成想要的HTML。</p>
<p>前端路由：每跳转到不同的URL都是使用前端的锚点路由，实际上只是JS根据URL来操作DOM元素，根据每个页面需要的去服务端请求数据，返回数据后和模板进行组合，当然模板有可能是请求服务端返回的，这就是 SPA 单页程序。</p>
<p>在js可以通过window.location.hash读取到路径加以解析之后就可以响应不同路径的逻辑处理。</p>
<p>history 是 HTML5 才有的新 API，可以用来操作浏览器的 session history (会话历史)。基于 history 来实现的路由可以和最初的例子中提到的路径规则一样。</p>
<p>H5还新增了一个hashchange事件，也是很有用途的一个新事件：</p>
<p>当页面hash(#)变化时，即会触发hashchange。锚点Hash起到引导浏览器将这次记录推入历史记录栈顶的作用，window.location对象处理“#”的改变并不会重新加载页面，而是将之当成新页面，放入历史栈里。并且，当前进或者后退或者触发hashchange事件时，我们可以在对应的事件处理函数中注册ajax等操作！<br>但是hashchange这个事件不是每个浏览器都有，低级浏览器需要用轮询检测URL是否在变化，来检测锚点的变化。当锚点内容(location.hash)被操作时，如果锚点内容发生改变浏览器才会将其放入历史栈中，如果锚点内容没发生变化，历史栈并不会增加，并且也不会触发hashchange事件。</p>
<p>16、介绍一下webpack和gulp，以及项目中具体的使用<br>17、你对es6的了解<br>参见阮大大的博客<br><a target="_blank" rel="noopener" href="http://es6.ruanyifeng.com/">http://es6.ruanyifeng.com/</a></p>
<p>18、解释一下vue和react，以及异同点<br>异同点：vue官网给过答案<br><a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/comparison.html">https://cn.vuejs.org/v2/guide/comparison.html</a></p>
<p>只简单的用过vue，用vue写了一个日程表，请赐教哦~</p>
<p><a target="_blank" rel="noopener" href="https://yyywwwqqq.coding.me/schedule/dist/">https://yyywwwqqq.coding.me/schedule/dist/</a></p>
<p>源码地址：<br><a target="_blank" rel="noopener" href="https://coding.net/u/yyywwwqqq/p/schedule/git">https://coding.net/u/yyywwwqqq/p/schedule/git</a></p>
<p>19、关于平衡二叉树<br>平衡二叉搜索树（Self-balancing binary search tree）又被称为AVL树（有别于AVL算法），且具有以下性质：它是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树，同时，平衡二叉树必定是二叉搜索树，反之则不一定。平衡二叉树的常用实现方法有红黑树、AVL、替罪羊树、Treap、伸展树等。 最小二叉平衡树的节点的公式如下 F(n)=F(n-1)+F(n-2)+1 这个类似于一个递归的数列，可以参考Fibonacci(斐波那契)数列，1是根节点，F(n-1)是左子树的节点数量，F(n-2)是右子树的节点数量。</p>
<p>20、前后端分离的意义以及对前端工程化的理解<br>21、使用css实现一个三角形<br>利用border去画~<br>先看一下border的布局，如图：</p>
<p>所以三角形：<br>1.设置宽度、高度为0</p>
<p>2.不设置border-top</p>
<p>3.设置左右border颜色为transparent–透明</p>
<p>22、用promise手写ajax<br>function getJson(url){<br>    return new Promise((resolve, reject) =&gt;{<br>        var xhr = new XMLHttpRequest();<br>        xhr.open(‘open’, url, true);<br>        xhr.onreadystatechange = function(){<br>            if(this.readyState == 4){<br>                if(this.status = 200){<br>                    resolve(this.responseText, this)<br>                }else{<br>                    var resJson = { code: this.status, response: this.response }<br>                    reject(resJson, this)<br>                }<br>            }<br>        }<br>        xhr.send()<br>    })<br>}</p>
<p>function postJSON(url, data) {<br>    return new Promise( (resolve, reject) =&gt; {<br>        var xhr = new XMLHttpRequest()<br>        xhr.open(“POST”, url, true)<br>        xhr.setRequestHeader(“Content-type”, “application/x-www-form-urlencoded”);</p>
<pre><code>    xhr.onreadystatechange = function () &#123;
        if (this.readyState === 4) &#123;
            if (this.status === 200) &#123;
                resolve(JSON.parse(this.responseText), this)
            &#125; else &#123;
                var resJson = &#123; code: this.status, response: this.response &#125;
                reject(resJson, this)
            &#125;
        &#125;
    &#125;

    xhr.send(JSON.stringify(data))
&#125;)
</code></pre>
<p>}</p>
<p>getJSON(‘/api/v1/xxx’)    // =&gt; 这里面是就try<br>.catch( error =&gt; {<br>  // dosomething          // =&gt; 这里就是catch到了error，如果处理error以及返还合适的值<br>})<br>.then( value =&gt; {<br>  // dosomething          // 这里就是final<br>})<br>23、手写一个类的继承，并解释一下<br>继承的形式有很多中，js高程里面归纳了其中，我简单说一下前三种。<br>1.原型继承</p>
<p>function Parent(){<br>    this.name = “parent”;<br>}<br>Parent.prototype.getName = function(){<br>    return this.name;<br>}</p>
<p>function Child(){<br>    this.name = “child”;<br>}</p>
<p>//继承parent<br>Child.prototype = new Parent();<br>2.构造函数继承</p>
<p>function Animal(name){<br>    this.name = name;<br>    this.eat = function(){<br>        consoel.log(this.name + “吃饭”);<br>    }<br>}<br>var cat = new Animal(“maomi”);<br>cat.name;<br>cat.eat();<br>缺点是：<br>3.组合继承</p>
<p>24、解释一下call函数和apply函数的作用，以及用法<br>改变this的指向。<br>this的指向问题，在你不知道的js这本书中（神书）做了四点归纳：<br>1.默认绑定 （指 直接调用 foo(), this指向window）<br>2.隐式绑定（obj.foo(), this指向obj 这里会出现很多坑，下面的问题应该会有解答）<br>3.显示绑定（利用call、apply、bind改变this）<br>4.new（var cat = new Animal() , this指向cat对象）</p>
<p>25、你说自己抗压能力强，具体表现在哪里？<br>略<br>26、对前端前景的展望，以后前端会怎么发展<br>27、手写第一次面试没有写出来的链表问题，要求用es6写<br>28、平时是怎么学技术的？<br>29、平时大学里面时间是怎么规划的？<br>30、接下来有什么计划？这个学期和下个学期的计划是？<br>31、项目中遇到的难点，或者你学习路上的难点<br>32、你是通过什么方法和途径来学习前端的<br>33、手写一个简单遍历算法<br>34、解释一下react和vue，以及区别<br>35、你在团队中更倾向于什么角色？<br>36、对java的理解<br>37、介绍node.js，并且介绍你用它做的项目<br>38、手写一个js的深克隆<br>function deepCopy(obj){<br>    //判断是否是简单数据类型，<br>    if(typeof obj == “object”){<br>        //复杂数据类型<br>        var result = obj.constructor == Array ? [] : {};<br>        for(let i in obj){<br>            result[i] = typeof obj[i] == “object” ? deepCopy(obj[i]) : obj[i];<br>        }<br>    }else {<br>        //简单数据类型 直接 == 赋值<br>        var result = obj;<br>    }<br>    return result;<br>}<br>39、for函数里面setTimeout异步问题<br>40、手写归并排序<br>&lt;1&gt;.长度为n(n&gt;1),把该输入序列分成两个长度为n/2的子序列；<br>&lt;2&gt;.对这两个子序列分别采用归并排序，直到长度n小于2；<br>&lt;3&gt;.将两个排序好的子序列合并成一个最终的排序序列。</p>
<p>function mergeSort(arr) {<br>    var len = arr.length;<br>    if(len &lt; 2) {<br>        return arr;<br>    } else {<br>        middle = Math.floor(len / 2);<br>        var left = arr.slice(0, middle);<br>        var right = arr.splice(middle);<br>        return merge(mergeSort(left), mergeSort(right));<br>    }</p>
<p>}</p>
<p>function merge(left, right) {<br>    var result = [];<br>    while(left.length &amp;&amp; right.length) {<br>        left[0] &gt; right[0] ? result.push(right.shift()): result.push(left.shift());<br>    }<br>    if(left.length) {<br>        result = result.concat(left);<br>    }<br>    if(right.length) {<br>        result = result.concat(right);<br>    }<br>    return result;<br>}<br>41、介绍自己的项目<br>略</p>
<p>42、实现两个排序数组的合并<br>参考42题中的merge函数。</p>
<p>43、手写一个原生ajax<br>ajax：一种请求数据的方式，不需要刷新整个页面；<br>ajax的技术核心是 XMLHttpRequest 对象；<br>ajax 请求过程：创建 XMLHttpRequest 对象、连接服务器、发送请求、接收响应数据；</p>
<p>一个在stackoverflow的高分回答结合上面的代码，给出get和post的两种不同请求方法：</p>
<p>var ajax = {};<br>ajax.x = function () {<br>    if (typeof XMLHttpRequest !== ‘undefined’) {<br>        return new XMLHttpRequest();<br>    }<br>    var versions = [<br>    “MSXML2.XmlHttp.6.0”,<br>    “MSXML2.XmlHttp.5.0”,<br>    “MSXML2.XmlHttp.4.0”,<br>    “MSXML2.XmlHttp.3.0”,<br>    “MSXML2.XmlHttp.2.0”,<br>    “Microsoft.XmlHttp”<br>    ];</p>
<pre><code>var xhr;
for (var i = 0; i &lt; versions.length; i++) &#123;
    try &#123;
        xhr = new ActiveXObject(versions[i]);
        break;
    &#125; catch (e) &#123;
    &#125;
&#125;
return xhr;
</code></pre>
<p>};</p>
<p>ajax.send = function (url, method, data, success,fail,async) {<br>    if (async === undefined) {<br>        async = true;<br>    }<br>    var x = ajax.x();<br>    x.open(method, url, async);<br>    x.onreadystatechange = function () {<br>        if (x.readyState == 4) {<br>            var status = x.status;<br>            if (status &gt;= 200 &amp;&amp; status &lt; 300) {<br>                success &amp;&amp; success(x.responseText,x.responseXML)<br>            } else {<br>                fail &amp;&amp; fail(status);<br>            }</p>
<pre><code>    &#125;
&#125;;
if (method == &#39;POST&#39;) &#123;
    x.setRequestHeader(&#39;Content-type&#39;, &#39;application/x-www-form-urlencoded&#39;);
&#125;
x.send(data)
</code></pre>
<p>};</p>
<p>ajax.get = function (url, data, callback, fail, async) {<br>    var query = [];<br>    for (var key in data) {<br>        query.push(encodeURIComponent(key) + ‘=’ + encodeURIComponent(data[key]));<br>    }<br>    ajax.send(url + (query.length ? ‘?’ + query.join(‘&amp;’) : ‘’), ‘GET’, null, success, fail, async)<br>};</p>
<p>ajax.post = function (url, data, callback, fail, async) {<br>    var query = [];<br>    for (var key in data) {<br>        query.push(encodeURIComponent(key) + ‘=’ + encodeURIComponent(data[key]));<br>    }<br>    ajax.send(url,’POST’, query.join(‘&amp;’), success, fail, async)<br>};<br>使用方法：GET</p>
<p>ajax.get(‘/test.php’, {foo: ‘bar’}, function(response,xml) {<br>    //success<br>},<br>function(status){<br>    //fail<br>});<br>POST</p>
<p>ajax.post(‘/test.php’, {foo: ‘bar’}, function(response,xml) {<br>    //succcess</p>
<p>},function(status){<br>    //fail</p>
<p>});<br>44、手写一个promise版的ajax<br>45、手写实现一个promise<br>46、手写实现requireJS模块实现<br>47、手写实现jquery里面的insertAfter<br>48、react和vue的介绍以及异同<br>49、AMD和CMD，commonJS的区别<br>50、介绍一下backbone<br>51、了解过SEO吗？</p>
<p>52、低版本浏览器不支持HTML5标签怎么解决？</p>
<p>53、用js使低版本浏览器支持HTML5标签 底层是怎么实现的？</p>
<p>54、实现一个布局：左边固定宽度为200，右边自适应，而且滚动条要自动选择只出现最高的那个</p>
<p>55、画出盒子模型，要使谷歌浏览器的盒子模型显示得跟IE浏览器一致（让谷歌跟ie一致，不是ie跟谷歌一致），该怎么做？</p>
<p>56、手写JS实现类继承，讲原型链原理，并解释new一个对象的过程都发生了什么</p>
<p>57、Array对象自带的方法，一一列举</p>
<p>58、若干个数字，怎么选出最大的五个</p>
<p>59、Array对象自带的排序函数底层是怎么实现的？</p>
<p>60、常用的排序算法有哪些，介绍一下选择排序</p>
<p>61、了解navigator对象吗？</p>
<p>62、手写一个正则表达式，验证邮箱</p>
<p>63、link和@import引入CSS的区别？</p>
<p>64、刚才说有些浏览器不兼容@import，具体指哪些浏览器？</p>
<p>65、介绍一下cookie,localstorage,sessionstorage,session</p>
<p>66、jquery绑定click的方法有几种</p>
<p>67、你的优点/竞争力</p>
<p>68、移动端适配问题</p>
<p>69、react的难点在哪里</p>
<p>70、做过css动画吗</p>
<p>71、如何优化网站</p>
<p>72、以后的规划</p>
<p>73、你做过最困难的事情是啥？</p>
<p>74、css3 html5新特性</p>
<p>75、闭包，ES6，跨域</p>
<p>76、问做过啥项目，用到什么技术，遇到什么困难</p>
<p>77、兼容性</p>
<p>78、盒子模型</p>
<p>79、Array的unshift() method的作用是什么？如何连接两个Array？如何在Array里移除一个元素？</p>
<p>80、用纸笔写一个Closure，任意形式和内容</p>
<p>81、知不知道Array-like Object？</p>
<p>82、如何用Native JavaScript来读写Cookie？</p>
<p>83、知不知道CSS Box-model？</p>
<p>84、如何做一个AJAX Request？</p>
<p>85、Cross-domain access有没有了解？</p>
<p>86、前端安全方面有没有了解？XSS和CSRF如何攻防？</p>
<p>87、HTTP Response的Header里面都有些啥？</p>
<p>88、知不知道HTTP2？</p>
<p>89、输入URL后发生了什么？</p>
<p>90、new operator实际上做了什么？</p>
<p>91、面向对象的属性有哪些？</p>
<p>92、做一个两栏布局，左边fixed width，右边responsive，用纸笔手写</p>
<p>93、讲一下AJAX Request</p>
<p>94、讲一下Cross-domain access</p>
<p>95、介绍一下做过的项目</p>
<p>96、问到了多个服务器怎么弄，架构之类的</p>
<p>97、angular的渲染流程</p>
<p>98、脏检查</p>
<p>99、nodejs的架构、优缺点、回调</p>
<p>100、css 盒模型</p>
<p>101、css 布局，左边定宽右边自适应</p>
<p>102、冒泡和捕获，事件流哪三个阶段？</p>
<p>103、实现事件代理</p>
<p>104、原型链</p>
<p>105、继承的两种方法</p>
<p>106、ajax，原生ajax的四个过程</p>
<p>107、闭包，简单说一个闭包的应用，然后闭包的主要作用是什么</p>
<p>108、css:两个块状元素上下的margin-top和margin-bottom会重叠。啥原因？怎么解决？</p>
<p>109、js：写一个递归。就是每隔5秒调用一个自身，一共100次</p>
<p>110、cookie和session有什么区别</p>
<p>111、网络分层结构</p>
<p>112、你的不足是什么？</p>
<p>113、做了那么多项目，有没有自己的归纳总结</p>
<p>114、工程怎么进行文件管理</p>
<p>115、less和sass掌握程度</p>
<p>116、Cookie 是否会被覆盖，localStorage是否会被覆盖</p>
<p>117、事件代理js实现</p>
<p>118、Css实现动画效果</p>
<p>119、Animation还有哪些其他属性</p>
<p>120、Css实现三列布局</p>
<p>121、Css实现保持长宽比1:1</p>
<p>122、Css实现两个自适应等宽元素中间空10个像素</p>
<p>123、requireJS的原理是什么</p>
<p>124、如何保持登录状态</p>
<p>125、浮动的原理以及如何清除浮动</p>
<p>126、Html的语义化</p>
<p>127、原生js添加class怎么添加，如果本身已经有class了，会不会覆盖，怎么保留？</p>
<p>128、Jsonp的原理。怎么去读取一个script里面的数据？</p>
<p>129、如果页面初始载入的时候把ajax请求返回的数据存在localStorage里面，然后每次调用的时候去localStorage里面取数，是否可行。</p>
<p>130、304是什么意思？有没有方法不请求不经过服务器直接使用缓存</p>
<p>131、http请求头有哪些字段</p>
<p>132、数组去除一个函数。用arr.splice。又问splice返回了什么？应该返回的是去除的元素。</p>
<p>133、js异步的方法（promise，generator，async）</p>
<p>134、Cookie跨域请求能不能带上</p>
<p>135、最近看什么开源项目？</p>
<p>136、commonJS和AMD</p>
<p>137、平时是怎么学习的？</p>
<p>138、为什么要用translate3d？</p>
<p>139、对象中key-value的value怎么再放一个对象？</p>
<p>140、Get和post的区别？</p>
<p>145、Post一个file的时候file放在哪的？</p>
<p>146、说说你对组件的理解</p>
<p>147、组件的html怎么进行管理</p>
<p>148、js的异步加载，promise的三种状态，ES7中的async用过么</p>
<p>149、静态属性怎么继承</p>
<p>150、js原型链的继承</p>
<p>151、jquery和zepto有什么区别</p>
<p>152、angular的双向绑定原理</p>
<p>153、angular和react的认识</p>
<p>154、MVVM是什么</p>
<p>155、移动端是指手机浏览器，还是native，还是hybrid</p>
<p>156、你用了移动端的什么库类和框架？</p>
<p>157、移动端要注意哪些？</p>
<p>158、适配有去考虑么，retina屏幕啊？</p>
<p>159、rem是什么？em是什么？如果上一层就是根root了，em和rem等价么？</p>
<p>160、怎么测试的？会自动化测试么？</p>
<p>161、你觉得你什么技术最擅长？</p>
<p>162、你平时有没有什么技术的沉淀？</p>
<p>163、单向链表怎么查找有没有环？</p>
<p>164、怎么得到一个页面的a标签？</p>
<p>165、怎么在页面里放置一个很简单的图标，不能用img和background-img？</p>
<p>166、正则表达式判断url</p>
<p>167、怎么去除字符串前后的空格</p>
<p>168、实现页面的局部刷新</p>
<p>169、绝对定位与相对定位的区别</p>
<p>170、js轮播实现思路</p>
<p>171、使用js画一个抛物线，抛物线上有个小球随着抛物线运动，有两个按钮能使小球继续运动停止运动</p>
<p>172、java五子棋，说下实现思路</p>
<p>173、如何让各种情况下的div居中(绝对定位的div,垂直居中,水平居中)？</p>
<p>174、display有哪些值？说明他们的作用</p>
<p>175、css定义的权重</p>
<p>176、requirejs实现原理</p>
<p>177、requirejs怎么防止重复加载</p>
<p>178、ES6里头的箭头函数的this对象与其他的有啥区别</p>
<p>179、tcp/udp区别</p>
<p>180、tcp三次握手过程</p>
<p>181、xss与csrf的原理与怎么防范</p>
<p>182、mysql与 MongoDB的区别</p>
<p>183、w3c事件与IE事件的区别</p>
<p>184、有没有上传过些什么npm模块</p>
<p>185、IE与W3C怎么阻止事件的冒泡</p>
<p>186、gulp底层实现原理</p>
<p>187、webpack底层实现原理</p>
<p>188、gulp与webpack区别</p>
<p>189、vuejs与angularjs的区别</p>
<p>190、vuex是用来做什么的</p>
<p>191、说下你知道的响应状态码</p>
<p>192、ajax的过程以及 readyState几个状态的含义</p>
<p>193、你除了前端之外还会些什么？</p>
<p>194、cookie与session的区别</p>
<p>195、一些关于php与java的问题</p>
<p>196、你觉得你哪个项目是你做的最好的</p>
<p>197、说说你在项目中遇到了哪些困难,是怎么解决的</p>
<p>198、前端优化你知道哪些</p>
<p>199、webpack是用来干嘛的</p>
<p>200、webpack与gulp的区别</p>
<p>201、es6与es7了解多少</p>
<p>202、说下你知道的响应状态码</p>
<p>203、看过哪些框架的源码</p>
<p>204、遇到过哪些浏览器兼容性问题</p>
<p>205、清除浮动有哪几种方式,分别说说</p>
<p>206、你知道有哪些跨域方式,分别说说</p>
<p>207、JavaScript有哪几种类型的值</p>
<p>208、使用 new操作符时具体是干了些什么</p>
<p>209、学习前端的方法以及途径</p>
<p>210、怎么实现两个大整数的相乘，说下思路</p>
<p>211、你学过数据结构没,说说你都了解些什么</p>
<p>212、你学过计算机操作系统没,说说你都了解些什么</p>
<p>213、你学过计算机组成原理没,说说你都了解些什么</p>
<p>214、你学过算法没,说说你都了解些什么</p>
<p>215、说下选择排序,冒泡排序的实现思路</p>
<p>216、用过哪些框架</p>
<p>217、让你设计一个前端css框架你怎么做</p>
<p>218、了解哪些设计模式说说看</p>
<p>219、说下你所了解的设计模式的优点</p>
<p>220、vue源码结构</p>
<p>221、状态码</p>
<p>222、浏览器缓存的区别</p>
<p>223、304与200读取缓存的区别</p>
<p>224、http请求头有哪些,说说看你了解哪些</p>
<p>225、js中this的作用</p>
<p>226、js中上下文是什么</p>
<p>227、js有哪些函数能改变上下文</p>
<p>228、你所了解的跨域的方法都说说看你了解的？</p>
<p>229、要是让你自己写一个js框架你会用到哪些设计模式</p>
<p>230、平常在项目中用到过哪些设计模式,说说看</p>
<p>231、一来给了张纸要求写js自定义事件</p>
<p>232、前端跨域的方法</p>
<p>233、call与apply的区别</p>
<p>234、h5有个api能定位你知道是哪个吗？</p>
<p>235、vue与angularjs中双向数据绑定是怎样实现的？</p>
<p>236、webpack怎样配置？</p>
<p>237、nodejs中的文件怎么读写？</p>
<p>238、link和@import有什么区别？</p>
<p>239、cookies，sessionStorage 和 localStorage 的区别</p>
<p>240、看过哪些前端的书？平时是怎么学习的</p>
<p>241、说下你所理解的mvc与mvvc</p>
<p>242、position有哪些值,说下各自的作用</p>
<p>243、写个从几个li中取下标的闭包代码</p>
<p>244、你的职业规划是怎么样的？</p>
<p>245、移动端性能优化</p>
<p>246、lazyload如何实现</p>
<p>247、点透问题</p>
<p>248、前端安全</p>
<p>249、原生js模板引擎</p>
<p>250、repaint和reflow区别</p>
<p>251、requirejs如何避免循环依赖？</p>
<p>252、实现布局：左边一张图片，右边一段文字（不是环绕）</p>
<p>253、window.onload和$(document).ready()的区别，浏览器加载转圈结束时哪个时间点？</p>
<p>254、form表单当前页面无刷新提交 target iframe</p>
<p>255、setTimeout和setInterval区别，如何互相实现？</p>
<p>256、如何避免多重回调—promise，promise简单描述一下，如何在外部进行resolve()</p>
<p>257、margin坍塌？水平方向会不会坍塌？</p>
<p>258、伪类和伪元素区别</p>
<p>259、vue如何实现父子组件通信，以及非父子组件通信</p>
<p>260、数组去重</p>
<p>261、使用flex布局实现三等分，左右两个元素分别贴到左边和右边，垂直居中</p>
<p>262、平时如何学前端的，看了哪些书，关注了哪些公众号</p>
<p>263、实现bind函数</p>
<p>264、数组和链表区别，分别适合什么数据结构</p>
<p>265、对mvc的理解</p>
<p>266、描述一个印象最深的项目，在其中担任的角色，解决什么问题</p>
<p>267、http状态码。。。401和403区别？</p>
<p>268、描述下二分查找</p>
<p>269、为什么选择前端，如何学习的，看了哪些书，《js高级程序设计》和《你不知道的js》有什么区别，看书，看博客，看公众号三者的时间是如何分配的？</p>
<p>270、如何评价BAT？</p>
<p>271、描述下在实习中做过的一个项目，解决了什么问题，在其中担任了什么角色？这个过程存在什么问题，有什么值得改进的地方？</p>
<p>272、如何看待加班，如果有个项目需要连续一个月加班，你怎么看？</p>
<p>273、遇到的压力最大的一件事是什么？如何解决的？</p>
<p>274、平时有什么爱好</p>
<p>275、自身有待改进的地方</p>
<p>276、n长的数组放入n+1个数，不能重复，找出那个缺失的数</p>
<p>277、手里有什么offer</p>
<p>278、你对于第一份工作最看重的三个方面是什么？</p>
<p>279、如何评价现在的前端？</p>
<p>280、用原生js实现复选框选择以及全选非全选功能</p>
<p>281、用4个颜色给一个六面体上色有多少种情况</p>
<p>282、amd和cmd区别</p>
<p>283、为什么选择前端，移动端性能优化</p>
<p>284、vue的特点？双向数据绑定是如何实现的</p>
<p>285、Object.defineProperty</p>
<p>286、算法题：数组去重，去除重复两次以上的元素，代码题：嵌套的ul-li结构，根据input中输入的内容，去除相应的li节点，且如果某个嵌套的ul下面的li都被移除，则该ul的父li节点也要被移除</p>
<p>287、页面加载过程</p>
<p>288、浏览器如何实现图片缓存</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">manyfish</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2021/07/19/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/">http://example.com/2021/07/19/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">ManyFish's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/Banner_img.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/07/23/%E9%AB%98%E7%BA%A7%E7%B1%BB%E5%9E%8B%E5%8F%8A%E6%98%A0%E5%B0%84%E7%B1%BB%E5%9E%8B/"><img class="prev-cover" src="/img/Banner_img.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info"></div></div></a></div><div class="next-post pull-right"><a href="/2021/07/15/%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%8F%92%E6%A7%BD%E4%B8%8E%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BB%84%E4%BB%B6/"><img class="next-cover" src="/img/Banner_img.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info"></div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/head_img.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">manyfish</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">24</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="/" target="_blank" title=""><i></i></a><a class="social-icon" href="/i" target="_blank" title=""><i class="1"></i></a><a class="social-icon" href="/m" target="_blank" title=""><i class="2"></i></a><a class="social-icon" href="/g" target="_blank" title=""><i class="3"></i></a><a class="social-icon" href="/" target="_blank" title=""><i class="4"></i></a><a class="social-icon" href="/h" target="_blank" title=""><i class="5"></i></a><a class="social-icon" href="/e" target="_blank" title=""><i class="6"></i></a><a class="social-icon" href="/a" target="_blank" title=""><i class="7"></i></a><a class="social-icon" href="/d" target="_blank" title=""><i class="8"></i></a><a class="social-icon" href="/_" target="_blank" title=""><i class="9"></i></a><a class="social-icon" href="/i" target="_blank" title=""><i class="10"></i></a><a class="social-icon" href="/m" target="_blank" title=""><i class="11"></i></a><a class="social-icon" href="/g" target="_blank" title=""><i class="12"></i></a><a class="social-icon" href="/." target="_blank" title=""><i class="13"></i></a><a class="social-icon" href="/j" target="_blank" title=""><i class="14"></i></a><a class="social-icon" href="/p" target="_blank" title=""><i class="15"></i></a><a class="social-icon" href="/g" target="_blank" title=""><i class="16"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#VUE%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">1.</span> <span class="toc-text">VUE面试题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Webpack-%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">2.</span> <span class="toc-text">Webpack 面试题</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/08/28/%E9%9D%A2%E8%AF%95%E9%A2%98/" title="前端面试题">前端面试题</a><time datetime="2021-08-27T16:00:00.000Z" title="发表于 2021-08-28 00:00:00">2021-08-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/07/23/%E9%AB%98%E7%BA%A7%E7%B1%BB%E5%9E%8B%E5%8F%8A%E6%98%A0%E5%B0%84%E7%B1%BB%E5%9E%8B/" title="无题">无题</a><time datetime="2021-07-23T03:25:35.589Z" title="发表于 2021-07-23 11:25:35">2021-07-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/07/19/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/" title="无题">无题</a><time datetime="2021-07-19T09:17:35.287Z" title="发表于 2021-07-19 17:17:35">2021-07-19</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/07/15/%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%8F%92%E6%A7%BD%E4%B8%8E%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BB%84%E4%BB%B6/" title="无题">无题</a><time datetime="2021-07-15T06:34:35.120Z" title="发表于 2021-07-15 14:34:35">2021-07-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/07/13/%E7%BC%96%E5%86%99Form-Generate%E7%BB%84%E4%BB%B6/" title="无题">无题</a><time datetime="2021-07-13T08:57:45.589Z" title="发表于 2021-07-13 16:57:45">2021-07-13</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By manyfish</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="rightside.chat_btn"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'AFItm5az9ElXBoaK1FVBD0WI-gzGzoHsz',
      appKey: 'zxKTlpuHwpY4p7brYypV5sB2',
      placeholder: 'o(*￣▽￣*)ブ欢迎吐槽',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'en',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      path: window.location.pathname,
      requiredFields: ["nick,mail"],
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><link rel="stylesheet" href="css/Lete.css"><script data-pjax src="js/Lete.js"></script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-show-text.min.js" data-mobile="true" data-text="♥好多愚♥,♥欢迎♥" data-fontsize="15px" data-random="true" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>